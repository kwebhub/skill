<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <meta name="robots" content="none">
  <meta name="robots" content="noimageindex, nofollow">
  <title>Layout</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <div class="wrapper">
    <div class="main__container">
      <div class="logo"><a href="../">MAY THE FORCE BE WITH YOU</a></div>
      <div class="menu__inner">
        <nav class="menu"><!--Menu-->
          <a href="https://www.freelancer.com/">freelancer</a> <br>
          <a href="https://www.upwork.com/freelance-jobs/">upwork</a> <br>
          <a href="https://www.youtube.com/watch?v=8Vl15qYG3GU">upwork youtube</a> <br>
          <a href="https://www.fiverr.com/">fiverr</a> <br>
          <a href="https://www.youtube.com/watch?v=cZ-IJvoKlqQ">fiverr youtube</a> <br>
          <a href="https://www.reqres.in/">Создать веб-приложение</a> <br>
          <br>
          <details class="menu__item"><!--HTML-->
            <summary>HTML</summary>
            <div class="menu__inner">
              <p><a href="https://www.w3schools.com/tags/default.asp" target="_blank">HTML</a>
                (от англ. <i>HyperText Markup Language</i> — «язык гипертекстовой разметки») стандартизированный язык разметки
                документов во Всемирной паутине.
              </p>
<pre>
<details><!--Service-->
  <summary><em>Service</em></summary><small>
    <span class="menu__komment">Тип документа</span>
    < <b>!DOCTYPE</b> html >
  
    <span class="menu__komment">Корень HTML-документа</span>
    < <b>html</b>><i>Документ</i>< /<b>html</b>>
  
    <span class="menu__komment">Содержит метаданные/информацию для документа, блочный</span>
    < <b>head</b>> <i>Служебная информация</i> < /<b>head</b>>
  
    <span class="menu__komment">Название сайта, которое отображается во вкладке</span>
    < <b>title</b>><i>Текст</i>< /<b>title</b>>
  
    <span class="menu__komment">Связывает с документом другой документ, блочный</span>
    < <b>link</b> rel="stylesheet" href="styles.css">
  
    <span class="menu__komment">JS вставка</span>
    < <b>script</b>><i>Ссылка или код</i>< /<b>script</b>>
  
    <span class="menu__komment">CSS вставка</span>
    < <b>style</b>><i>Ссылка или код</i>< /<b>style</b>>
  
    <span class="menu__komment">Тело документа, блочный</span>
    < <b>body</b>><i>Тело документа</i>< /<b>body</b>>
  
    <span class="menu__komment">Заголовок документа или раздела, блочный</span>
    < <b>header</b>><i>Шапка сайта</i>< /<b>header</b>>
  
    <span class="menu__komment">Навигационные ссылки, блочный</span>
    < <b>nav</b>>
      < <b>a</b> href=""><i>Навигация или меню</i>< /<b>a</b>>
    < /<b>nav</b>>
  
    <span class="menu__komment">Основное содержимое документа, блочный</span>
    < <b>main</b>><i>Основная часть сайта</i>< /<b>main</b>>
  
    <span class="menu__komment">Боковая панель сайта, второстепенный контент</span>
    < <b>aside</b> ><i>Контент</i>< /<b>aside</b> >
  
    <span class="menu__komment">Контейнер, блочный</span>
    < <b>div</b>><i>Контент</i> < /<b>div</b>>
  
    <span class="menu__komment">Контейнер для внешнего приложения, блочный</span>
    < <b>embed</b> type="text/html" src="snippet.html" width="500" height="200">
  
    <span class="menu__komment">Контейнер для внешнего приложения, блочный</span>
    < <b>object</b> data="" width="" height="">< /<b>object</b>>
  
    <span class="menu__komment">Встроенный фрейм (страница в странице)</span>
    < <b>iframe</b> src="" title="">< /<b>iframe</b>>
  
    <span class="menu__komment">Кликабельная кнопка, блочный</span>
    < <b>button</b> type="button"><i>Кнопка</i>< /<b>button</b>>
  
    <span class="menu__komment">Комментарий, строчный</span>
    < <b>!--</b> <i>Комментарий</i> <b>--</b> >
  
    <span class="menu__komment">Нижний колонтитул документа или раздела, блочный</span>
    < <b>footer</b>><i>Подвал сайта</i>< /<b>footer</b>>
  
    <span class="menu__komment">Альтернативный контент при не поддержании JS</span>
    < <b>noscript</b>><i>Текст</i>< /<b>noscript</b>>
  
    <span class="menu__komment">Контейнер для контента, который должен быть скрыт при загрузке страницы</span>
    < <b>template</b>><i>Контент</i>< /<b>template</b>>
  </small>
</details>
<details><!--Content_group-->
  <summary><em>Content_group</em></summary><small>
    <span class="menu__komment">Группировка связанных элементов в независимый объект</span>
    < <b>article</b> ><i>Cтатья</i>< /<b>article</b> >
  
    <span class="menu__komment">Заголовок и связанный контент, блочный</span>
    < <b>hgroup</b>><i>Заголовок и контент</i>< /<b>hgroup</b>>
  
    <span class="menu__komment">Тематическое изменение содержания (линия), блочный</span>
    < <b>hr</b>>
  
    <span class="menu__komment">Спойлер, блочный</span>
    < <b>details</b>>
      < <b>summary</b>><i>Tекст</i>< /<b>summary</b>>
      < <b>p</b>><i>Tекст</i>< /<b>p</b>>
    < /<b>details</b>> 
  
    <span class="menu__komment">Список определений, блочный</span>
    < <b>dl</b>>
      < <b>dt</b>><i>Термин</i>< /<b>dt</b>>
      < <b>dd</b>><i>Значение термина</i>< /<b>dd</b>>
    < /<b>dl</b>>
  
    <span class="menu__komment">Список, блочный</span>
    < <b>ol</b>>     <span class="menu__komment">Упорядоченный список, блочный</span>
      < <b>li</b>><i>Текст</i>< /<b>li</b>>  <span class="menu__komment">Элемент списка, блочный</span>
      ...
    < /<b>ol</b>>
  
    <span class="menu__komment">Список, блочный</span>
    < <b>ul</b>>     <span class="menu__komment">Неупорядоченный список, блочный</span>
      < <b>li</b>><i>Текст</i>< /<b>li</b>>  <span class="menu__komment">Элемент списка, блочный</span>
      ...
    < /<b>ul</b>>
  
    <span class="menu__komment">Неупорядоченный список, блочный</span>
    < <b>menu</b>>
    < <b>li</b>><i>Текст</i>< /<b>li</b>>  <span class="menu__komment">Элемент списка, блочный</span>
      ...
    < /<b>menu</b>>
  
    <span class="menu__komment">Группу связанных параметров в раскрывающемся списке</span>
    < <b>optgroup</b> label="">
      < <b>option</b> value=""><i>Текст</i>< /<b>option</b>>
      ...
    < /<b>optgroup</b>>
  
    <span class="menu__komment">Раскрывающийся список</span>
    < <b>label</b> for="cars"><i>Текст</i>< /<b>label</b>>
    < <b>select</b> name="cars" id="cars">
      < <b>option</b> value=""><i>Текст</i>< /<b>option</b>>
      ...
    < /<b>select</b>>
  
    <span class="menu__komment">Раздел в документе</span>
    < <b>section</b>><i>Текст</i>< /<b>section</b>>
  </small>
</details>
<details><!--Text-->
  <summary><em>Text</em></summary><small>
    <span class="menu__komment">Аббревиатура или акроним, строчный</span>
    < <b>abbr</b> title="Расшифровка"> <i>Aббревиатура</i> < /<b>abbr</b> >
    
    <span class="menu__komment">Вывод контактной информации, строчный</span>
    < <b>address</b> ><i>Контакная информация</i>< /<b>address</b> >
    
    <span class="menu__komment">Жирный текст, строчный</span>
    < <b>b</b>><i>Жирный текст</i>< /<b>b</b>>
  
    <span class="menu__komment">Меньший текст, строчный</span>
    < <b>small</b>><i>Текст</i>< /<b>small</b>>
  
    <span class="menu__komment">Часть текста в строке, строчный</span>
    < <b>span</b>><i>Текст</i>< /<b>span</b>>
  
    <span class="menu__komment">Текст большой важности, строчный</span>
    < <b>strong</b>><i>Текст</i>< /<b>strong</b>>
  
    <span class="menu__komment">Подчеркнутый текст, строчный</span>
    < <b>u</b>>Текст< /<b>u</b>>
  
    <span class="menu__komment">Построчный текст</span>
    < <b>sub</b>><i>Текст</i>< /<b>sub</b>>
  
    <span class="menu__komment">Надстрочный текст</span>
    < <b>sup</b>><i>Текст</i>< /<b>sup</b>>
    
    <span class="menu__komment">Изолирует часть текста, строчный</span>
    < <b>bdi</b>><i>Текст</i>< /<b>bdi</b>>
    
    <span class="menu__komment">Переопределяет направление текста, строчный</span>
    < <b>bdo</b> dir="rtl"><i>Текст</i>< /<b>bdo</b>>
    
    <span class="menu__komment">Раздел, цитируемый из другого источника, блочный</span>
    < <b>blockquote</b> cite="ссылка на источник"><i>Текст</i>< /<b>blockquote</b>>
  
    <span class="menu__komment">Цитата</span>
    < <b>q</b>><i>Текст</i>< /<b>q</b>>
  
    <span class="menu__komment">Вывод даты и времени</span>
    < <b>time</b>><i>Текст</i>< /<b>time</b>>
  
    <span class="menu__komment">Разрыв строки, строчный</span>
    < <b>br</b> >
  
    <span class="menu__komment">Название произведения, вывод автора цитаты, строчный</span>
    < <b>cite</b>><i>Название</i>< /<b>cite</b>>
  
    <span class="menu__komment">Часть компьютерного кода, строчный</span>
    < <b>code</b>><i>Код</i>< /<b>code</b>>
  
    <span class="menu__komment">Ассоциирует название продукта с номером продукта, строчный</span>
    < <b>data</b> value="номер продукта"><i>Название продукта</i>< /<b>data</b>>
  
    <span class="menu__komment">Перечеркнутый текст, строчный</span>
    < <b>del</b>><i>Перечеркнут</i>< /<b>del</b>>
  
    <span class="menu__komment">Термин, который будет определен, строчный</span>
    < <b>dfn</b>><i>Термин</i>< /<b>dfn</b>>
  
    <span class="menu__komment">Выделенный текст, текст с ударением (более громко), строчный</span>
    < <b>em</b>><i>Текст</i>< /<b>em</b>>
  
    <span class="menu__komment">h1 - h6, Заголовок, блочный</span>
    < <b>h1</b>><i>Заголовок</i>< /<b>h1</b>>
  
    <span class="menu__komment">Текст курсивом. Текст, который отличается (иностранное слово, мысли и т.д.), строчный</span>  
    < <b>i</b>><b>Курсив</b>< /<b>i</b>>
  
    <span class="menu__komment">Текст, который был вставлен, строчный</span>
    < <b>ins</b>><i>Текст</i>< /<b>ins</b>>
  
    Текст, как ввод с клавиатуры, строчный</span>
    < <b>kbd</b>><i>Текст</i>< /<b>kbd</b>>
  
    <span class="menu__komment">Отмеченный/выделенный текст особого внимания, строчный</span>
    < <b>mark</b>><i>Текст</i>< /<b>mark</b>>
  
    <span class="menu__komment">Неправильныйт текст</span>
    < <b>s</b>><i>Текст</i>< /<b>s</b>>
  
    <span class="menu__komment">Текст как вывод компьютерной программы</span>
    < <b>samp</b>><i>Текст</i>< /<b>samp</b>>
  
    <span class="menu__komment">Текст как переменная</span>
    < <b>var</b>><i>Текст</i>< /<b>var</b>>
    
    <span class="menu__komment">Возможный разрыв строки</span>
    < <b>wbr</b>>
  
    <span class="menu__komment">Параграф, блочный</span>
    < <b>p</b>><i>Текст</i>< /<b>p</b>>
  
    <span class="menu__komment">Предварительно отформатированный текст, блочный</span>
    < <b>pre</b>><i>Текст</i>< /<b>pre</b>>
  
    <span class="menu__komment">Аннотация Ruby (для восточноазиатской типографики)</span>
    < <b>ruby</b>>
      漢 < <b>rp</b>> <i>(</i> < /<b>rp</b>>< <b>rt</b>> <i>ㄏㄢˋ</i> < /<b>rt</b>>< <b>rp</b>> <i>)</i> < /<b>rp</b>>
    < /<b>ruby</b>>
  </small>
</details>
<details><!--Link-->
  <summary><em>Link</em></summary><small>
    <span class="menu__komment">Гиперссылка</span>
    < <b>a</b> href="ссылка" ><i>Текст</i>< /<b>a</b> >
    
    <span class="menu__komment">Базовый URL-адрес для всех относительных URL-адресов в документе, строчный</span>
    < <b>base</b> href="...">
  </small>
</details>
<details><!--Graphic-->
  <summary><em>Graphic</em></summary><small>
    <span class="menu__komment">Рисование графики на лету, блочный</span>
    < <b>canvas</b> id="myCanvas">
    Your browser does not support the canvas tag.
    < /<b>canvas</b>>
  
    <span class="menu__komment">Контейнер для графики SVG, блочный</span>
    < <b>svg</b> width="" height="">
      < <b>circle</b> cx="" cy="" r="" stroke="" stroke-width="" fill="" />
    < /<b>svg</b>>
  </small>
</details>
<details><!--Image-->
  <summary><em>Image</em></summary><small>
    <span class="menu__komment">Карта-изображения</span>
    < <b>img</b> src="" alt="" usemap="#workmap">
    < <b>map</b> name="workmap">
      < <b>area</b> shape="rect" coords="34,44,270,350" alt="Computer" href="computer.htm" >
    < /<b>map</b>>
    
    <span class="menu__komment">Изображение, строчный</span>
    < <b>img</b> src="" alt="">
  
    <em>Тег picture</em> - <span class="menu__komment">контейнер для нескольких ресурсов изображений, блочный,
      позволяет выводить нужное изображение в зависимости от условий. Адаптив без css, ускоряет загрузку верстки.
      Если браузер не поддерживает picture, то выведет img.</span>
    <span class="menu__komment">Kонтейнер </span>
    < <b>picture</b>>
      < <b>source</b> media="" srcset="">
      ...
      < <b>img</b> src="" alt="">
    < /<b>picture</b>>
  </small>
</details>
<details><!--Form-->
  <summary><em>Form</em></summary><small>
    <span class="menu__komment">Таблица, блочный</span>
    < <b>table</b>>
    < <b>caption</b>><i>Название</i>< /<b>caption</b>>    <span class="menu__komment">Название таблицы, блочный</span>
      < <b>thead</b>>   <span class="menu__komment">Шапка таблицы, блочный</span>
        < <b>tr</b>>    <span class="menu__komment">Строка таблицы, блочный</span>
          < <b>th</b>><i>Текст</i>< /<b>th</b>>   <span class="menu__komment">Ячейка шапки таблицы, блочный</span>
        < /<b>tr</b>>
      < /<b>thead</b>>
      < <b>tbody</b>>   <span class="menu__komment">Тело таблицы, блочный</span>
        < <b>tr</b>>
          < <b>td</b>><i>Текст</i>< /<i>td</i>>   <span class="menu__komment">Ячейка тела таблицы, блочный</span>
        < /<i>tr</i>>
      < /<b>tbody</b>>
      < <b>tfoot</b>>   <span class="menu__komment">Подвал таблицы, блочный</span>
        < <b>tr</b>>
          < <b>td</b>>Текст< /<b>td</b>>
        < /<b>tr</b>>
      < /<b>tfoot</b>>
    < /<b>table</b>>
  
    <span class="menu__komment">Группа столбцов в таблице</span>
    < <b>colgroup</b>>
      < <b>colspan</b>="2">
    < /<b>colgroup</b>>
  
    <span class="menu__komment">Диалоговое окно, блочный</span>
    < <b>dialog</b> open> <i>Сообщение</i> < /<b>dialog</b>>
  
    <span class="menu__komment">Поле многострочного ввода (текстовая область)</span>
    < <b>textarea</b> rows="" cols=""><i>Текст</i>< /<b>textarea</b>>
  
    <span class="menu__komment">HTML-форма для ввода пользователя. Отвечает за отправку введенных данных,
    адрес передачи - атрибут action, метод передачи - атрибут method</span>
    < <b>form</b> action="/action_page.php">
      < <b>fieldset</b>>       <span class="menu__komment">Групперует элементы формы</span>
        < <b>legend</b>><i>Personalia:</i>< /<b>legend</b>>      <span class="menu__komment">Заголовок формы</span>
        < <b>label</b> for="fname"><i>First name:</i>< /<b>label</b>>    <span class="menu__komment">Заголовок поля</span>
        < <b>input</b> type="text" id="fname" name="fname">
        ...
        < <b>input</b> type="submit" value="Submit">
      < /<b>fieldset</b>>
    < /<b>form</b>>
  
    <span class="menu__komment">Форма с предопределённым списком вариантов для поля ввода</span>
    < <b>form</b> action="/action_page.php" method="get">
      < <b>label</b> for="browser"><i>Choose your browser from the list:</i>< /<b>label</b>>
      < <b>input</b> list="browsers" name="browser" id="browser">
      < <b>datalist</b> id="browsers">
        < <b>option</b> value="Edge">
        < <b>option</b> value="Firefox">
        < <b>option</b> value="Chrome">
        < <b>option</b> value="Opera">
        < <b>option</b> value="Safari">
      < /<b>datalist</b> >
      < <b>input</b> type="submit">
    < /<b>form</b> >
  
    <span class="menu__komment">Раздел поиска</span>
      < <b>search</b>>
        < <b>form</b>>
        < <b>input</b> name="" id="" placeholder="">
        < /<b>form</b>>
      < /<b>search</b>>
  
    <span class="menu__komment">Результат расчета</span>
    < <b>form</b> oninput="x.value=parseInt(a.value)+parseInt(b.value)">
      < <b>input</b> type="range" id="a" value="50">
      +< <b>input</b> type="number" id="b" value="25">
      =< <b>output</b> name="x" for="a b">< /output>
    < /<b>form</b>>
  
    <span class="menu__komment">Скалярное измерение в известном диапазоне (манометр)</span>
    < <b>label</b> for="idname"><i>Текст</i>< /<b>label</b>>
    < <b>meter</b> id="idname" value=""><i>Текст</i>< /<b>meter</b>>
  
    <span class="menu__komment">Представляет ход выполнения задачи, блочный</span>
    < <b>label</b> for="file"><i>Downloading progress:</i>< /<b>label</b>>
    < <b>progress</b> id="file" value="32" max="100"> <i>32%</i> < /<b>progress</b>>
  </small>
</details>
<details><!--Media_content-->
  <summary><em>Media_content</em></summary><small>
    <span class="menu__komment">Групировка медиа-элементов, блочный</span>
    < <b>figure</b>>
      < <b>img</b> src="" alt="">
      < <b>figcaption</b>><i>Текст</i>< /<b>figcaption</b>>
    < /<b>figure</b>>
  
    <span class="menu__komment">Встроенный аудио контент</span>
    < <b>audio</b> controls>
      < <b>source</b> src="horse.ogg" type="audio/ogg">
      < <b>source</b> src="horse.mp3" type="audio/mpeg">
      < <b>track</b> src="" kind="" srclang="" label="">    <span class="menu__komment">текстовые дорожки</span>
      Your browser does not support the audio tag.
    < /<b>audio</b>>
  
    <span class="menu__komment">Встроенный видио контент, блочный
    формат МР4 - наиболее распространен,
    формат Webm - хорошо оптимизируется и позволяет воспроизводить видео на прозрачном фоне</span>
    < <b>video</b> width="" height="" controls>
      < <b>source</b> src="" type="">
      < <b>track</b> src="" kind="" srclang="" label="">    <span class="menu__komment">текстовые дорожки</span>
    < /<b>video</b>>
  </small>
</details>
<details><!--Мета тег-->
  <summary><em>Мета тег</em></summary><small>
    < meta charset="UTF-8"> - <span class="menu__komment">Кодировка</span>
    < meta name="viewport" content="width=1170"> - <span class="menu__komment">фиксированная ширина вся помещается в экран</span>
    < meta name="viewport" content="width=device-width"> - <span class="menu__komment">адаптивный</span>
    < meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
    - <span class="menu__komment">параметры адаптивности</span>
    < meta name="format-detection" content="telephone=no"> - <span class="menu__komment">отключает ссылку у номера телефона на iOS</span>
    < meta name="description" content="<i>описание до 140 символов</i>"> - <span class="menu__komment">для SEO</span>
    < meta name="keywords" content="<i>ключевые слова через запятую до 20</i>"> - <span class="menu__komment">ключевые слова для SEO</span>
  
  <em>доступ поисковых роботов к страице</em>:
    < meta name="robots" content="noindex, nofollow">
    < meta name="robots" content="none">
    < meta name="robots" content="noimageindex, nofollow"> - <span class="menu__komment">запрет индексации картинок и ссылок</span>
  
  <em>технические</em>:
    < meta name="Author" content="<i>Дарт Вейдер</i>"> - <span class="menu__komment">Автор страницы</span>
    < meta name="Copyright" content="<i>Люк Скайвокер</i>"> - <span class="menu__komment">Авторские права</span>
    < meta name="Address" content="<i>Татуин, кратер № 97</i>"> - <span class="menu__komment">Адрес автора</span>
    < meta http-equiv="refresh" content="0; url="> - <span class="menu__komment">обновляет страницу либо перенаправляет пользователя,
    указать количество секунд до перенаправления и адрес страницы</span>
  
  <em>социальные сети</em>:
    < meta property="og:locale" content="<i>ru_RU</i>"> - <span class="menu__komment">локализация для русcкоязычного сайта</span>
    < meta property="og:type" content="<i>article</i>"> - <span class="menu__komment">тип контента статья</span>
    < meta property="og:title" content="<i>META теги</i>"> - <span class="menu__komment">заголовок записи в социальной сети</span>
    < meta property="og:description" content="<i>описание страницы</i>"> - <span class="menu__komment">описание страницы</span>
    < meta property="og:image" content="http://fls.guru/meta/img/bg.jpg"> - <span class="menu__komment">изображение для записи в соцсети</span>
    < meta property="og:url" content="http://fls.guru/meta/ "> - <span class="menu__komment">ссылка на текущую страницу</span>
    < meta property="og:site_name" content="<i>Название сайта</i>"> - <span class="menu__komment">Название сайта</span>
  
  Facebook https://developers.facebook.com/tools/debug/sharing/
  https://ruogp.me/
  
    < meta name="twitter:card" content="<i>summary</i>"> - <span class="menu__komment">тип карты твитер</span>
    < meta name="twitter:site" content="<i>Автор</i>"> - <span class="menu__komment">имя/логин автора</span>
    < meta name="twitter:title" content="<i>META теги</i>"> - <span class="menu__komment">название страницы</span>
    < meta name="twitter:description" content="<i>описание страницы</i>"> - <span class="menu__komment">описание страницы</span>
    < meta name="twitter:image" content="http://fls.guru/meta/img/bg.jpg"> - <span class="menu__komment">изображение для записи в соцсети</span>
  
  https://cards-dev.twitter.com/validator
  https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started
  </small>
</details>
<span class="menu__komment">Валидаторы HTML:</span>
  <a href="https://caninclude.glitch.me/">glitch</a>
  <a href="https://validator.w3.org/">w3</a>
</pre>
            </div>
          </details>
          <details class="menu__item"><!--CSS-->
            <summary>CSS</summary>
            <div class="menu__inner">
              <p><em>Стилем или CSS</em> (<i>Cascading Style Sheets, каскадные таблицы стилей</i>) <br>
                называется набор параметров форматирования,
                который применяется к элементам документа,
                чтобы изменить их внешний вид.
                <ul><em>Достоинства</em>:
                    <li>Разграничение кода и оформления</li>
                    <li>Разное оформление для разных устройств</li>
                    <li>Расширенные по сравнению с HTML способы оформления элементов</li>
                    <li>Ускорение загрузки сайта</li>
                    <li>Единое стилевое оформление множества документов</li>
                </ul>
<pre><small>
  <em>Применение</em>:
  <span class="menu__komment">Внутренние стили. Приоритет максимальный.</span>
  < <b>h1</b> <em>style</em>="color: red;"><i>Текст</i>< /<b>h1</b>>
  
  <span class="menu__komment">Глобальные стили</span>
  < <b>style</b>>
    <em>h1</em> {
      color: red;
    }
  < /<b>style</b>>

  <span class="menu__komment">Связанные стили</span>
  < <b>link</b> rel="stylesheet" href="<i>путь/к файлу/CSS</i>">
</small>
</pre>
              </p>
<pre>
<details><!--Синтаксис-->
  <summary>Синтаксис</summary><small>
div.text {}  <span class="menu__komment">применяем css-свойство к тегу div с классом text</span>
.block.text {}  <span class="menu__komment">применяем к тегам, содержащим оба класса</span>
.block,.text {}  <span class="menu__komment">применяем к тегам, содержащим один из классов</span>
.block .text {}  <span class="menu__komment">применяем к тегам, содержащим класс text и находящийся внутри элемента с классом block</span>
.text > div {}  <span class="menu__komment">применяем к первому div верхнего уровня внутри элемента с классом text</span>
.block + .text <span class="menu__komment">sibling</span>
.block : hover <span class="menu__komment">псевдоклассы состояния: hover, active, target, focus, 
  псевдоклассы навигации: first child, last child, first off type, last off type, not</span>
.block :: after <span class="menu__komment">псевдоэлементы: before, after</span>

@import "имя файла"; - <span class="menu__komment">импорт файлов</span>

<em>Параметр в качестве селектора</em>:
[class*="__container"] {}  <span class="menu__komment">применяем css-свойство ко всем элементам с атрибутом class,
                            значение которого содержит __container</span>

<em>Шрифты</em>
<span class="menu__komment">подключаем любо в html тегом <b>link</b> либо в scss через <b>@import</b></span>
fonts.google.com
nomail.com.ua
font2web.com

<em>БЭМ</em>
- блок - <span class="menu__komment">часть кода, которая повторяется или может повторяться самостоятельно</span>
- элемент - <span class="menu__komment">это часть блока. имя класса блока__имя класса элемента</span>
- модификатор - <span class="menu__komment">дополняет или уточняет стиль блока или элемента</span>
<small>
  имя класса блока_модификатор
  имя класса блока__имя класса элемента_модификатор
  микс - позволяет использовать блоки и элементы в одном объекте
</small>
Источник: ru.bem.info
  </small>
</details>
<details><!--Единицы измерения-->
  <summary>Единицы измерения</summary><small>
<em>Абсолютные</em>
<b>px</b> (пиксель)  <span class="menu__komment">Все остальные еденицы измерения пересчитываются браузером в пиксели</span>

<em>Относительные</em>
<b>em</b> - <span class="menu__komment">равен текущему размеру объекта.
            Лучше использовать для медиа-запросов и в случае когда нужно привязаться к текущему размеру шрифта.</span>
<b>rem</b> - <span class="menu__komment">равен размеру шрифта в теге html, а если там нет, то браузера по умолчанию (16px). 
            Т.е. не зависит от резмаера шрифта родителя.
            Лучше использовать для размеров шрифтов, отступов, не указывая размер для тега html.</span>
<b>%</b> - <span class="menu__komment">разные свойства css вычисляют % от разных оснований.
            Лучше использовать для отзывчивых резиновых конструкций, для позиционирования объектов и для скрола.</span>
<b>vw, vh, vmin, vmax</b> - <span class="menu__komment">работают относительно окна браузера (viewport).
            Лучше использовать для полноэкранных блоков и scss вычислений.</span>
<b>fr</b> - <span class="menu__komment">единица измерения в модуле grid.</span>
<b>ex</b> - <span class="menu__komment">единица измерения относительно размера прописной "е".</span>
<b>ch</b> - <span class="menu__komment">единица измерения относительно размера 0.</span>
  </small>
</details>
<details><!--Обнуление стилей-->
<summary>Обнуление стилей</summary><small>
  <em>Убираем отступы</em>:
  *{
    padding: 0;
    margin: 0;
    border: 0;
  }
  
  <em>Изменение ширины блока</em>:
  *,*:before,*:after{
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
  }
  
  <em>Снятие обводки елементов по умолчанию</em>:
  :focus,:active {outline: none;}
  a:focus,a:active {outline: none;}
  
  <em>Делаем теги блочными</em>:
  nav,footer,header,aside {display: block;}
  
  <em>Уравнять поведение шрифтов в разных браузерах</em>:
  html,body{
    height: 100%;
    width: 100%;
    font-size: 100%;
    line-height: 1;
    font-size: 14px;
    -ms-text-size-adjust: 100%;
    -moz-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
  }
  
  <em>Теги формы наследуют семейство шрифта</em>:
  input,button,textarea {font-family: inherit;}
  
  <em>Убираем отличительные особенности браузеров</em>:
  input::-ms-clear {display: none;}
  button {cursor: pointer;}
  button::-moz-focus-inner {padding:0; border:0;}
  a,a:visited {text-decoration: none;}
  a:hover {text-decoration: none;}
  ul li {list-style: none;}
  img {vertical-align: top;}
  
  <em>Обнуляем стили заголовков</em>:
  h1,h2,h3,h4,h5,h6 {font-size:inherit; font-weight: 400;}
</small>
</details>
<details><!--Свойства-->
<summary>Свойства</summary><small>
  <em>Текст</em>
  font-family - <span class="menu__komment">семейство шрифта.</span>
  font-size - <span class="menu__komment">размер шрифта елемента.</span>
  font-style - <span class="menu__komment">начертание шрифта (курсив, наклон и нормальный)</span>
  font-weight - <span class="menu__komment">насыщенность (вес) шрифта</span>
  color - <span class="menu__komment">цвет текста</span>
  text-align - <span class="menu__komment">горизонтальное выравнивание текста</span>
  text-decoration - <span class="menu__komment">оформление текста (подчеркивание, перечеркивание и т.д.)</span>
  text-shadow - <span class="menu__komment">добавляет тень к тексту</span>
  text-transform - <span class="menu__komment">преобразование заглавных и прописных символов</span>
  text-ident - <span class="menu__komment">отступ первой строки от края блока</span>
  letter-spacing - <span class="menu__komment">определяет интервал между символами</span>
  word-spacing - <span class="menu__komment">определяет интервал между словами</span>
  white-space - <span class="menu__komment">управляет свойствами пробелов между словами</span>
  line-height - <span class="menu__komment">устанавливает межстрочный интервал текста</span>

  <em>Геометрия</em>
  padding - <span class="menu__komment">внутренний отступ блочных тегов</span>
  margin - <span class="menu__komment">внешний отступ блочных тегов</span>
  width - <span class="menu__komment">ширина блочных тегов</span>
  max-width - <span class="menu__komment">устанавливает макимальную ширину блочных тегов</span>
  min-width - <span class="menu__komment">устанавливает минимальную ширину блочных тегов</span>
  height - <span class="menu__komment">устанавливает высоту блочных тегов</span>
  max-height - <span class="menu__komment">устанавливает максимальную высоту блочных тегов</span>
  min-height - <span class="menu__komment">устанавливает минимальную высоту блочных тегов</span>

  <em>Отоброжение</em>
  overflow - <span class="menu__komment">управляет отображением содержания блочного елемента</span>
  display - <span class="menu__komment">определяет как елемент должен быть показан в документе</span>
  border - <span class="menu__komment">граница блока</span>
  border-radius - <span class="menu__komment">устанавливает радиус скругления уголков блока</span>
  outline - <span class="menu__komment">внешняя граница блока</span>
  box-shadow - <span class="menu__komment">добавляет тень к блоку</span>
  opacity - <span class="menu__komment">определяет уровень прозрачности элемента</span>
  visibility - <span class="menu__komment">отображение или скрытие блока</span>
  background - <span class="menu__komment">управляет фоном элемента</span>
  background-color - <span class="menu__komment">цвет фона элемента</span>
  background-image - <span class="menu__komment">фоновое изображение или градиентная заливка</span>
  background-repeat - <span class="menu__komment">повторение фонового изображения</span>
  background-position - <span class="menu__komment">положение фонового изображения</span>
  background-attachment - <span class="menu__komment">прокручивание фона вместе с содержимым элемента</span>
  background-size - <span class="menu__komment">размеры фонового изображения</span>
  background - <span class="menu__komment">позволяет задать несколько фоновых изображений одному блоку</span>
  background-origin и background-clip - <span class="menu__komment">отвечают за показ фона вместе с границей border.</span>

  <em>Псевдокласс</em> - <span class="menu__komment">это модификатор селектора</span>
  .link:hover{}
  :hover - <span class="menu__komment">срабатывает при наведении</span>
  :visited - <span class="menu__komment">срабатывает для посещенных ссылок</span>
  :active - <span class="menu__komment">срабатывает при нажатии на элемент</span>
  :focus - <span class="menu__komment">срабатывает при получении элементом фокуса</span>
  :first-child - <span class="menu__komment">обращение к первому элементу в блоке</span>
  :last-child - <span class="menu__komment">обращение к последнему элементу в блоке</span>
  :nth-child(номер элемента по порядку, odd, even) - <span class="menu__komment">обращение к конкретному элементу в блоке</span>

  <em>Псевдоэлемент</em>
  <span class="menu__komment">строчный, модификатор содержимого элемента, синтаксис</span>
  .text:hover::befor{} либо .text::first-line{}
  ::first-line{} - <span class="menu__komment">задает стиль первой строки текста</span>
  ::first-letter{} - <span class="menu__komment">задает стиль первого символа</span>
  ::before - <span class="menu__komment">для отображения контента до содержимого элемента, к которому применяется.
    Обязательное свойство <b>content</b>: '';</span>
  ::after - <span class="menu__komment">для отображения контента после содержимого элемента, к которому применяется.
    Обязательное свойство <b>content</b>: '';</span>

  <em>Позиционирование</em>
  position - <span class="menu__komment">совйство позиционирования устанавливает тип позиционирования элемента относительно 
  других элементов или окна браузера</span>
  position: static; - <span class="menu__komment">по умолчанию у всех блоков</span>
  position: relative; - <span class="menu__komment">положение относительно изначального места в коде, обязательно с:</span>
  left, top, right, bottom - <span class="menu__komment">управляют позицией элемента</span>
  z-index - <span class="menu__komment">управляет наложением элементов</span>
  position: absolute; - <span class="menu__komment">утрачивает связь с местом в коде и свойствами тега, обязательно с:</span>
  left, top, right, bottom - <span class="menu__komment">управляют позицией элемента
  Для взаиморасположения относительно друг друга у одного элемента должно быть absolute
  у другого relative</span>
  position: fixed; - <span class="menu__komment">фиксирует элемент относительно окна браузера не завися от элементов с relative и прокрутки</span>
  обязательно с: left, top, right, bottom - <span class="menu__komment">управляют позицией элемента</span>
  position: sticky; - <span class="menu__komment">переводит элемент из static в fixed при достижении элементом указаной позиции</span>
  обязательно с: left, top, right, bottom - <span class="menu__komment">управляют позицией элемента</span>

  <em>Трансформ</em>
  transform - <span class="menu__komment">применяется только к блочным объектам</span>
  transform: translate(0px, 0px); - <span class="menu__komment">translate сдвигает элемент на новое место</span>
  transform: scale(1, 1); - <span class="menu__komment">scale масштабирует изображения, т.е. zoom.
  При отрицательном значении - зеркалит.</span>
  transform: rotate(0deg); - <span class="menu__komment">поворачивает элемент.</span>
  Положительное значение по часовой, отрицетельное - против.
  transform: skew(0deg, 0deg); - <span class="menu__komment">деформирует стороны объекта по вертикали и горизонтали.</span>
  transform: matrix(a, b, c, d, e); - <span class="menu__komment">позволяет объединить трансформации. Значения без едениц измерения.</span>
  transform: translate(0px, 0px) scale(1, 1) rotate(0deg);
  transform-origin: center; - <span class="menu__komment">смещает центр трансформации</span>
  perspective: 0px; - <span class="menu__komment">установка глубины перспективы</span>
  perspective-origin: center; - <span class="menu__komment">смена точки начала координат</span>
  transform: translate3d(0px, 0px, 0px);
  transform: scale3d(1, 1, 1);
  transform: rotate3d(x, y, z, deg);
  transform: matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n); - <span class="menu__komment">16 значений</span>
  transform: translate3d(0px, 0px, 0px) rotate3d(1, 1, 1, 0deg);
  transform-style: flat; - <span class="menu__komment">задает стиль трансформации</span>
  backface-visibility: visible; - <span class="menu__komment">показывает обратную сторону объекта</span>
</small>
</details>
<details><!--Sass-->
<summary>Sass</summary><small>
  <em>Sass</em> - <span class="menu__komment">препроцессор, добавляет функционала в css</span>
  <em>SCSS</em> - <span class="menu__komment">синтаксис Sass похожий на синтаксис css</span>
  <em>Вложенность</em> - <span class="menu__komment">писать правила css внутрь других правил</span>
  <em>&</em> - <span class="menu__komment">подставляет вместо себя класс, внутри которого указан. Удобно для указания псевдоклассов и псевдо элементов</span> 
  <em>$var:80px;</em> - <span class="menu__komment">переменная var со значением 80 пикселей</span>
  
  <em>Шаблоны</em>:
  <b>%tpl</b> {параметры css} - <span class="menu__komment">задаём шаблон tpl</span>
  <b>@extend</b> %tpl; - <span class="menu__komment">вставляем в нужный блок правил css</span>
  либо
  <b>.tpl</b> {параметры css} - <span class="menu__komment">задаём шаблон tpl</span>
  <b>@extend</b> .tpl; - <span class="menu__komment">вставляем в нужный блок правил css</span>
  
  %message {
    <b>font-family</b>: sans-serif;
    <b>font-size</b>: 18px;
    <b>font-weight</b>: bold;
    <b>border</b>: 1px solid black;
    <b>padding</b>: 20px;
    <b>maigin</b>: 20px;
  }
  
  .success {
    <b>@extend %message</b>;
    <b>background-color</b>: green;
  }
  
  .warning {
    <b>@extend %message</b>;
    <b>background-color</b>: orange;
  }
  
  .error {
    <b>@extend %message</b>;
    <b>background-color</b>: red;
  }
  
  <em>Миксины</em>:
  @<b>mixin</b> exempl($var) {font-size: $var;} - <span class="menu__komment">объявляем миксин с переменной</span>
  @<b>include</b> exempl(100px); - <span class="menu__komment">вставляем в нужный блок правил css со значением
  поддерживает математические рассчеты</span>
  
  <em>Комментарии</em>:
  <b>/* */</b> - <span class="menu__komment">отображается и в файле scss и в css</span>
  <b>//</b> - <span class="menu__komment">отображается только в файле scss</span>
  
  Manual: https://sass-scss.ru/
</small>

</details>
<details><!--Flex-->
  <summary>Flex</summary><small>
  .counter {
    display: flex;
    flex-wrap: wrap;
  }

  .counter > div {
    background-color: green;
    font-size: 20px;
    margin: 20px;
    padding: 20px;
    width: 200px;
  }

  <b>display</b>: flex; - <span class="menu__komment">включает флекс разметку</span>
  <b>display</b>: inline-flex; - <span class="menu__komment">строчный флекс-контейнер</span>

  <b>justify-content</b> - <span class="menu__komment">определяет выравнивание вдоль основной оси</span>
  <b>justify-content</b>: flex-start; - <span class="menu__komment">елементы слева</span>
  <b>justify-content</b>: flx-end; - <span class="menu__komment">елементы справа</span>
  <b>justify-content</b>: cnter; - <span class="menu__komment">елементы в центре</span>
  <b>justify-content</b>: space-between; - <span class="menu__komment">пространство между елементами</span>
  <b>justify-content</b>: space-around; - <span class="menu__komment">пространство вокруг елементов</span>

  <em>для флекс-контейнера:</em>
  <b>align-items</b> - <span class="menu__komment">определяет поведение вдоль перекрёсной оси</span>
  <b>align-items</b>: stretch; - <span class="menu__komment">елементы подстраиваются под самый высокий</span>
  <b>align-items</b>: flex-start; - <span class="menu__komment">высота флекс-елемента от верха на высоту контента</span>
  <b>align-items</b>: flex-end; - <span class="menu__komment">высота флекс-елемента от низа на высоту контента</span>
  <b>align-items</b>: center; - <span class="menu__komment">флекс-елементы выстроятся по горизонтальному центру самого высокого елемента</span>
  <b>align-items</b>: baseline; - <span class="menu__komment">выстраивает флекс-елементы по базовой линии</span>
  <b>flex-wrap</b>: nowrap; - <span class="menu__komment">флекс-елементы не адаптируются</span>
  <b>flex-wrap</b>: wrap; - <span class="menu__komment">флекс-елементы адаптируются</span>
  <b>flex-wrap</b>: wrap-reverse; - <span class="menu__komment">флекс-елементы адаптируются в обратном порядке</span>

  <em>для флекс-елемента:</em>
  <b>align-self</b> - <span class="menu__komment">переопределяет выравнивание</span>
  <b>align-self</b>: stretch;
  <b>align-self</b>: center;
  <b>align-self</b>: flex-start;
  <b>align-self</b>: flex-end;

  <b>order</b> - <span class="menu__komment">порядок вывода елементов</span>
  <b>order</b>: 1; - <span class="menu__komment">выводим первым</span>
  <b>flex-basis</b> - <span class="menu__komment">базовый размер элемента</span>
  <b>flex-basis</b>: auto; - <span class="menu__komment">по размеру контента</span>

  <b>flex-grow</b> - <span class="menu__komment">возможность увеличиваться в размере</span>
  <b>flex-grow</b>: 0; - <span class="menu__komment">не больше чем flex-basis</span>
  <b>flex-shrink</b> - <span class="menu__komment">возможность уменьшаться в размере</span>
  <b>flex-shrink</b>: 1; - <span class="menu__komment">разрешено становиться меньше</span>
  <b>flex</b>: 0 1 auto; - <span class="menu__komment">короткая запись flex-grow flex-shrink flex-basis</span>

  <b>flex-direction</b> - <span class="menu__komment">устанавливает основную ось</span>
  <b>flex-direction</b>: row; - <span class="menu__komment">в ряд</span>
  <b>flex-direction</b>: row-reverse; - <span class="menu__komment">в обратную сторону в обратном порядке</span>
  <b>flex-direction</b>: column; - <span class="menu__komment">основная ось вертикально</span>
  <b>flex-direction</b>: column-revers; - <span class="menu__komment">вертикально снизу вверх
  https://fls.guru/flexbox.html</span>
  </small>
</details>
<details><!--GRID-->
<summary>GRID</summary><small>
  .somecontent {
    background-color: green;
    display: grid;
    padding: 20px;
    grip-column-gap: 20px;
    grip-row-gap: 10px;
    grid-template-columns: 200px 200px auto;
  }

  .somecontent-item {
    background-color: white;
    font-size: 20px;
    padding: 20px;
  }

<b>display</b>: grid; - <span class="menu__komment">определяет блочный грид-контейнер</span>
<b>display</b>: inline-grid; - <span class="menu__komment">определяет строчный грид-контейнер</span>
<b>grid-template-columns</b>: ; - <span class="menu__komment">управление колонками</span>
<b>grid-template-rows</b>: ; - <span class="menu__komment">управление рядами</span>
<b>grid-template-columns</b>: 200px minmax(150px, 1fr) 200px; - <span class="menu__komment">первая колонка шириной 200рх,
вторая - минимум 150рх и максимум на всю ширину грид-контейнера,
третья - шириной 200рх</span>
<b>grid-template-rows</b>: 1fr 1fr; - <span class="menu__komment">два ряда делят высоту грид-контейнера поровну</span>
<b>grid-template-columns</b>: fit-content(400px) 1fr auto; - <span class="menu__komment">ширина первой колонки по контенту, но не шире 400рх,
                вторая колонка - вся свободная ширина блока,
                третья колонка по ширине контента</span>
<b>grid-template-columns</b>: repeat(3, 1fr); - <span class="menu__komment">3 колонки размером 1fr</span>
<b>grid-template-areas</b>: ; - <span class="menu__komment"></span>управляет областями
<b>grid-area</b>: ; - <span class="menu__komment">применяется к елементам</span>
<b>grid-template</b>: repeat(2, 1fr) / repeat(3, 1fr); - <span class="menu__komment">две равные строки и три равные колонки</span>
<b>grid-template</b>:
[start] "header header" 100px [row2]
[row2]  "side content" 1fr [row-end] / 150px 1fr; - <span class="menu__komment">управление областями, 
            через свойство grid-area присваиваем имена элементам,
            в первом ряду header занимает две колонки,
            второй ряд содержит колонки side и content,
            высота рядов 1fr,
            ширина колонок 150px 1fr.</span>
<b>grid-auto-rows</b>: ; - <span class="menu__komment">управляет рядом неявной сетки, т.е. ряд, который не обозначен в grid-template-rows</span>
<b>grid-auto-columns</b>: ; - <span class="menu__komment">если не задан grid-template-columns</span>
<b>grid-auto-flow</b>: row; - <span class="menu__komment">выстраивает грид-элементы поочередно в ряд</span>
<b>grid-auto-flow</b>: column; - <span class="menu__komment">выстраивает грид-элементы поочередно в колонку</span>
<b>grid-auto-flow</b>: dense; - <span class="menu__komment">выстраивает грид-элементы в произвольном порядке</span>

<em>Размещение элементов с помощью линий сетки</em>:    
<b>grid-row-start</b>: auto;
<b>grid-row-end</b>: auto;
<b>grid-column-start</b>: auto;
<b>grid-column-end</b>: auto;
<b>grid-row-start</b>: span 2; <span class="menu__komment">объект занимает 2 строчки</span>
<b>grid-template-rows</b>: [start] 1fr [row2] 1fr [row-end]; - <span class="menu__komment">две строки одинаковой высоты 
        и [имена линий] между строк сверху вниз</span>
<b>grid-template-columns</b>: [start] 1fr [col2] 1fr [col3] 1fr [col-end]; - <span class="menu__komment">три столбца одинаковой ширины
        и [имена линий] меду столбцами слева направо</span>
<b>grid-row</b>: 1 / 2; - <span class="menu__komment">применяется к элементу, указывает начало и конец элемента по линиям рядов</span>
<b>grid-column</b>: 1 / 2; - <span class="menu__komment">применяется к элементу, указывает начало и конец элемента по линиям столбцов</span>
или
<b>grid-row</b>: start / row2; - <span class="menu__komment">применяется к элементу, указывает начало и конец элемента по линиям рядов</span>
<b>grid-column</b>: start / col2; - <span class="menu__komment">применяется к элементу, указывает начало и конец элемента по линиям столбцов</span>
<b>order</b>: 1; - <span class="menu__komment">задается каждому елементу сетки и определяет порядок вывода елемента</span>
<b>justify-items</b>: stretch; - <span class="menu__komment">растягивает/прижимает елементы в ячейках вправо/влево</span>
<b>align-items</b>: stretch; - <span class="menu__komment">растягивает/прижимает елементы в ячейках вверх/вниз</span>
<b>row-gap</b>: 20px; - <span class="menu__komment">расстояние между строками</span>
<b>column-gap</b>: 20px; - <span class="menu__komment">расстояние между колонками</span>
или
<b>gap</b>: 20px; - <span class="menu__komment">и для строк и для колонок одновременно</span>
</small>
</details>
<details><!--Адаптивная верстка-->
  <summary>Адаптивная верстка</summary><small>
  <em>отзывчивая</em> - <span class="menu__komment">всё в %, указываем только максимальную ширину для body, 
  весь контент на своём месте, отзывается на изменение ширины экрана.</span>
  <em>адаптивная</em> -<span class="menu__komment"> брейкпоинты, медиа-запросы, контент перестраивается на брейкпоинтах 
  при изменении ширины экрана.</span>
  <em>отзывчиво-адаптивная</em> - <span class="menu__komment">делаем отзывчиую пока читается контент при уменьшении ширины экрана.
  При ширине плохо читабельного контента далем брейкпоинт - адаптив.</span>
  < <b>meta</b> name="viewport" content="width=device-width">
  <em>Брейкпоинт</em>:
  @media (max-width:1200px){
    .container{
      max-width: 970px;
    }
  }

  @media (max-width:992px){
    .container{
      max-width: 750px;
    }
  }

  @media (max-width:767px){
    .container{
      max-width: none;
    }
  }
  < <b>div</b> class="<em>container</em>">< /div> - <span class="menu__komment">обворачиваем весь контент</span>
  <b>@import</b> url(color.css) screen and (color); - <span class="menu__komment">медиа-запрос в css,</span>
  < <b>link</b> rel="stylesheet" media="screen and (color)" href="example.css"> - <span class="menu__komment">медиа-запрос в html:
  файл стилей подключится в только при выполнении условия медиа-запроса</span>
</small>
</details>
<details><!--Animation-->
<summary>Animation</summary><small>
  <b>@keyframes</b> <i>grow</i> {
    <b>from</b> {
      font-size: 20px;
    }
    <b>to</b> {
      font-size: 100px;
    }
  }

  <b>h1</b> {
    <b>animation-name</b>: <i>grow</i>;
    <b>animation-direction</b>: 2s;
    <b>animation-fill-mode</b>: forwards;
  }
  
  или

  <b>@keyframes</b> <i>grow</i> {
    <b>from</b> {
      left: 0%;
    }
    <b>to</b> {
      left: 50%;
    }
  }

  <b>h1</b> {
    <b>position: relative</b>
    <b>animation-name</b>: <i>grow</i>;
    <b>animation-direction</b>: 2s;
    <b>animation-fill-mode</b>: forwards;
  }

  <b>animation-name</b>: <span class="menu__komment">имя ключевых кадров, имя ключевых кадров № 2; 
  - список применяемых к элементу анимаций (кадров)</span>
  <b>animation-duration</b> - <span class="menu__komment">продолжительность анимации</span>
  <b>animation-timing-function</b> - <span class="menu__komment">сценарий анимации</span>
  <b>animation-iteration-count</b> - <span class="menu__komment">количество повторов ключевых кадров</span>
  <b>animation-direction</b> - <span class="menu__komment">тип и направление проигрования ключевых кадров</span>
  <b>animation-play-state</b> - <span class="menu__komment">запускает либо приостанавливает анимацию по событию</span>
  <b>animation-name</b>: none; - <span class="menu__komment">возвращает анимацию на исходную</span>
  <b>animation-delay</b> - <span class="menu__komment">задержка перед началом анимации</span>
  <b>animation-fill-mode</b> - <span class="menu__komment">определяет какие свойства применятся после завершения анимации</span>
  <b>animation</b>: name duration function count direction delay mode;
  <b>animation</b>: firstname 2s linear infinite alternate 0s forwards, secondname 5s ease infinite alternate 0s forwards;

  Сколько свойств - <span class="menu__komment">столько и значений transition-duration через запятую</span>
  <b>transition-duration</b> - <span class="menu__komment">время перехода</span>
  <b>transition-property</b> - <span class="menu__komment">содержит css свойства к которым будет применен переход</span>
  <b>transition-delay</b> - <span class="menu__komment">время задержки перехода</span>
  <b>transition-timing-function</b> - <span class="menu__komment">сценарий анимации</span>
  <b>общая запись</b>: transition: all 1s ease 0s; - transition: property duration function delay;
  <b>transition</b>: padding 1s ease 0s, color 2s ease-in 0.5s;
</small>

</details>
<details><!--Графика-->
<summary>Графика</summary><small>
  <b>JPEG/JPG</b> - <span class="menu__komment">растровый, оптимизируется хорошо, лучше для контента</span>
  <b>PNG</b> - <span class="menu__komment">растровый, оптимизируется плохо, может быть прозрачным, лучше для фона и элементов дизайна</span>
  <b>GIF</b> - <span class="menu__komment">растровый, до 256 цветов, видеоролик в формате изображения, оптимизируется хорошо</span>
  <b>SVG</b> - <span class="menu__komment">векторный, хорошо подходит для иконок и при масштабировании изображения</span>
  <b>WebP</b> - <span class="menu__komment">замена всех растровых форматов (прозрачность, анимация, хорошо оптимизируется)</span>
  <b>ico</b> - <span class="menu__komment">растровый, оптимизируется хорошо, может быть прозрачным, 16х16рх, для иконок</span>
  < <b>link</b> rel="shortcut icon" href="favicon.ico">
  <b>object</b> - <span class="menu__komment">работа с изображениями в контейнере как background в фоне</span>
  <b>object-fit</b>: fill; - <span class="menu__komment">управляет изображением внутри контейнера</span>
  <b>object-position</b>: center; - <span class="menu__komment">позиционирование изображения относительно родителя</span>
</small>
</details>
<a href="https://www.youtube.com/@OnlineTutorialsYT">OnlineTutorialsYT</a>
<a href="https://www.youtube.com/@codeonly">Code Only</a>
<a href="https://www.youtube.com/playlist?list=PLM6XATa8CAG6IJvQBkrTTNZmpIcyS2Avk">Как сделать</a>
<a href="https://www.youtube.com/watch?v=kfOe-F64C_A&list=PLM6XATa8CAG4F9nAIYNS5oAiPotxwLFIr&index=9">Уроки HTML CSS JS</a>
<a href="https://www.youtube.com/playlist?list=PLN2KCaMlZNdCBrVcXJXEO1iaTkZIMEA7R">Верстка сайта от 0 до 1</a>
<a href="https://www.w3.org/TR/cssom-1/">CSSOM</a>
</pre>
            </div>
          </details>
          <details class="menu__item"><!--JS-->
            <summary>JS</summary>
            <div class="menu__inner">
            <p><em>JavaScript</em> — мультипарадигменный язык программирования. <br>
                Поддерживает объектно-ориентированный, императивный и функциональный стили. <br>
                Является реализацией спецификации ECMAScript. <br>
                JavaScript обычно используется как встраиваемый язык для программного доступа к объектам приложений. <br>
                Позволяет взаимодействовать с элементами на странице, изменять их содержание и стиль, реагировать на события, 
                такие как клики и наведение курсора, а также создавать сложные анимации и эффекты.
            </p>
            <a href="https://jsfiddle.net/">Онлайн редактор</a> <br>
            <br>
<pre>
<details><!--Синтаксис-->
  <summary>Синтаксис</summary><small>
  < <b>script</b>>alert('Привет мир!') < /<b>script</b>> - <span class="menu__komment">вставить скрипт в html, либо</span>
  < <b>script</b> src="/path/to/script.js"> < /<b>script</b>> - <span class="menu__komment">подключить в html файл со скриптом.</span>
  <b>"use strict"</b> или <b>'use strict'</b> - <span class="menu__komment">строгий режим. Отключить невозможно.
  Классы и модули строгий режим включают автоматически.</span>

  <span class="menu__komment">Имена должны быть легко читаемые, camelCase, описательные и лаконичные.</span>
  <b>" "</b> или <b>' '</b> - <span class="menu__komment">это строка</span>
  <b>`${...} `</b> - <span class="menu__komment">вставить выражение в строку</span>
  <b>//</b> - <span class="menu__komment">однострочный комментарий</span>
  <b>/*...*/</b> - <span class="menu__komment">многострочный комментарий</span>

  <em>Блок инструкций</em>:
  {
    console.log('<i>Учим</i>');
    console.log('<i>JS</i>');
  }

  <em>Область видимости {}</em>
  const KNOW_VAL = I know the value; - <span class="menu__komment">константа с известным заранее значением пишем в верхнем регистре</span>
  const donotKnow = I don't know the value; - <span class="menu__komment">константа с неизвестным заранее значением</span>
  var - <span class="menu__komment">ключевое слово переменной, можно использовать до объявления.
  область видимости в пределах модуля, 
  исключение: если объявлена в теле функции, то видна только в теле функции.</span>

  <em>Комментируй</em>:<span class="menu__komment">
    - общую архитектуру
    - использование функций
    - неочевидные решения
    - важные детали</span>
  <em>Не комментируй что делает код.</em>

  <em>Значения</em>:<span class="menu__komment">
    - фиксированные значения - литералы
    - литерал целого числа:          25
    - литерал дробного числа:        23.8
    - литерал строки:                'Javascript', "Javascript"
    - литерал массива:               [], [15,7,89]
    - литерал объекта:               {}, {name: 'Javascript', surname: 'Javascript'}
    - литерал регулярного выражения: (ab|bc)
    - значения констант: const MAX_VALUE = 17;
    - значения переменных: var section = 'JS';</span>

  let arr = ['HTML','CSS','JS'];

  <em>Выражения</em> - <span class="menu__komment">комбинация значений переменных и операторов</span>
  <em>Ключевые слова</em> - <span class="menu__komment">определяет какое действие нужно выполнить</span>

  <em>Автоматическое тестирование</em> - <span class="menu__komment">тесты пишуться отдельно:
  по-разному запускают функции и сравнивают результат с ожидаемым.</span>

  <em>спецификация состоит из</em>:
  describe ("<i>pow</i>", function(){                // <span class="menu__komment">описываем функцию pow</span>
    it ("<i>возводит в степень n</i>", function() {  // <span class="menu__komment">рабочий блок - описывает что делает</span>
      assert.equal(pow(2, 3), 8);             // <span class="menu__komment">функция assert проверяет работу функции pow</span>
    });
  });

  <em>Опциональная цепочка</em>:
  <span class="menu__komment">Если перед ?. undefined или null, то останавливает вычисление и возвращает undefined (без ошибки).</span>
  ?. работает:<span class="menu__komment">
    - с существующими переменными
    - с функциями user1.admin?.(...)
    - с квадратными скобками ?.[...]</span>
  let user = {}; - <span class="menu__komment">пользователь без адреса</span>
  alert(user?.adress?.street); - <span class="menu__komment">undefined (без ошибки)</span>
  delete user?.name - <span class="menu__komment">удалит user.name если user существует</span>
  obj?.prop - <span class="menu__komment">вернёт obj.prop если obj есть, иначе undefined</span>
  obj?.[prop] - <span class="menu__komment">вернёт obj[prop] если obj есть, иначе undefined</span>
  obj.method?.() - <span class="menu__komment">вызовет obj.method если он есть, иначе undefined</span>
  </small>         
</details>
<details><!--Types-->
  <summary>Types</summary><small>
    <em>Тип</em>:<span class="menu__komment">
      - набор характеристик значения,
      - не у переменной, а у значения,
      - присваиваится переменной вместе со значением.
    </span> 
  </small>
  <details><!--Object-->
    <summary>Object</summary><small>
    Object {property1: value1, property2: value2}

    let someObj = new Object();
    let someObj = {
      key1: value1,
    };
    console.log(someObj.key); <i>либо</i> console.log(someObj['key']);

    someObj.key2 = value2; - <span class="menu__komment">добавил в объект свойство (ключ: значение)</span>
    delete someObj.key2; - <span class="menu__komment">удалил из объекта свойство (ключ: значение)</span>
    let obj = someObj; - <span class="menu__komment">скопировал ссылку на объект в другую переменную</span>
    let obj = Object.assign({}, someObj); - <span class="menu__komment">сделал дубликат объекта</span>

    if ("key1" in someObj) {} - <span class="menu__komment">проверка на наличие свойства</span>
    for (let key in object) {} - <span class="menu__komment">перебирает все свойства объекта</span>
    let someObj = {
      key1: value1,
      someFunc: function () {}, - <span class="menu__komment">метод объекта</span>
      <i>либо</i>
      someFunc() {},
    };

    <em>Function</em> - <span class="menu__komment">это Object, но выведен отдельно для простоты определения функций</span>

    Object.getOwnPropertySymbols(obj) - <span class="menu__komment">получить все свойства объекта с ключами-символами</span>

    Reflect.ownKeys(obj) - <span class="menu__komment">возвращает все ключи объекта включая символьные</span>
  </small>
  </details>
  <details><!--Примитивы-->
  <summary>Примитивы</summary><small>
    <em>Примитивы</em> - <span class="menu__komment">это конкретные значения.
    С помощью объектов-оберток (Number, String, ...) все примитивы кроме null и undefined
    имеют методы работы с ними.</span>
    <em>undefined</em> - <span class="menu__komment">неопределен, нет значения</span>
    <em>null</em> - <span class="menu__komment">переменная определена, значение - ничего</span>
    <em>boolean</em> - <span class="menu__komment">true/false</span>
    <em>number</em> - <span class="menu__komment">числа целые и с точкой
      - infinity (безконечность)
      - NaN (Not a Number)</span>

    <em>Обычные числа в JS</em> - <span class="menu__komment">это числа с плавающей точкой двойной точности 
    (double precision floating point numbers), 64-битный формат IEEE-754.</span>

    <em>BigInt</em> - <span class="menu__komment">числа позволяют работать с числами произвольной длины.</span>
    123e6 = 123 000 000 (<i>e6 - это 6 нулей</i>) 123e-6 = 0,000123
    let someNum = 1000000; <i>лучше так</i>: let someNum = 1e6;
    let num = 0.000001;                 let num = 1e-6;

    0b11111111 - <span class="menu__komment">бинарная (двоичная) форма записи числа 255</span>
    0о377 - <span class="menu__komment">восьмиричная форма записи числа 255</span>
    0xff - <span class="menu__komment">шестнадцатиричная форма записи числа 255</span>

    <em>string</em> - <i>строка</i> ' ', " ", `${}`
    "<i>Какое-то</i> \n <i>предложение</i> \n\t <i>тут</i>": <span class="menu__komment">\n - перевод строки, \t - табуляция (отступ), \ - экранирование</span>
    let someText = "text";
    console.log(someText.length); - <span class="menu__komment">длина строки</span>
    let firstSymbol = someText[0]; - <span class="menu__komment">получаем символ строки</span>
    let lastSymbol = someText[someText.length-1]; - <span class="menu__komment">последний символ строки</span>

    for (const char of someText) {    - <span class="menu__komment">перебирает символы строки</span>
      console.log(char);
    }

    someText.toUpperCase() - <span class="menu__komment">все буквы большие</span>
    someText.toLowerCase() - <span class="menu__komment">все буквы маленькие</span>

    someText.indexOf(substr, pos) - <span class="menu__komment">ищет подстроку substr в строке someText,</span>
    pos - <span class="menu__komment">необязательный, символ с которого искать</span>
    includes(substr, pos), startsWith(substr), endsWith(substr) - <span class="menu__komment">проверяет на наличие, возвращает true или false</span>
    slice(start, end) - <span class="menu__komment">возвращает часть строки без end</span>

    <em>Symbol</em> - <i>идентификатор объекта</i>
    Два <b>Symbol("id")</b> с одинаковым "<b>id</b>" - <span class="menu__komment">это разные символы.</span>
    let id = Symbol.for("id") -<span class="menu__komment"> читает символ "id" из глобального реестра,
    если символа нет, то создаст новый глобальный символ.</span>
    <span class="menu__komment">В глобальном реестре под одним именем один символ.</span>
    <span class="menu__komment">Используется как "скрытые" свойства объектов, т.к. символьное свойство не появится в for..in,
    например:</span>
    - Symbol.iterator - <span class="menu__komment">для итераторов,</span>
    - Symbol.toPrimitive - <span class="menu__komment">для преобразования объектов в примитивы</span>
        
    let id = Symbol("id");  // <span class="menu__komment">создание символа</span>
    let user = {
      name: "Вася",         // <span class="menu__komment">не преобразуются в строку автоматически</span>
      [id]: 123             // <span class="menu__komment">просто id:123 не работает, т.к. нужно значение переменной id, а не срока id.</span>
    };
    </small>
  </details>
  <details><!--typeof-->
  <summary>typeof - возвращает тип аргумента</summary><small>
    typeof 0 - <span class="menu__komment">number</span>
    typeof true - <span class="menu__komment">boolean</span>
    typeof 'JS' - <span class="menu__komment">string</span>
    typeof undefined - <span class="menu__komment">undefined</span>
    typeof Math - <span class="menu__komment">object</span>
    typeof Symbol ('JS') - <span class="menu__komment">symbol</span>
    typeof null - object - <span class="menu__komment">баг, это null</span>
    typeof function() {} - <span class="menu__komment">function - баг, это object</span>
    typeof NaN - <span class="menu__komment">number - Not a Number возвращает number</span>
  </small>
  </details>
  <details><!--Приведение типов-->
  <summary>Приведение типов</summary><small>
    <em>Основные приведения: строковое, численное и логическое.</em>
    '', 0, null, undefined, Nan, false - <span class="menu__komment">приводятся Boolean() к false ("false" - значения).</span>
    Boolean('Hello') - <span class="menu__komment">true</span>
    Boolean(' ') - <span class="menu__komment">true, пробел - это символ</span>
    Boolean('0') - <span class="menu__komment">true, '0' приводится к строке</span>
    Boolean(0) - <span class="menu__komment">false</span>
    Boolean([]) - <span class="menu__komment">true</span>
    Boolean({}) - <span class="menu__komment">true</span>

    <span class="menu__komment">Операторы приводят значения null к 0, а undefined к NaN:</span>
    null > 0 - false            undefined > 0 - false
    null >= 0 - true            undefined < 0 - false
    null == 0 - false           undefined == 0 - false
    <span class="menu__komment"><b>NaN</b> возвращает <b>false</b> при любых сравнениях.</span>
    <span class="menu__komment">При нестрогом равенстве null/undefined ни к чему не приводятся и равны только друг другу.</span>

    <em>Строки и числа</em>:
    String(value); - <span class="menu__komment">приведение к строке</span>
    Number(value); - <span class="menu__komment">приведение к числу</span>
    Number("123"); - <span class="menu__komment">123</span>
    Number("123z"); - <span class="menu__komment">NaN</span>
    Number(true); - <span class="menu__komment">1</span>
    Number(false); - <span class="menu__komment">0</span>
    +true - <span class="menu__komment">1</span>
    +'' - <span class="menu__komment">0</span>
    null + 2 - <span class="menu__komment">number 2, null приводится к 0</span>
    1 + '2' - <span class="menu__komment">string 12</span>
    '' + 1 + 0 - <span class="menu__komment">string 10</span>
    '' - 1 + 0 - <span class="menu__komment">number -1, у строки есть только оператор сложения (конкатенация), поэтому -1 это число + 0</span>
    '3' + '8' - <span class="menu__komment">number 24</span>
    4 + 10 + 'px' - <span class="menu__komment">string 14px</span>
    'px' + 4 + 10 - <span class="menu__komment">string px410</span>
    '42' - 40 - <span class="menu__komment">number 2</span>
    '42px' - 40 - <span class="menu__komment">NaN, px к числу не приводится</span>
    undefined + 2 - <span class="menu__komment">NaN, undefined приводится к NaN</span>

    parseInt() - <span class="menu__komment">возвращает целое число, которое смогло получить из параметра</span>
    parseFloat()- <span class="menu__komment">возвращает число с точкой, которое смогло получить из параметра</span>
    parseInt(str, base) - <span class="menu__komment">преобразует строку в число, base - система исчисления 2 =< base =< 36, по умолчанию 10</span>
    parseInt('0xff', 16) - <span class="menu__komment">255, дополнительное свойство - читает кодировки чисел</span>
    parseInt('100px') - <span class="menu__komment">100</span>
    parseFloat('12.5em') - <span class="menu__komment">12.5</span>
    parseInt('a123') - <span class="menu__komment">NaN, не смог прочитать ни одной цифры</span>
    num.toString(base) - <span class="menu__komment">преобразует число num в строку в виде системы исчисления base (от 2 до 32, по умолчанию 10)
    Если вызывать метод на числе, то 123..toString(36) или (123).toString(36)</span>
    num.toFixed(n) - <span class="menu__komment">округляет до n знаков после запятой и возвращает результат в виде строки</span>
    isNaN(value) - <span class="menu__komment">преобразует в число и проверяет является ли оно NaN. NaN никогда не будет равно NaN.</span>
    NaN === NaN - <span class="menu__komment">false</span>
    isFinite(value) - <span class="menu__komment">преобразует в число и возвращает true если обычное число</span>
    Object.is(a, b) - <span class="menu__komment">идентично a === b</span>
    Object.is(NaN, NaN) === <span class="menu__komment">true</span>
    Object.is(0, -0) === <span class="menu__komment">false, технически 0 и -0 это разные значения</span>
    встроенный объект Math - <span class="menu__komment">математические операции над числами</span>

    <em>Преобразование объектов в примитивы:</em>
    obj[Symbol.toPrimitive](hint) - <span class="menu__komment">вызывается метод объекта если он существует
    Если hint = string, то вызывается obj.toString(), если такого нет, то obj.valueOf()
    Если hint = number или default, то вызывается obj.valueOf(), если такого нет, то obj.toString().</span>
  </small>
  </details>
  <img src="../img/js/Прототип.png" alt="">
</details>
<details><!--Регулярные выражения-->
    <summary>Регулярные выражения</summary><small>
      Пока ничего нет
    </small>
</details>
<details><!--Операторы-->
  <summary>Операторы</summary><small>
операнд - <span class="menu__komment">это то, к чему применяется оператор</span>
-х; - <span class="menu__komment">унарный оператор - применяется к одному операнду</span>
у - х; - <span class="menu__komment">бинарный оператор - применяется к двум операндам</span>
+операнд - <span class="menu__komment">приведение к числу</span>
= <span class="menu__komment">оператор присваивания</span>

<em>все операторы возвращают значение</em>
+ <span class="menu__komment">сложения, если одно из слагаемых строка, то сумма - строка. Остальные операторы дают число.</span>
- <span class="menu__komment">вычитания</span>
* <span class="menu__komment">умножения</span>
/ <span class="menu__komment">деления</span>
% <span class="menu__komment">взятие остатка от деления (5%2 = 1)</span>
** <span class="menu__komment">возведения в степень</span>

<em>Инкремент/декремент можно применять только к переменной.</em>
++ <span class="menu__komment">инкремент увеличивает на 1</span>
-- <span class="menu__komment">декремент уменьшает на 1</span>
counter++ <span class="menu__komment">постфиксная форма возвращает старое значение (до увеличения/уменьшения числа)</span>
++counter <span class="menu__komment">префиксная форма возвращает новое значение</span>

<em>операторы == vs === (нестрогое vs строгое)</em>
== <span class="menu__komment">сравнивает с приведением типов</span>
=== <span class="menu__komment">сравнивает без приведения типов</span>
2 == '2' <span class="menu__komment">true</span>
2 === '2' <span class="menu__komment">false</span>
undefined == null <span class="menu__komment">true</span>
undefined === null <span class="menu__komment">false</span>
'0' == false    <span class="menu__komment">true</span>
'0' == 0        <span class="menu__komment">true</span>
0 == 0          <span class="menu__komment">true</span>
false == ''     <span class="menu__komment">true</span>
false == []     <span class="menu__komment">true</span>
false == {}     <span class="menu__komment">false</span>
'' == 0         <span class="menu__komment">true</span>
'' == []        <span class="menu__komment">true</span>
'' == {}        <span class="menu__komment">false</span>
'' == null      <span class="menu__komment">false</span>
{} == {}        <span class="menu__komment">false</span>
{} === {}       <span class="menu__komment">false</span>
== и === <span class="menu__komment">для объектов работают одинаково.</span>
<span class="menu__komment">Два объекта равны если это один и тот же объект.</span>

2**2 = 4
4**(1/2) = 2 <span class="menu__komment">квадратный корень</span>
8**(1/3) = 2 <span class="menu__komment">кубический корень</span>

<em>Приоритет</em>:
+ <span class="menu__komment">унарный плюс</span>
- <span class="menu__komment">унарный минус</span>
** <span class="menu__komment">возведение в степень</span>
* <span class="menu__komment">умножение</span>
/ <span class="menu__komment">деление</span>
+ <span class="menu__komment">сложение</span>
- <span class="menu__komment">вычитание</span>
= <span class="menu__komment">присваивание</span>

<em>Операторы сравнения</em>:
a > b, a < b    <span class="menu__komment">больше/меньше</span>
a >= b, a <= b  <span class="menu__komment">больше/меньше или равно</span>
a == b          <span class="menu__komment">равно</span>
a === b         <span class="menu__komment">строгое равно</span>
a != b          <span class="menu__komment">не равно</span>
a !== b         <span class="menu__komment">строгое не равно</span>
<span class="menu__komment">Все операторы возвращают true или false.
Строки сравниваются посимвольно.
При сравнении разных типов - приведение к числу.</span>

<em>Оператор запятая</em> (,):<span class="menu__komment">
- позволяет вычислять несколько выражений, разделяя их запятой.
- каждое выражение выполняется, но возвращается результат только последнего.</span>
let a = (1+2, 3+4);   <span class="menu__komment">скобки важны, т.к. приоритет ниже чем =</span>
alert(a);   <span class="menu__komment">7-результат 3+4.</span>

<em>Побитовые операторы</em>:
&   AND                     <span class="menu__komment">и</span>
|   OR                      <span class="menu__komment">или</span>
^   XOR                     <span class="menu__komment">побитовое исключающие или</span>
~   NOT                     <span class="menu__komment">не</span>
<<  LEFT SHIFT              <span class="menu__komment">левый сдвиг</span>
>>  RIGHT SHIFT             <span class="menu__komment">правый сдвиг</span>
>>> ZERO-FILL RIGHT SHIFT   <span class="menu__komment">правый сдвиг с заполнением нулями</span>
<span class="menu__komment">Побитовые операторы работают с 32-разрядными целыми числами (приводят к ним), 
на уровне их внутреннего двоичного представления.</span>

<em>Логические операторы</em>:
||  <span class="menu__komment"></span>или - если любой из аргументов true, то вернет true, иначе false</span>
true || true   <span class="menu__komment">true</span>
false || true   <span class="menu__komment">true</span>
true  || false  <span class="menu__komment">true</span>
false || false  <span class="menu__komment">false</span>
<span class="menu__komment">- цепочка или || возвращает первое истиное значение или последнее, если такое значение не найдено.
- цепочка вычисляется слева направо.</span>
undefined || null || 0  <span class="menu__komment">результат 0.</span>

&&  <span class="menu__komment">и - если оба аргумента true, то вернет true, иначе false</span>
true && true   <span class="menu__komment">true</span>
false && true   <span class="menu__komment">false</span>
true  && false  <span class="menu__komment">false</span>
false && false  <span class="menu__komment">false</span>
<span class="menu__komment">- цепочка или && возвращает первое ложное значение или или последнее, если такое значение не найдено.</span>
<span class="menu__komment">- приоритет и && больше чем или ||.</span>
<span class="menu__komment">Или || спотыкается на правде, и && спотыкается на лжи.</span>

! <span class="menu__komment">не  - принимает один аргумент, приводит к логическому типу и возвращает к противоположное значение.</span>
!true <span class="menu__komment">-> false</span>
!0    <span class="menu__komment">-> true</span>
!! "non-empty string"   <span class="menu__komment">true</span>
!! null                 <span class="menu__komment">false</span>
!!операнд - <span class="menu__komment">приведение к boolean</span>
<span class="menu__komment">Приоритет ! наивысший из всех логических операторов.</span>

?? - <span class="menu__komment">оператор объединения с null, возвращает первое определённое значение, если оно отличается от null или undefined.</span>
операнд ?? операнд - <span class="menu__komment">вернет операнд не равный null или undefined</span>
|| <span class="menu__komment">возвращает первое истинное значение,</span>
?? <span class="menu__komment">возвращает первое определённое значение.</span>
let height = 0;
height || 100 <span class="menu__komment">вернет 100 </span>
height ?? 100 <span class="menu__komment">вернет 0</span>
a ?? b <span class="menu__komment"></span>результат a, если а определено, иначе b</span>
let user;
alert(user??"Аноним");  <span class="menu__komment">Аноним
Запрещено использовать оператор ?? вместе с && и || без явного указания приоритета скобками.</span>

... - <span class="menu__komment">троеточие, обозначает оператор "остаточные параметры" если нахидотся в конце списка аргументов функции либо оператор "расширения".
- оператор "остаточные параметры" используется, чтобы создавать функции с неопределённым числом аргументов, собирает оставшиеся параметры в массив:</span>
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Repablic"];
- <span class="menu__komment">оператор "расширения" позволяет вставить массив в функцию, расширяя перебираемый объект arr в список аргументов (f...arr);
оператор "расширения" работает только с итерируемыми объектами.</span>
</small>
</details>
<details><!--Инструкции-->
  <summary>Инструкции</summary><small>
  <em>Условное ветвление</em>:
  if (...) {          
    ...             
  } else if (...) {    
    ...
  }<span class="menu__komment">
  - вычисляет условие в скобках
  - приводит к логическому типу
  - если условие true, то выполняет блок кода
  Блоков else и else if может быть сколько угодно, а может и не быть.</span>
  if () {}
  if () {} else {}
  if () {} else if () {} else {}
  () <b>?</b> valueIfTrue <b>:</b> valueIfFalse; <i>тоже самое</i> if () {} else {}

  switch(x) {
    case 'value1':
      ...
      break
    case 'value2':
      ...
      break
    default:
      ...
    break
  }<span class="menu__komment">
  - switch заменяет несколько if.
  - switch имеет один или несколько блоков case.
  - проверка равенства всегда строгая.
  - если нет dreak, то выполнение пойдет по следующим case без проверки.</span>

  ? - <span class="menu__komment">тернарный оператор (три аргумента)</span>
  let <b>result</b> = условие <b>?</b> значение1 <b>:</b> значение2;
  <span class="menu__komment">если условие true, то значение1, иначе значение2</span>
  break/continue <span class="menu__komment">использовать нельзя</span>

  <em>Циклы</em>:
  while (...) {
    <i>тело цикла</i> - <span class="menu__komment">выполняется пока условие true</span>
  }
  while () {} - <span class="menu__komment">если процедура не одна, то {}. Если процедура одна: while () procedure;</span>

  do {
    <i>тело цикла</i>
  } while (...);<span class="menu__komment">
  - выполнить и проверить условие
  - если условие true, то выполнить и проверить условие ещё раз</span>

  for (<i>начало</i>; <i>условаие</i>; <i>шаг</i>) {
    <i>тело цикла</i>
  }<span class="menu__komment">
  - выполнить начало
  - посторять пока условие true:
  если условие true, то выполнить тело
  выполнить шаг и проверить условие
  Любая часть может быть пропущена.</span>

  for (;;) {
    <span class="menu__komment">будет выполняться вечно</span>
  }

  for (key in object) {
    <span class="menu__komment">тело цикла выполняется для каждого свойства объекта</span>
  }

  for..in - <span class="menu__komment">для перебора свойств объекта</span>
  for..of - <span class="menu__komment">для перебора значений массива</span>

  let fruits = ["Яблоко", "Апельсин", "Слива"];
  for (let fruit of fruits) {
    alert(fruit);
  }<span class="menu__komment">
  - проходит по значениям каждого элемента массива
  - не предоставляет доступа к номеру элемента, только к его значению</span>

  <em>Метка</em> - <span class="menu__komment">точка местоположения в коде:</span>
  outer: for (...) {
    for (...) {
      if (!input) break outer;
    }
  }
  outer: - <span class="menu__komment">метка-идентификатор с двоеточием</span>
  break/continue <span class="menu__komment">поддерживает метки</span>
</small>
</details>
<details><!--Функция-->
  <summary>Функция</summary><small>
  <img src="../img/js/Синтаксис.png" alt="">
  <br>
  <em>Функция</em> - <span class="menu__komment">это значение, представляющее действие.
  Одна функция - одно действие.</span>

  function sayHi(<i>аргументы, через, запятую</i>) {
    <span class="menu__komment">тело функции, код</span>
  }
  sayHi - <span class="menu__komment">обращение к переменной, содержащей код функции.</span>
  sayHi() - <span class="menu__komment">вызываем код функции на выполнение.</span>

  <span class="menu__komment">Можно передать внутрь функции любую информацию через аргументы функции.
  Переданные через аргументы значения копируются в локальные переменные (<i>параметры</i>) и используются в теле функции.
  Функция всегда получает только копию значения.
  Если аргумент не указан, то его значением становится undefined.</span>

  function showMessage(from, text = "<i>текст не добавлен</i>") {
    alert(from + ": " + text);  <span class="menu__komment">"текст не добавлен" - текст по умолчанию.</span>
  } 

  <em>return</em> - <span class="menu__komment">функция останавливается и возвращает значение.
  Результат функции с пустым retutn или без него - undefined.</span>

  <span class="menu__komment">Функция внутри другой функции называется вложенной.</span>

  <span class="menu__komment">Рекурсия - функция вызывает саму себя. Глубина рекурсии - количество вызовов самой себя.</span>

  <span class="menu__komment">Колбэк функция - функция передаваемая параметром в другую функцию и вызываемая внутри другой функции.</span>
  
  function func1(param1, param2) {}
  function func2(param3) {}
  function func3(param1, param2) {
    func2(func1(param1, param2));
  }
  func3(param1, param2); - <span class="menu__komment">выдаст результат работы func1 и func2</span>
  
  <span class="menu__komment">Функция - это объект, его свойства:
  - <b>name</b> - имя функции
  - <b>length</b> - количество аргументов в объявлении функции, троеточие (остаточные аргументы) не считаються.</span>

  <span class="menu__komment">Функция может содержать другие функции в своих свойствах.</span>

  <span class="menu__komment"><b>Переменные</b> - это не свойства функции и не наоборот - это два параллельных мира.</span>

  <span class="menu__komment">Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.
  Arguments не поддерживает методы массивов и всегда содержит все аргументы функции - мы не можем получить их часть.</span>

  <em>Function Declaration</em> (<i>Объявление функций</i>) <span class="menu__komment">считывается интерпритатором когда создаётся лексическое окуржение,
  в котором объявлена, hosting работает.
  При запуске функций, для неё создаётся лексическое окружение для хранения локальных переменных и параметров вызова.</span>
  
  function sayHi(аргументы, через, запятую) {
    <span class="menu__komment">тело, код функции</span>
  }

  <em>Function Expression</em> (<i>Функциональное выражение</i>) <span class="menu__komment">считывается когда выполнение доходит до него, hosting не работает.</span>
  let sayHi = function() {
    alert("<i>Привет</i>");
  }

  <em>Named Function Expression NFE</em> (<i>именованное функциональное выражение</i>) - <span class="menu__komment">когда у функционального выражения есть имя.
  Имя функционального выражения не доступно за пределами функции и позволяет функции ссылаться на себя (рекурсивные вызовы).</span>
  let sayHi = function func(who) {
    alert(`<i>Hello</i>, ${who}`);
  }

  <em>IIFE</em> - <i>Immediate Invoked Function Expression</i>
  <span class="menu__komment">Функциональное выражение моментального выполнения. 
  Позволяет оборачивать функции для моментального выполнения, передавая необходимые параметры.
  Используются для создания локальной области видимости (scope) с замыканием на внешнюю переменную.
  Пути создания IIFE:</span>
  (function() {
    alert("<i>Скобки вокруг функции</i>");
  })();

  (function() {
    alert("<i>Скобки вокруг всего</i>");
  }());

  !function() {
    alert("<i>Выражение начинается с логического оператора NOT</i>");
  }();

  +function() {
    alert("<i>Выражение начинается с унарного плюса</i>");
  }();

  <em>=> Arrow functions</em> (<i>Стрелочные функции</i>):<span class="menu__komment">
  - не имееют this. При обращении к this, его значение берётся снаружи.
  - не имеют arguments. Arguments внешней функции.
  - не могут быть вызваны с new. Не могут быть конструктором.
  - нет super.
  - предназначены для небольшого кода без контекста, выполняемого в контексте текущего кода.
  - func.bind(this) создаёт связанную версию функции, а => ничего не привязывает, т.к. у неё нет this.</span>
  let sum = (a, b) => a + b;
  <i>или</i>
  let sum = (a, b) => {
    let result = a + b;
    return result;
  };                  <span class="menu__komment">при фигурных скобках для возврата значения нужно явно вызвать return.</span>
  
  <em>new Function</em><span class="menu__komment">
  При создании функции через new Function в её [[Environment]] записывается ссылка не на внешнее лексическое окружение,
  в котором она была создана, а на глобальное.
  Поэтому у неё доступ только к глобальным перменным.
  Используют new Function когда код функции заранее не известен, а будет определен только в процессе выполнения.</span>
  let func = new Function([arg1, arg2, ...argN], functionBody);
  let sum = new Function('a', 'b', return a+b);
  <span class="menu__komment">Можно получить код функции с сервера:</span>
  let str = <span class="menu__komment">...код полученный с сервера динамически...</span>
  let func = new Function(str);
  func();
  
  <span class="menu__komment">Переданные явно глобальные аргументы не вызывают проблем у минификаторов.</span>
  <em>Минификатор</em> - <span class="menu__komment">специальная программа, которая уменьшает размер кода, удаляя комментарии, 
  лишние пробелы, а локальным переменным даются укороченные имена.</span>

  <em>Функции-конструкторы</em> (<i>Конструкторы</i>):<span class="menu__komment">
  - имя с заглавной буквы
  - вызывается при помощи оператора new
  - используется для повторного создания однотипных объектов
  При вызове создаёт пустой this в начале и возвращает заполненный (свойства и их значения) в конце:</span>
  function User(name) {           <span class="menu__komment"> this = {}; явно </span>
    this.name = name;           <span class="menu__komment"> добавляет свойства к this</span>
    this.isAdmin = false;
  }                               <span class="menu__komment"> return this; неявно</span>
  let user = new User("Вася");

  function Cat(color, name) {     <span class="menu__komment"> выполняет роль класса, сама функция ничего не возвращает</span>
    this.color = color;
    this.name = name;
  }
  const cat = new Cat('black', 'Кот');
  console.log(cat);                       <span class="menu__komment"> Cat {color:'black', name: 'Кот'}</span>
  const cat = Cat();                      <span class="menu__komment"> присвоит cat undefined, т.к. Cat() ничего не возвращает</span>
  const cat = new Cat();                  <span class="menu__komment"> присвоит cat - Cat{color: undefined, name: undefined}, т.к. нет входных аргументов</span>

  function myNew(constractor, ...args) {  <span class="menu__komment"> создаём своё ключевое слово new</span>
    const obj = {};                     <span class="menu__komment"> new всегда возвращает новый объект</span>
    Object.setPrototypeOf(obj.constractor.prototype)
    return constractor.apply(obj, args) || obj;
  }<span class="menu__komment">
  - устанавливаем в поле prototype объекта переданную во входных аргументах constructor-ссылку, теперь constructor прототип obj.
  - теперь obj имеет доступ ко всем полям constructor, выполняет функцию-конструктор в контексте obj с входными аргументами args
  или в случае ошибки только сам obj.</span>
  const cat = myNew(Cat, 'black', 'Кот');
  console.log(cat);                       <span class="menu__komment"> Cat {color:'black', name:'Кот'}
  выполняем своё ключевое слово myNew c constructor в контексте Cat и входными аргументами 'black' и 'Кот'.</span>
  
  function SomeFuncCon(name, age) {
    this.name = name;
    this.age = age;
  }
  console.log(new SomeFuncCon('Vasya', 30)); - создаю конструктором новый объект Вася и вывожу в консоль
  
  <span class="menu__komment">Планирование вызова функции:
  <b>setTimeout</b>(<i>функция или код, задержка, параметр, параметр</i>) - вызывает функцию один раз через какое-то время
  <b>setInterval</b>(<i>функция или код, задержка, параметр, параметр</i>) - вызывает функцию много раз через интервал времени</span>

  let timeId = setTimeout(someFunc, param, param);
  setInterval(timeId); - <span class="menu__komment">прерывание setTimeout.
  Если setTimeout вызывать из setTimeout (рекурсия), то получим setInterval
  clearInterval тоже самое что и setInterval</span>

  <em>Контекст</em> - <span class="menu__komment">объект, который передают при вызове и который указывает с каким объектом работает вызываемая функция.
  Ключевое слово function создаёт свой контекст, к которому нужно привязать объект (this), с которым работает функция.
  <b>this</b> - обозначает текущий объект</span>

  <em>Контекст выполнения</em> - <span class="menu__komment">специальная внутренняя структура данных, которая содержит информацию о вызове функции:
  - место в коде, где находится итерпритатор
  - локальные переменные функции
  - значение this
  - прочая служебная информация.</span>

  <em>Привязка контекста: bind</em>
  person.knows.bind(john, 'ничего не', 'Джон');<span class="menu__komment">
  в отличии от call и apply, bind не вызывает метод knows на выполнение, 
  а возвращает новый объект, который нужно вызвать как функцию (),
  чтобы передать вызов в knows и установить this = john.
  Для выполнения пишем так:</span>
  person.knows.bind(john, 'ничего не', 'Джон')();
  <i>либо так</i>
  const bound = person.knows.bind(john, 'ничего не', 'Джон');
  bound();<span class="menu__komment">
  При передаче методов объекта в качестве колбэков,
  например в setTimeout, метод передаётся отдельно от объекта, происходит потеря this.
  Встроенный в функции метод bind позволяет зафиксировать this.
  Частичная или частично применённая функция - это функция с привязанными аргументами.</span>
  let bound = func.bind(context, [arg1], [arg2], ...);

  <em>Явная привязка контекста</em>:
  function logThis() {
    console.log(this)
  }
  const obj = {num: 42};
  logThis.apply(obj); <span class="menu__komment">{num: 42}</span>
  logThis.call(obj); <span class="menu__komment">{num: 42}</span>
  logThis.bind(obj)(); <span class="menu__komment">{num: 42}</span>
  
  <em>Неявная привязка контекста</em>:
  const animal = {
    legs: 4,
      logThis: function() {
        console.log(this);
    }
  }
  animal.logThis();  <span class="menu__komment">{legs: 4, logThis:[Function: logThis]}
  в контекст привязался тот объект, в котором была вызвана функция.</span>

  <em>Методы</em> - <i>это функции как свойства объекта</i>.<span class="menu__komment">
  Методы ссылаются на объект через this для доступа к информации внутри объекта.
  Значение this вычисляется во время выполнения кода (когда функция вызвана) и зависит от контекста.
  Функция может быть скопирована между объектами (из одного объекта в другой).
  Значением this во время вызова синтаксисом "метода" (object.method()) является объект перед точкой.
  У стрелочных функций нет this, его значение берётся из внешей функции.
  Для работы вызовов типа user.hi(), точка возвращает не саму функцию, 
  а специальное значение "ссылочного типа"</span> - <i>Reference Type</i>.

  <em>Значение ссылочного типа</em> - <span class="menu__komment"></span>это "триплет", комбинация из трёх значений:
  <b>base</b> - <span class="menu__komment">объект</span>
  <b>name</b> - <span class="menu__komment">имя свойства объекта</span>
  <b>strict</b> - <span class="menu__komment">режим исполнения (true если 'use strict')
  Когда скобки () применяются к значению ссылочного типа (вызов функции), 
  они получают полную информацию об объекте и его методе, и могут подставить правильный this.
  Ссылочный тип - исключительно внутренний, промежуточный, 
  используется чтобы передать информацию от точки до вызывающих скобок().
  При любой другой операции, например присваении</span>
  hi = user.hi;
  <span class="menu__komment">ссылочный тип заменяется на само значение user.hi (функцию), и дальше работа только с ней - без this.</span>

  <em>Замыкание</em> - <span class="menu__komment">это функция, которая помнит лексическое окружение где она была создана (свои внешние переменные)
  и может получить к нему доступ с помощью скрытого свойства [[Environment]].
  Все функции, кроме newFunction(), изначально являются замыканиями.</span>
  function sayHelloTo(name) {
    const message = 'Helo' + name;
    return function() {            <span class="menu__komment"> анонимная функция</span>
      console.log(message);
    }
  }

  const helloToElena = sayHelloTo('Elena'); <span class="menu__komment"> helloToElena ссылается на анонимную функцию</span>
  const helloToIgor = sayHelloTo('Igor'); <span class="menu__komment"> helloToIgor ссылается на анонимную функцию</span>

  helloToElena();     <span class="menu__komment"> Hello Elena</span>
  helloToIgor();      <span class="menu__komment"> Hello Igor</span>

  const fib = [1, 2, 3, 5, 8, 13];
  for (var i=0; i < fib.length; i++) {
    setTimeout(function() {
      console.log(`fib[${j}] = ${fib[j]}`)
    }, 1500)
  }<span class="menu__komment">
  через 1,5 секунды должен вывести индекс = значение, 
  но не работает т.к. цикл for за 1,5 секунды успевает пробежать по всей длине массива и var i уже имеет значение 6. 
  Только потом срабатывает setTimeout.</span>

  <em>Исправление через область видимости</em>:
  const fib = [1, 2, 3, 5, 8, 13];
  for (let i=0; i < fib.length; i++) {
    setTimeout(function() {
      console.log(`fib[${j}] = ${fib[j]}`)
    }, 1500)
  }<span class="menu__komment">
  поменять var на let, т.к. let действует только в области видимости цикла.</span>

  <em>Исправление через замыкание</em>:
  const fib = [1, 2, 3, 5, 8, 13];
  for (var i=0; i < fib.length; i++) {
  (function(j) {
    setTimeout(function() {
        console.log(`fib[${j}] = ${fib[j]}`)
      }, 1500)
    })(i)
  }<span class="menu__komment">
  обернуть setTimeoutв функцию и через ()()(IIFE) замкнуть функцию на var i.</span>
  
  let someObj = {
    key1: value1,

    someFunc() {
      function anotherFunc() {console.log(`${this.key1}`)}

      anotherFunc();
    }
  };
  <b>someObj.someFunc();</b> - <span class="menu__komment">ошибка, anotherFunc() создает свою область видимости и замыкается (использует)
  область видимости someFunc(), this ищет в области видимости someFunc() свойство key1.</span>

  let someObj = {
    key1: value1,

    someFunc() {
      let someVar = () => console.log(`${this.key1}`)

      someVar();
    }
  };
  <b>someObj.someFunc();</b> - <span class="menu__komment">стрелочная функция не создает свою область видимости и пользуется всем что есть у
  someFunc(), т.е. области видимости someFunc() и someObj.
  <b>this</b> находит свойство key1 в области видимости someObj </span>
  
  <em>Перенапрвление вызова</em> (<i>call forwarding</i>) - <span class="menu__komment">передача всех аргументов вместе с контекстом другой функции:
  <b>call и apply</b> - встроенные методы функции, позволяют вызывать функцию, явно устанавливая this.
  Одна разница:
  - оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.
  - apply принимает только псевдомассив args.</span>
  const person = {
    surname: 'Старк',
    knows: function(what, name) {
      console.log(`Ты ${what} знаешь, ${name} ${this.surname}`)
    }
  }   <span class="menu__komment"> функция работает в контексте (this) объекта person</span>

  const john = {surname: 'Сноу'}
  person.knows('всё', 'Бран')     <span class="menu__komment"> Ты всё знаешь Бран Старк
  
  чтобы перенаправить вызов, функцию knows не вызываем (), а обращаемся к ней как к объекту
  и вызываем её метод call(), в который передаём объект (this), в контексте которого она
  должна отработать и аргументы самой функции knows:</span>
  person.knows.call(john, 'ничего не', 'Джон');   <span class="menu__komment"> Ты ничего не знаешь, Джон Сноу.</span>
  person.knows.apply(john, ['ничего не', 'Джон']);   <span class="menu__komment"> аргументы в виде массива.</span>
  person.knows.call(john, ...['ничего не', 'Джон']);   <span class="menu__komment"> ES-6 синтаксис - оператор спред (...) разворачивает массив.</span>

  <em>Заимствование метода</em>:
  function hash (args) {
    return args[0] + ',' + args[1]; <span class="menu__komment"> функция делает ключ-строку из принимаемых аргументов</span>
  }

  function hash (args) {
    alert([].join.call(args));      <span class="menu__komment"> позаимствовали join у массива</span>
  }
</small>   
</details>
<details><!--Event loop-->
  <summary>Event loop</summary>
  <em>Event loop</em> - <i>событийный цикл (бесконечный цикл)</i>:
<img src="../img/js/EventLoop.png" alt="">
<small><span class="menu__komment">
1. Выполнить старейшую задачу из очереди макрозадач. <b>setTimeout(f)</b> с нулевой задержкой добавляет в очередь новую макрозадачу.
2. Выполнить старейшую задачу из очереди микрозадач. <b>queueMicrotask(f)</b> - добавляет в очередь новую микрозадачу.
Обработчики промисов в микрозадачах.
3. Отрисовать изменения страницы (если есть).
4. Если очередь макрозадач пуста - подождать, когда появится макрозадача.
Сразу после каждой макрозадачи: <i>все микрозадачи -> события -> рендеринг -> макрозадача</i>

<em>Очередь</em> - (<i>queue</i>) <span class="menu__komment">добавляем в конец, извлекаем с начала.</span>
<em>Стек</em> - (<i>stack</i>) <span class="menu__komment">новые элементы всегда добавляются или удаляются с конца.</span>

<em>Web workers</em>:<span class="menu__komment">
- способ исполнить код в параллельном потоке
- обмениваются сообщениями с основным процессом
- имеют свои переменные и свой событийный цикл
- позволяют задействовать несколько ядер процессора сразу
- не имеют доступа к DOM
- используются для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.</span>
</small>
</details>
<details><!--Environment-->
    <summary>Environment</summary><small>
<em>Переменная</em> - <i>это именованное хранилище для данных, которое является свойством Environment Record.</i>
<em>Переменные</em> - <span class="menu__komment">это ссылки на значения, объекты или на другие переменные.
Объекты храняться и копируются по ссылке.
Создание переменной происходит в два этапа:
- <em>declaration</em> (<i>объявление</i>)
- <em>definition</em> (<i>определение</i>), <em>initalization</em> (<i>инициализация</i>)
Имя переменной может содержать буквы, цифры, символы $ и _.
Первый символ в имени не цифра. Регистр имеет значение.
Переменная не объявлена - <i>is not defined</i>.
Переменная не определена - <i>undefined</i>.

<em>hoisting</em> (<i>всплытие, поднятие</i>) - это механизм в JS, в котором объявления переменных и функций, 
передвигаются вверх своей области видимости (локальной или глобальной) перед тем как код будет выполнен и мы
можем обратиться к ним ещё до их определения.
hoisting передвигает только объявления функций и переменных, их определения остаются на своих местах.

<em>LexicalEnvironment</em> - <i>объект лексического окружения </i>состоит из двух частей:
<em>Environment Record</em> - (<i>лексическое окружение</i>) объект, в котором как свойства храняться все локальные переменные, 
значение this и т.д.
Это структура, состоящая из лексических областей видимости, 
которая определяет связи между идентификаторами переменных и функций с их определениями 
на основе вложенности лексических областей видимости.
</span>
function funcA() {
  let a = 1;
  function funcB() {
    let b = 2;
    function funcC() {
      let c = 3;
      console.log(a, b, c);
    }
  }
}
<span class="menu__komment">
Один вызов функции - одно лексическое окружение.
Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.
Для цикла у каждой итерации свой отдельное лексическое окружение.
Из-за того, что у блока есть собственное лексическое окружение, код снаружи не видит переменные этого блока.
При обращении к переменной - сначала ищем во внутреннем лексическом окружении, затем во внешнем, и так до глобального.
Функция получает последнее значение внешних переменных.
Объект лексического окружения существует пока есть хотя бы одна вложенная функция, которая ссылается на него.

<em>Scope</em> - (<i>лексическая область видимости</i>) ссылка на внешнее лексическое окружение, 
т.е. это область видимости, которая указывает на доступность переменных:
- глобальная область видимости - window или document в браузере
- локальная область видимости  - в рамках одной функции или блока кода

Это область видимости, которая определена во время разбора кода на лексемы 
и формируется исходя из того, где переменные, функции и инструкции размещены в коде.
<b>var a = 2;</b>
<i>лексемы:</i>
<b>var</b> - объявление переменной
<b>a</b> - идентификатор (имя) переменной
<b>=</b> - оператор присваивания
<b>2</b> - число
<b>;</b> - конец инструкции
<em>let</em> - изменяемая впеременная, область видимости блок, hoisting не работает.
<em>const</em> - неизеняемая переменная, область видимости блок, hoisting не работает.
Константы с заглавными буквами для заранее известных значений.
Константы маленькими буквами для значений вычисляемых и присваиваемых в процессе выполнения.
<em>var</em> - изменяемая переменная, область видимости функция или скрипт, hoisting работает.</span>
let a = 'variable a'; - <span class="menu__komment">global scope</span>
let b = 'variable b';
{
  a = 'New variable A'; - <span class="menu__komment">a from global scope</span>
  let b = 'Local Variable B'; - <span class="menu__komment">b from local scope</span>
  console.log('A:', a); - <span class="menu__komment">New Variable A</span>
  console.log('B:', b); - <span class="menu__komment">Local Variable B</span>
  console.log('C:', c); - <span class="menu__komment">ReferenceError</span>
  let c = 'Something';
}
console.log('A:', a); - <span class="menu__komment">New Variable A</span>
console.log('B:', b); - <span class="menu__komment">Local Variable B
</span></small>                                  
</details>
<details><!--Коллекции-->
<summary>Коллекции</summary><small><span class="menu__komment">
  <i>Объекты для хранения именованных коллекций.</i>
  <em>Массив</em> - (<i>Array</i>), подвид объектов для хранения упорядоченых коллекций,
  расширяют объекты методами для работы с упорядоченными коллекциями данных и свойством <b>length</b>.
  Получить доступ к элементу <b>arr[0]</b> - это синтаксис доступа по ключу (<b>obj[key]</b>),
  где в роли obj у нас arr, а key - числовой индекс.
  Создание пустого массива: </span>
  let arr = new Array();
  <i>либо</i>
  let arr = [];
  let arr = newArray(2); - <span class="menu__komment">создать пустой массив на 2 пустых элемента.</span>
  
  let fruins = ["Яблоко", "Апельсин", "Слива"];
  fruits[0] - <span class="menu__komment">получить элемент</span>
  fruins[2] = 'Груша'; - <span class="menu__komment">заменить элемент с индеком 2</span>
  fruins[3] = 'Лимон'; - <span class="menu__komment">добывить новый элемент</span>
  fruins.length - <span class="menu__komment">общее число элементов массива</span>
  alert(fruins); - <span class="menu__komment">вывести массив целиком
  В массиве могут храниться элементы любого типа.
  
  <em>Массив</em> - <i>это объект</i>, который намного быстрее объекта если работать с массивом ни как с объектом, 
  а как с упорядоченной коллекцией:
  - свойства именовать цифрами (индексы - числа, а не строки)
  - не создавать дыр, т.е. не оставлять свойства без значений (0: "Вася", 1: , 2: "Петя")
  - не заполнять массив значениями в обратном порядке (сконца)</span>
  let arr = new Array();
  let arr = [];
  let arr = [el1, el2, el3,]; - <span class="menu__komment">элементом массива может быть что угодно.</span>
  arr[1] - <span class="menu__komment">обращение к элементу, индексация с 0</span>
  arr.length - <span class="menu__komment">длина массива</span>
  let arrNew = arr; - <span class="menu__komment">скопировал ссылку на массив
  
  масиивы могут работать и как очередь и как стек:</span>
  push() - <span class="menu__komment">добавляет в конец массива - выполняется быстро</span>
  pop() - <span class="menu__komment">удаляет элемент вконце массива - выполняется быстро</span>
  shift() - <span class="menu__komment">удаляет элемент вначале массива - выполняется медленно</span>
  unshift() - <span class="menu__komment">добавляет элемент вначало массива - выполняется медленно</span>
  delete arr[1]; - <span class="menu__komment">удаление конкретного элемента</span>
  arr.splice(pos, count); - <span class="menu__komment">начиная с позиции pos удалить count элементов
  (pos - считаем сначала, -pos - считаем сконца)</span>
  let rm = arr.splice(pos, count); - <span class="menu__komment">начиная с позиции pos удалить count элементов 
  и вернуть удаленные элементы в переменную</span>
  arr.splice(pos, count, elem); - <span class="menu__komment">начиная с позиции pos заменить count элементов на elem</span>
  arr.splice(pos, 0, elem1, elem2); - <span class="menu__komment">начиная с позиции pos добавить elem1, elem2</span>
  let arrNew = arr.slice(); - <span class="menu__komment">копируем весь массив</span>
  let arrNew = arr.slice(1, 2); - <span class="menu__komment">копируем массив с позиции 1 до позиции 2, не включая позицию 2</span>
  let arrNew = arr.concat(elem); - <span class="menu__komment">копирует весь массив и добавляет в конец нового массива elem</span>
  arr.indexOf(elem, from); - <span class="menu__komment">ищет elem с индекса from, возвращает индекс найденого item или -1</span>
  arr.lastIndexOf(elem); - <span class="menu__komment">возвращает индекс найденого elem или -1, ищет справа налево</span>
  arr.includes(elem, from); - <span class="menu__komment">ищет elem с индекса from, возвращает true  или false
  <img src="../img/js/Methods.jpg" alt="">
  Для массивов, элементы которых объекты:
  <b>find()</b> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,
  если условие совпало, то прерывает поиск и возвращает соответствующее свойство либо undefined</span>
  let res = arr.find(function(elem, index, array) {
    return elem.prop === 18;
  });
  <i>либо</i>
  let res = arr.find(elem => elem.prop === 18);
  <span class="menu__komment">
  <b>findIndex()</b> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,
  если условие совпало, то прерывает поиск и возвращает соответствующей индекс либо undefined</span>
  let res = arr.findIndex(elem => elem.prop === 18);
  <span class="menu__komment">
  <b>filter()</b> - с помощью функции проходит по объекту elem, ищет свойство объекта по заданому условию,
  если условие совпало, то продолжает поиск и возвращает массив совпавших свойств либо undefined</span>
  let res = arr.filter(elem => elem.prop >= 18);
  <span class="menu__komment">
  <b>sort(fn)</b> - сортирует массив, меняя в нем порядок элементов по алгоритму функции fn,
  если fn не указана, то по возрастанию</span>
  function compareNum(a, b) {
    console.log(`Сравниваем ${a} и ${b}`);
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
  }
  console.log(arr.sort(compareNum));
  <i>либо</i>
  function compareNum(a, b) {
    console.log(`Сравниваем ${a} и ${b}`);
    return a - b;
  }
  console.log(arr.sort(compareNum));
  <i>либо</i>
  console.log(arr.sort((a, b) => a - b));
  
  <b>reverse()</b> - <span class="menu__komment">меняет порядок елементов в массиве на обратный</span>
  arr.reverse();
  
  <b>map()</b> - <span class="menu__komment">перебирает элементы массива, применяет функцию к каждому элементу и возвращает 
  на его место в массиве результат работы функции.</span>
  let res = arr.map(function(elem, index, array) {});
  
  <b>split()</b> - <span class="menu__komment">преобразовывает строку в массив по указанному разделителю</span>
  let str = 'elem1,elem2,elem3';
  let arr = str.split(',', limit); - <span class="menu__komment">limit ограничивает количество элементов, которые попадут в массив
  если не указывать, то все</span>
  
  <b>join()</b> - <span class="menu__komment">преобразовывает массив в строку с указанным разделителем</span>
  let arr = ['elem1', 'elem2', 'elem3'];
  let res =  arr.join(',');
  <i>либо</i>
  let arr = ['elem1', 'elem2', 'elem3'];
  let res =  String(arr); - <span class="menu__komment">разделитель всегда запятая</span>
  
  Array.isArray(arr) - <span class="menu__komment">возвращает true если arr это массив, иначе false
  
  Циклы для перебора элементов массива:</span> for (i=0; i < arr.length; i++) и for (let var of arr) {}
  
  <b>forEach()</b> - <span class="menu__komment">метод перебора массива, применяет функцию для каждого элемента массива</span>
  arr.foreach(function(elem, index, array) {
    console.log(`${elem} <i>находится на</i> ${index} <i>позиции в</i> ${array}`);
  });
  <i>либо</i>
  arr.forEach((elem, index, array) => {
    console.log(`${elem} <i>находится на</i> ${index} <i>позиции в</i> ${array}`);
  });
  <i>либо</i>
  let func = function(elem, index, array) {
    console.log(`${elem} <i>находится на</i> ${index} <i>позиции в</i> ${array}`);
  };
  arr.forEach(func);
  
  <b>reduce()</b> - <span class="menu__komment">перебирает элементы массива и вычисляет значение на основе всего массива</span>
  let value = arr.reduce(function(previousValue, elem, index, array) {}, [initial]);
  previousValue - <span class="menu__komment">результат предыдущего вызова этой функции,
  равен initial при первом вызове функции (если initial передан),</span>
  elem - <span class="menu__komment">очередной элемент массива</span>
  index - <span class="menu__komment">его индекс</span>
  array -  class="menu__komment">сам массив</>
  
  reduceRight() - так же как и reduce(), но справа на лево
  
  <em>Псевдомассив</em> - <span class="menu__komment">объекты, у которых есть индексы и свойство length,
  могут иметь другие свойства и методы, но у них нет встроенных методов массива.</span>
  Array.from(obj[,mapFn, thisArg]) - <span class="menu__komment">создаёт Array из итерируемого объекта
  или псевдомассива obj, и затем к нему можно применить методы массивов.
  Необязательные аргументы mapFn и thisArg позволяют применять функцию с 
  задаваемым контекстом к каждому элементу.

  <em>Итерируемые объекты</em> - объекты, которые реализуют метод <b>Symbol.iterator</b>,
  и их можно использовать в цикле for..of.
  Результат вызова <b>obj[Symbol.iterator]</b> называется итератором. Он управляет итерацией.
  Итератор должен иметь метод next(), который возвращает объект</span>
  {done: Boolean, value: any}, где done: true - <span class="menu__komment">окончание итерации,
  иначе value - следующее значение.
  Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его
  и напрямую. Строковый итератор знает про сурогатные пары.

  Свойство <em>length</em> - это наибольший цифровой индекс плюс один.
  Самый простой способ очистить массив - это</span> arr.length = 0;<span class="menu__komment">
  Метод <b>toString</b> возвращает список элементов, разделённых запятыми.
  
  <em>Добавление/удаление элементов</em>:</span>
  push(...items) - <span class="menu__komment">добавляет элементы в конец</span>
  pop() - <span class="menu__komment">извлекает элемент с конца</span>
  shift() - <span class="menu__komment">извлекает элемент с начала</span>
  unshift(...items) - <span class="menu__komment">добавляет элемент в начало</span>
  splice(pos, deleteCount, ...items) - <span class="menu__komment">начиная с индекса pos, удаляет deleteCount элементов и вставляет items.</span>
  slice(start, end) - <span class="menu__komment">создаёт новый массив, копируя в него элементы с позиции start до end, не включая end.</span>
  concat(...items) - <span class="menu__komment">возвращает новый массив: копирует все элементы текущего массива и добавляет к нему items.
  Если какой-то из items является массивом, то беруться его элементы.
  Если объект имеет специальное свойство <b>Symbol.isConcatSpreadable</b>, то он обрабатывается concat как массив,
  т.е. вместо объекта добавляются его числовые свойства.
  Методы push/pop выполняются быстро, а shift/unshift - медлено.</span>

  <em>Поиск среди элементов</em>:
  indexOf/lastIndexOf(item, pos) - <span class="menu__komment">ищет item, начиая с позиции pos, и возвращает его индекс или -1, если ничего не найдено.</span>
  includes(value) - <span class="menu__komment">возвращает true, если в массиве есть элемент value, иначе false.</span>
  find/filter(func) - <span class="menu__komment">фильтрует элементы через функцию и отдаёт первое/все значения, 
  у которых при прохождении через функцию возвращается true.
  findIndex похож на find, но возвращает индекс вместо значения.</span>
  
  <em>Перебор элементов</em>:
  forEach(func) - <span class="menu__komment">вызывает func для каждого элемента. Ничего не возвращает.</span>
  ["Bilbo", "Gandalf", "Nazgul"].forEach(alert); - <span class="menu__komment">вызов alert для каждого элемента.</span>
  
  <em>Преобразование массива</em>:
  map(func) - <span class="menu__komment">создаёт новый массив из результатов вызова func для каждого элемента.</span>
  sort(func) - <span class="menu__komment">сортирует массив "на месте", а потом возвращает его.</span>
  revers(func, initial) - <span class="menu__komment">вычисляет одно значение на основе всего массива,
  вызывая func для каждого элемента и передавая промежуточный результат между вызовами.</span>
  
  Array.isArray(arr) - <span class="menu__komment">проверяет является ли arr массивом.

  <em>Деструктуризация</em> позволяет разбивать объект или массив на переменные при присвоении.
  Для объекта:</span> let {prop: varName = default, ...rest} = object - <span class="menu__komment">неупомянутые свойства копируются в объект rest.
  Для массива:</span> let [item1 = default, item2, ...rest] = array - <span class="menu__komment">первый элемент копируется в item1, второй в item2,
  остальные в массив rest.
  Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и первая.
  
  <em>Map</em> - коллекция пар: ключ-значение.
  Отличия от обычного объекта Object:
  - что угодно может быть ключом, в том числе и объекты.
  - есть дополнительные методы, свойство size.</span>
  
  <em>Методы и свойства</em>:
  newMap([iterable]) - <span class="menu__komment">создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ, значение] для инициализации.</span>
  map.set(key.value) - <span class="menu__komment">записывает по ключу key значение value.</span>
  map.get(key) - <span class="menu__komment">возвращает значение по ключу или undefined, если ключа нет.</span>
  map.has(key) - <span class="menu__komment">возвращает true, если ключ key присутствует в коллекции, иначе false.</span>
  map.delete(key) - <span class="menu__komment">удаляет элемент по ключу key.</span>
  map.clear() - <span class="menu__komment">очищает коллекцию от всех элементов.</span>
  map.size - <span class="menu__komment">возвращает текущее количество элементов.</span>
  map.keys() - <span class="menu__komment">возвращает итерируемый объект по ключам.</span>
  map.values() - <span class="menu__komment">возвращает итерируемый объект по значениям.</span>
  map.entries() - <span class="menu__komment">возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.</span>
  Object.entries(obj) - <span class="menu__komment">создаёт Map из обычного объекта.</span>
  let obj = Object.fromEntries(map); - <span class="menu__komment">создаёт объект из Map.
  
  <em>Set</em> - коллекция значений без ключей, где каждое значение может появляться только один раз.</span>
  
  <em>Методы и свойства</em>:
  newSet([iterable]) - <span class="menu__komment">создаёт Set, можно указать перебираемый объект со значениями без инициализации.</span>
  set.add(value) - <span class="menu__komment">добавляет значение если такого нет, возвращает тот же объект.</span>
  set.delete(value) - <span class="menu__komment">удаляет значение, возвращает true если value было, иначе false.</span>
  set.has(value) - <span class="menu__komment">возвращает true, если значение есть, иначе false.</span>
  set.clear() - <span class="menu__komment">удаляет все значения.</span>
  set.size - <span class="menu__komment">возвращает количество элементов в множестве.</span>
  set.values() - <span class="menu__komment">возвращает перебираемый объект для значений.</span>
  set.keys() - <span class="menu__komment">то же самое, что и <b>set.values()</b>, нужен для обратной совместимости с Map.
  
  Перебор Map и Set всегда осуществляется в порядке добавления элементов,
  поменять порядок элементов или получить элемент напрямую по номеру нельзя.
  
  <em>WeakMap & WeakSet</em>:
  <b>WeakMap</b> - Map-подобная коллекция, где ключи только объекты, автоматически удаляемые вместе со значениями
  как только они становяться недостижимыми.
  <b>WeakSet</b> - Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми.</span>
                                  <em>Mathods</em>:
  weakMap.get(key)                weakSet.get(key)
  weakMap.set(key, value)         weakSet.set(key, value)
  weakMap.delete(key)             weakSet.delete(key)
  weakMap.has(key)                weakSet.has(key)<span class="menu__komment">
  WeakMap и WeakSet поддерживают операции только на отдельном элементе коллекции.
</span></small>
</details>
<details><!--Модуль-->
  <summary>Модуль</summary><small>
  <em>Модуль</em> - <i>это файл.</i><span class="menu__komment">
  Чтобы работал import/export, нужно указать < <b>script type="module"</b>>.
  <b>export</b> отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
  <b>import</b> позволяет импортировать функциональность из других модулей.</span>
  
  < !doctype html>
  <.script type="module">
  import {sayHi} from './say.js';
  document.body.innerHTML = sayHi('John');
  < /script>
  
  <em>У модулей</em>:<span class="menu__komment">
  - Отложенное (deferred) выполнение по умолчанию.
  - Загрузка внешних модулей (<.script type="module" src="...">) не блокирует обработку HTML
  и выполняются только после загрузки HTML документа.
  - Выполняются в порядке расположения в документе.
  - Для загрузки внешнего модуля с другого источника, он должен ставить заголовки CORS.
  - Дублирующиеся внешние скрипты игнорируются.
  - У модулей своя область видимости, обмен через import/export.
  - В модуле всегда включен "use strict".
  - Код в модуле выполняется только один раз.
  - Сборщик Webpack объединяет модули для производительности.</span>

  <em>Синтаксис</em>:
  export default class/function/variable - <span class="menu__komment">перед объявлением</span>
  export {x as y, ...} - <span class="menu__komment">отдельный экспорт</span>
  export {x [as y], ...} from "module" - <span class="menu__komment">реэкспорт</span>
  export * from "module" - <span class="menu__komment">реэкспорт всего кроме export default</span>
  export {default [as y], ...} from "module" - <span class="menu__komment">реэкспорт только export default </span>
  import {x [as y], ...} - <span class="menu__komment">именованный импорт из модуля</span>
  import x from "module" - <span class="menu__komment">импорт по умолчанию</span>
  import {default as x} from "module" - <span class="menu__komment">импорт по умолчанию</span>
  import * as obj from "module" - <span class="menu__komment">импорт всего сразу</span>
  import "module" - <span class="menu__komment">подключить модуль без присваивания переменной
  import/export могут быть вначале или вконце скрипта, но не в {...}.</span>

  <em>Именованный экспорт</em>                    <em>Экпорт по умолчанию</em>
  export class User {...}                 export default class User {...}
  import {User} from ...                  import User from ...<span class="menu__komment">
  Выражение import (module) загружает модуль и возвращает промис,
  результатом которого становится объект модуля, содержащий все его экспорты.</span>
  
  < !doctype html>                                            say.js
  <.script>                                           export function hi() {
  async function load() {                             alert('Привет');
  let say = await import('./say.js');         }
  say.hi();              Привет               export function buy() {
  say.buy();             Пока                     alert('Пока');
  say.default();         Модуль загружен      }
  }                                               export default function() {
  < /script>                                              alert('Модуль загружен');
  < button onclick = "load">Нажми меня< /button>      }
  < class="menu__komment"><span class="menu__komment">
  Динамический импорт работает в обычных скриптах и не требует указания <b>script type="module"</b>.
  <b>import()</b> - это не функция, а спец.синтаксис, как <b>super()</b>.
  <img src="../img/js/promise.png" alt="">
</span></small>
</details>
<details><!--Browser-->
  <summary>Browser</summary>
  <img src="../img/js/windowJS.png" alt="">
  <details><!--Window-->
    <summary>Window</summary><small>
    <span class="menu__komment"><em>Window</em> = <i>globalThis + DOM + BOM</i> - глобальный объект JS в браузере.
    <i>Object <- EventTarget <- Window</i> - интерфейс Window наследует свойства интерфейса EventTarget
    и реализует свойства из WindowOrWorkerGlobalScope и миксин WindowEventHandlers.
    Объект Window реализует интерфейс Window.
    У каждого окна и у каждой вкладки свой объект Window.</span>
    functionsayHi() {       <span class="menu__komment">глобальные функции доступны как методы глобального объекта</span>
        alert('Hello');
    }
    window.sayHi();

    <em>Window.properties</em>:
    opener - <span class="menu__komment">ссылка на открывающее окно,</span>
    closed - <span class="menu__komment">true (закрыто), false (открыто),</span>
    frames - <span class="menu__komment">коллекция объектов window вложенных ифреймов</span>
    parent - <span class="menu__komment">ссылка на родительское окно</span>
    top - <span class="menu__komment">ссылка на окно самого верхнего уровня</span>

    <em>Window.methods</em>:
    open (url, name, params) - <span class="menu__komment">открывает новое окно и возвращает ссылку на него.</span>
    close()
    focus()
    blur()
    alert("Hello") - <span class="menu__komment">показывает сообщение</span>
    result = promt(title, [default]); - <span class="menu__komment">показывает сообщение и запрашивает у пользователя
    ввод текста. Возвращает напечатанный в поле ввода текст или null.</span>
    result = confirm (question); - <span class="menu__komment">показывает сообщение и ждёт, пока пользователь 
    нажмёт ОК или Отмена. Возвращает true если нажата ОК и fasle - если отмена.</span>
    iframe.contentWindow - <span class="menu__komment">объект Window внутри тега < iframe>
    </span></small>
  </details>
  <details><!--BOM-->
  <summary>BOM</summary><small>
    Browser Object Model - <span class="menu__komment">объектная модель браузера.</span>
    Window.navigator - <span class="menu__komment">информация о браузере пользователя.</span>
    Window.screen - <span class="menu__komment">информация об экране пользователя.</span>
    Window.location - <span class="menu__komment">адресная строка: текущие компоненты.</span>
    Window.frames - <span class="menu__komment">фреймы и ифреймы.</span>
    Window.history - <span class="menu__komment">история посещений (url), движения вперед и назад в окне.</span>
    Window.XMLHttp Request - <span class="menu__komment">встроенный объект для Http запросов к серверу
    без перезагрузки страницы.</span>
    Window.document - <span class="menu__komment">DOM-документ загруженный в окно.
    https://html.spec.whatwg.org</span></small>
  </details>
  <details><!--DOM-->
      <summary>DOM</summary><small>
<em>Document Object Model</em> - <i>объектная модель документа, представляет всё содержимое страницы в виде объектов</i>.
document.body.style.background = "red".
<i>Object <- EventTarget <- Node <- Document</i><span class="menu__komment">
html-документы представленны в браузере в виде дерева DOM.</span>

<em>Веб-воркер</em> — <span class="menu__komment">это JavaScript, который работает в фоновом режиме, 
независимо от других скриптов, не влияя на производительность страницы. 
Вы можете продолжать делать все, что захотите: щелкать, выбирать объекты и т. д.,
пока веб-воркер работает в фоновом режиме.
https://dom.spec.whatwg.org
https://learn.javascript.ru/basic-dom-node-properties#klassy-dom-uzlov
</span></small>
  </details>
  <details><!--Node-->
  <summary>Node</summary><small><span class="menu__komment">
<em>Node</em> - абстрактный класс.
Обеспечивает базовую функциональность для всех узлов.
Объекты класса Node никогда не создаются, но от него наследуются.

<em>Классы</em>:
<em>Text</em> - для текстовых узлов. Содержат текст.
<em>Comment</em> - для узлов-комментариев. Иногда в них можно включить информацию, которая 
не будет поазана, но будет доступна в DOM для чтения JS.
<em>Element</em> - для узлов-элементов. HTML-тэги - строительные блоки документа.
Обеспечивает навигацию на уровне узлов-элементов и служит базой
для классов SVGElement, XMLElement, HTMLElement.

<i>Текст, комментарий и тэг</i> - это DOM-узел.
Каждый DOM-узел принадлежит своему классу.
Для наследования используют классы, основанные на прототипах.
Классы формируют иерархию.
Весь набор свойств и методов является результатом наследования.
<em>DOM-узлы</em> - это обычные JS объекты. Реализация соответствующего класса.
<em>DOM-элемент</em> - это JS объект тэга.

<em>HTMLElement</em> - является базовым классом для всех остальных HTML-элементов.
От него наследуют элементы:
<em>HTMLInputElement</em> - класс для тега < input>
<em>HTMLBodyElement</em> - класс для тега < body>
<em>HTMLAnchorElement</em> - класс для тега < a>
и т.д., 
каждому тегу соответствует свой класс, который представляет свойства и методы:
<em>value</em> - значение для <.input>, <.select> и <.textarea> (HTMLInputElement, HTMLSelectElement, ...).
<em>href</em> - адрес ссылки "href" для <.a href="..."> (HTMLAnchorElement).
<em>id</em> - значение атрибута "id" для всех элементов (HTMLElement).</span>

console.log(elem) <span class="menu__komment">выводит элемент в виде DOM-дерева.</span>
console.dir(elem) <span class="menu__komment">выводит элемент в виде DOM-объекта, 
это удобно для анализа его свойств.

Для изменения элементов или проверки DOM-дерева можем использовать инструменты разработчика в браузере.</span></small>
  </details>
  <details><!--DOM-navigation-->
  <summary>DOM-navigation</summary><small>
<img src="../img/js/Навигация DOM.png" alt=""><span class="menu__komment">
<em>Дочерние узлы (дети)</em> - непосредственные дети-элементы узла.
<em>Потомки</em> - все элементы, внутри данного, ключая детей, их детей и т.д.
Коллекция childNodes содержит список всех детей, включая текст.</span>

elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length-1] === elem.lastChild
<span class="menu__komment">
<em>Соседи</em> - узлы, у которых один и тот же родитель.</span>
< <b>body</b>> - <i>следующий или правый сосоед</i> < <b>head</b>>
< <b>head</b>> - <i>предыдущий или левый сосед</i> < <b>body</b>>

const bodyElement = document.body;
const firstChildNode = bodyElement.firstChild; - <span class="menu__komment">первый узел</span>
const lastChildNode = bodyElement.lastChild; - <span class="menu__komment">последний узел</span>

const childNodes = bodyElement.childNodes; - <span class="menu__komment">список всех детей (узлов) объекта 
                                        (в данном случае body) в виде коллекции</span>
bodyElement.hasChildNodes() - <span class="menu__komment">проверяет есть ли дочерние узлы у объекта true or false

<em>Коллекция</em> - <i>это псевдомассив</i>:
можно перебирать с помощью <b>for( of ) {}</b> и <b>forEach()</b>
методы массива не работают
изменять элемент коллекции как в массиве не получится, только через специальные методы</span>

bodyElement.previousSibling; - <span class="menu__komment">предыдущий соседний узел</span>
bodyElement.nextSibling; - <span class="menu__komment">следующий соседний узел</span>
bodyElement.parentNode; - <span class="menu__komment">родительский узел</span>

<em>Для элементов (тегов)</em>:
bodyElement.childNodes; - <span class="menu__komment">получаем коллекцию всех дочерних узлов</span>
bodyElement.children; - <span class="menu__komment">получаем коллекцию всех дочерних элементов (тегов)</span>
bodyElement.firstElementChild; - <span class="menu__komment">первый элемент</span>
bodyElement.lastElementChild; - <span class="menu__komment">последний элемент</span>
bodyElement.previousElementSibling; - <span class="menu__komment">предыдущий соседний элемент</span>
bodyElement.nextElementSibling; - <span class="menu__komment">следующий соседний элемент</span>
bodyElement.parentElement; - <span class="menu__komment">родительский элемент</span>

<em>Поиск произвольного элемента</em>:
elem.querySelectorAll(CSS); - <span class="menu__komment">возвращает статичную коллекцию со всеми элементами внутри elem,
      соответствующие указанному CSS-селектору
      (класс (с точкой впереди), тег, вложенные теги, атрибут, id и т.д.)
проверяет только последний указанный в CSS-селекторе элемент без учета контекста используется чаще других</span>
querySelector(CSS); - <span class="menu__komment">ищет и возвращает первый попавшийся объект по указанному CSS-селектору</span>
document.getElementById(id без решетки); - <span class="menu__komment">ищет и возвращает элемент по id,
                      ищет только в document</span>
getElementsByTagName(тег); - <span class="menu__komment">возвращает живую коллекцию, ищет где угодно</span>
getElementsByClassName(класс без точки впереди); - <span class="menu__komment">возвращает живую коллекцию, ищет где угодно</span>
document.getElementsByName(атрибут name); - <span class="menu__komment">возвращает живую коллекцию, ищет только в document
живая коллекция - содержит в себе всегда актуальную информацию с учетом изменений в дереве DOM</span>
<img src="../img/js/querySelector.png" alt="">

elem.closest(css) - <span class="menu__komment">ищет ближайшего предка, который соответствует указанному css-селектору</span>
elem.matches(css) - <span class="menu__komment">ничего не ищет, проверяет соответствует ли элемент css селектору,
возвращает true or false</span>

const textElement = document.querySelector('.someClass__text'); - <span class="menu__komment">получил объект</span>
const textElementContent = textElement.innerHTML; - <span class="menu__komment">получил содержимое объекта как есть</span>
textElement.innerHTML = `<i>Новое содержимое объекта</i>`; - <span class="menu__komment">заменил содержимое объекта</span>

const textElement = document.querySelector('.someClass__text'); - <span class="menu__komment">получил объект</span>
const textElementContent = textElement.outerHTML; - <span class="menu__komment">получил содержимое объекта и сам объект</span>
textElement.outerHTML = `< p><i>Новое содержимое объекта</i>< /p>`; - <span class="menu__komment">заменил сам объект</span>

const textElement = document.querySelector('.someClass__text'); - <span class="menu__komment">получил объект</span>
const textElementContent = textElement.textContent; - <span class="menu__komment">получил содержимое объекта без тегов</span>
textElement.textContent = `< p><i>Новое содержимое объекта</i>< /p>`; - <span class="menu__komment">заменил содержимое объекта,
                                      но теги вставляються как текст позволяет записывать получаемый текст безопасно</span>

const textElement = document.querySelector('.someClass__text'); - <span class="menu__komment">получил объект с классом .someClass__text</span>
const getComment = textElement.nextSibling; - <span class="menu__komment">получил следующий объект - комментарий</span>
console.log(getComment.data); - <span class="menu__komment">вывел текст комментария в консоль</span>
getComment.data = `Новый текст`; - <span class="menu__komment">заменил текст комментария</span>

<em>Методы поиска элементов в DOM</em>:
querySelector - <span class="menu__komment">ищет внутри элемента по CSS-selector</span>
querySelectorAll - 
getElementById - <span class="menu__komment">ищет по id</span>
getElementsByName - <span class="menu__komment">возвращает коллекцию, ищет по имени</span>
getElementsByTagName - <span class="menu__komment">возвращает коллекцию, ищет внутри элемента по тегу или "*"</span>
getElementsByClassName - <span class="menu__komment">возвращает коллекцию, ищет внутри элемента по class</span>
elem.matches(css) - <span class="menu__komment">проверяет, удовлетворяет ли элемент CSS-селектору</span>
elem.closest(css) - <span class="menu__komment">ищет ближайшего предка</span>
elemA.contains(elemB) - <span class="menu__komment">вернет true если elemB находится внутри elemA или elemA == elemB</span></small>
  </details>
  <details><!--Document-->
  <summary>Document</summary><small>
<em>Document</em> - <span class="menu__komment">интерфейс доступа к узлам, его реализует объект document.</span>
<em>document</em> - <span class="menu__komment">объект DOM, входная точка в DOM</span>
const htmlElement = document.documentElement; - <span class="menu__komment">получить объект html со всем его содержимым</span>
const headElement = document.head; - <span class="menu__komment">получить объект head со всем его содержимым</span>
const bodyElement = document.body; - <span class="menu__komment">получить объект body со всем его содержимым

<em>DOMContentLoaded</em> генерируется на document, когда DOM готов и к нему можно применить JS.
Изображения и другие ресурсы (стили и т.п.) всё ещё могут продолжать загружаться.</span>
window.onload - <span class="menu__komment">страница и все ресурсы загружены</span>
window.beforeunload - <span class="menu__komment">пользователь покидает страницу. 
Если отменить событие, то браузер спросит хочет ли пользователь уйти.</span>
window.unload - <span class="menu__komment">пользователь окончательно уходит, можно сделать сетевой запрос.</span>
document.readyState - <span class="menu__komment">текущее состояние загрузки документа.

Изменения можно отследить с помощью события <em>readyStateChange</em>:</span>
loading - <span class="menu__komment">документ грузится</span>
interactive - <span class="menu__komment">документ прочитан, происходит перед DOMContentLoaded</span>
complete - <span class="menu__komment">документ и ресурсы загружены, происходит перед window.onload

Скрипт должен дождаться пока загрузятся стили.
Скрипты <b>script... /script</b> или <b>script src="..." /script</b> блокируют DOMContentLoaded.
Скрипты созданные через <b>document.createElement('script')</b>, добавленные на страницу и скрипты с атрибутами async или defer 
не блокируют DOMContentLoaded.
Динамически загружаемые скрипты по умолчанию ведут себя как async,</span>
script.async = false; - <span class="menu__komment">отмена async-поведения</span>
let script = document.createElement('script');
script.src = "<i>путь/к/скрипту</i>";
document.body.append(script);

<b>async</b> - <span class="menu__komment">скрипты выполняются по загрузке, DOMContentLoaded не имеет значения.
<b>defer</b> - скрипты выполняются по расположению в докумете. Скрипт ждёт загружки документа выполняется перед DOMContentLoaded.
defer работает только у внешних скриптов - у которых есть <b>src="..."</b>, все элементы с src="..." дают события:
<b>load</b> - при успешной загрузке,
<b>error</b> - при ошибке
<b>< iframe></b> - исключение: всегда даёт load, даже при ошибке.
Событие <b>readystatechange</b> также работает для ресурсов.
Обработчики onload/onerror отслеживают только сам процесс загрузки.
<b>Window.onerror</b> - позволяет "поймать" ошибки в скрипте.
Скрипт одного сайта не может получить детали ошибки скрипта с другого сайта, нужно поставить тегу <.script> атрибут crossorigin 
и специальные заголовки на удалённом сервере.
<b>MutationObserver</b> - встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.</span>
let observer = newMutationObserver(callback); - создать наблюдатель
observer.observe(node, config); - <span class="menu__komment">прикрепить наблюдателя к DOM-узлу.</span>
observer.disconnect(); - <span class="menu__komment">останавливает наблюдение.</span>
observer.takeRecords(); - <span class="menu__komment">получает список необработанных записей измененений, которые произошли, 
но колбэк для них ещё не выполнился.

В основе выделения лежит <em>Range(диапозон)</em> - пара граничных точек: начало и конец диапозона.
<em>Range</em> - общий, объект для управления диапозоном.
Выделение в документе представлено объектом Selection, который можно получить как 
<b>window.getSelection()</b> или <b>document.getSelection()</b>.
<em>Selection</em> (выделение) имеет начальную границу (якорь) и конечную (фокус).

Основные свойства выделения:</span>
anchorNode - <span class="menu__komment">узел начала выделения</span>
anchorOffset - <span class="menu__komment">смещение в anchorNode, где начинается выделение</span>
focusNode - <span class="menu__komment">узел окончания выделения</span>
focusOffset - <span class="menu__komment">смещение в focusNode, где выделение заканчивается</span>
inCollapsed - <span class="menu__komment">true, если диарозон выделения пуст или не существует</span>
rangeCount - <span class="menu__komment">количество диапозонов в выделении

<em>document.cookie</em> предоставляет доступ к куки:
- операция записи изменяет только те куки, которые было указано
- имя и значение куки должны быть закодированы
- одно уки вмещает до 4 kb данных, количество куки зависит от браузера.</span>

<em>Настройки куки</em>:
path = / - <span class="menu__komment">по умолчанию текущий путь, делает куки видимыми только по указанному пути и ниже</span>
domain = site.com - <span class="menu__komment">по умолчанию куки видно только на текущем домене, если явно указан домен, 
то куки видно и на поддоменах</span>
expires или max-age - <span class="menu__komment">устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.</span>
secure - <span class="menu__komment">делает куки доступными только при использовании HTTPS</span>
somesite - <span class="menu__komment">запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки</span>

<em>Методы создания узлов</em>:
document.createElement(tag) - <span class="menu__komment">создаёт элемент с заданным тегом</span>
document.createTextNode(value) - <span class="menu__komment">создаёт текстовый узел</span>
document.write(html) - <span class="menu__komment">добавляет html на страницу до завершения её загрузки.

После загрузки затирает начальный документ.</span>
const newElement = document.createElement(`div`); - <span class="menu__komment">создал элемент: тег div</span>
const newText = document.createTextNode(`Новый текст`); - <span class="menu__komment">создал текстовый узел</span>
elem.cloneNode(deep) - <span class="menu__komment">клонирует элемент, если deep == true, то со всеми дочерними элементами.

Вставка и удаление узлов:</span>
node.append(...nodes or strings) - <span class="menu__komment">вставляет в node в конец</span>
node.prepend(...nodes or strings) - <span class="menu__komment">вставляет в node в начало</span>
node.before(...nodes or strings) - <span class="menu__komment">вставляет прямо перед node</span>
node.after(...nodes or strings) - <span class="menu__komment">вставляет сразу после node</span>
node.replaceWith(...nodes or strings) - <span class="menu__komment">заменяет node</span>
node.remove() - <span class="menu__komment">удаляет node</span>
elem.beforebegin - <span class="menu__komment">вставляет html прямо перед elem</span>
elem.afterbegin - <span class="menu__komment">вставляет html в elem в начало</span>
elem.beforeend - <span class="menu__komment">вставляет html в elem в конец</span>
elem.afterend - <span class="menu__komment">вставляет html сразу после elem</span>
elem.insertAdjacentText - <span class="menu__komment">вставляет текстовые строки</span>
elem.insertAdjacentElement - <span class="menu__komment">вставляет элементы</span>
textElement.before(newElement); - <span class="menu__komment">вставил newElement перед textElement</span>
textElement.after(newElement); - <span class="menu__komment">вставил newElement после textElement</span>
textElement.prepend(newElement); - <span class="menu__komment">вставил newElement в начало внутри объекта textElement</span>
textElement.append(newElement); - <span class="menu__komment">вставил newElement в конец внутри объекта textElement</span>
<i>либо</i>
textElement.append(newElement, `Новый текст`); - <span class="menu__komment">можно вставлять через запятую,
                      но теги вставляються как текст</span>
textElement.insertAdjacentHTML('pos', `ins`); - <span class="menu__komment">позволяет вставить в DOM что угодно</span>
      pos - <span class="menu__komment">место вставки по отношению к textElement</span>
          beforebegin - <span class="menu__komment">вставить перед textElement</span>
          afterbegin - <span class="menu__komment">вставить в начало textElement</span>
          beforeend - <span class="menu__komment">вставить в конец textElement</span>
          afterend - <span class="menu__komment">вставить после textElement</span>
      ins - <span class="menu__komment">то что вставляем, позволяет вставить теги</span>
insertAdjacentText();
insertAdjacentElement();
textElement.append(oldElement); - <span class="menu__komment">перенес существующий oldElement в конец textElement</span>
let cloneOldElement = oldElement.cloneNode(); - <span class="menu__komment">клонировал без дочерних элементов</span>
let cloneOldElement = oldElement.cloneNode(true); - <span class="menu__komment">клонировал с дочерними элементами</span>
textElement.remove(); - <span class="menu__komment">удаление объекта</span>
const elementClassNames = element.className; - <span class="menu__komment">получил все классы объекта element</span>
element.className = "red"; - <span class="menu__komment">заменил все классы на класс red</span>
element.classList.add('active'); - <span class="menu__komment">добавить класс</span>
element.classList.remove('active'); - <span class="menu__komment">удалить класс</span>
element.classList.toggle('active'); - <span class="menu__komment">добавить класс если его нет, а если есть, то удалить</span>
element.classList.contains('active'); - <span class="menu__komment">проверяет наличие класса, возвращает true or false</span>
element.style.color = "red"; - <span class="menu__komment">получаем доступ к атрибуту style HTML-тега и задаём цвет</span>
console.log(element.style.marginBottom); - <span class="menu__komment">вывод в консоль значения css-свойство атрибута style
              HTML-тега объекта element</span>
element.style.color = ""; - <span class="menu__komment">удалил css-свойство из атрибута style HTML-тега</span>
element.style.cssText = `
margin-bottom: 30px;
color: red;
`; - <span class="menu__komment">записываю сразу несколько css-свойств в атрибут style, перезаписывает style полностью</span>
const elementStyle = getComputedStyle(element); - <span class="menu__komment">получил вычисленные стили элемента
console.log(elementStyle.fontSize); - <span class="menu__komment"></span>выводим вычисленое значение размера шрифта</span>
const elementBeforeStyle = getComputedStyle(element, "::before"); - <span class="menu__komment">получил стили псевдоэлемента</span>
console.log(elementBeforeStyle.backgroundColor); - <span class="menu__komment">выводим цвет фона, который реализован с помощью ::before</span>
getComputedStyle(); - <span class="menu__komment">работает только для чтения</span>
const paddingLeft = parseInt(elementStyle.paddingLeft); - <span class="menu__komment">сразу перевожу значение из строки в число</span>
element.style.marginLeft = "20px"; - <span class="menu__komment">задавать значения всегда с единицами измерения

Устаревшие методы (возвращают node):</span>
parent.appendChild(node)
parent.insertBefore(node, nextSibling)
parent.removeChild(node)
parent.replaceChild(newElem, node)

document.forms - <span class="menu__komment">живая коллекция всех форм на странице document.forms[name/index]
Элементы < form> или < fieldset> доступны через <b>form.elements[name/index]</b> или <b>form[name/index]</b>.
Элементы хранят ссылку на свою форму в свойстве element.form.
Значения элементов формы доступны через input.value, textarea.value, select.value и т.д. либо input.cheked для чекбоксов и переключателей.

Для < select> можно получить индекс выбранного пункта через: <b>select.selectedIndex</b> либо <b>select.options</b>.
Элемент получает фокус когда пользователь кликает по нему или использует Tab.

HTML-атрибут <b>auto-focus</b> - устанавливает фокус при загрузке страницы.
HTML позволяет делать валидацию с помощью атрибутор required, pattern и т.д.
События <b>focus и blur</b> срабатывают на фокусировке/потере фокуса элемента и не всплывают, 
но можно использовать фазу перехвата или focusin/focusout.
tabindex делает фокусируемым любой элемент.</span>

document.activeElement - <span class="menu__komment">текущий элемент с фокусом.</span>
const form = document.forms[0] - <span class="menu__komment">получить форму по индексу коллекции</span>
const form = document.forms.main - <span class="menu__komment">по аттрибуту тега name (<i>name="main"</i>)</span>

document.querySelectorAll('form') - <span class="menu__komment">неживая коллекция</span>

const form = document.forms.main
console.log(form.elements) -  <span class="menu__komment">вывел элементы формы</span>

focus, blur - <span class="menu__komment">события не всплывают</span>
focus(), blur() - <span class="menu__komment">методы. Аттрибут taindex = -1 на клавишу tab не реагирует,
      но можно установить фокус на елемент методом</span>
document.activeElement - <span class="menu__komment">получаем текущий элемент с фокусом</span>
focusin / focusout - <span class="menu__komment">события всплывают</span>

<em>События изменения данных:</em>
change - <span class="menu__komment">значение изменено. срабатывает в текстовом поле при потере фокуса, в остальных полях при выборе.</span>
input - <span class="menu__komment">значение изменено. Срабатывает немедлено при каждом изменении текстового поля.</span>
cut/copy/paste - <span class="menu__komment">свойство event.clipboardData даёт доступ на чтение/запись в буфер.</span>
cut - <span class="menu__komment">событие, срабатывает при вырезании</span>
copy - <span class="menu__komment">событие, срабатывает при копировании</span>
paste - <span class="menu__komment">событие, срабатывает при вставке</span>
submit - <span class="menu__komment">событие отправки данных формы, при <b>form.submit()</b> - форма отправится при потере фокуса</span>
event.preventDefault() - <span class="menu__komment">запретит выполнение события

<em>Отправка формы:</em>
Нажать кнопку < <b>input type="submit"</b>> или < <b>input type="image</b>">
Нажать Enter на любом поле
При отправке формы по нажатию Enter в текстовом поле, генерируется событие click на кнопке < input type="submit">
При отправке формы срабатывает событие submit, оно используется для проверки формы перед её отправкой на сервер 
или для отмены отправки и обработки её с помощью JS.
<b>form.submit()</b> позволяет отправить форму из JS. Используют для создания и отправки собственных форм на сервер, 
при этом событие submit не генерируется.

<em>scroll</em> - событие прокрутки позволяет реагировать на прокрутку страницы или элемента.</span>
window.addEventListener('scroll', function() {
document.getElementById('showScroll').innerHTML = pageYOffset + 'px';
});
</small>
  </details>
  <details><!--EventTarget-->
  <summary>EventTarget</summary>
<small>
<em>EventTarget</em> - <span class="menu__komment">это абстрактный класс.
Обеспечивает поддержание DOM-узлами событий.
<em>Event</em>(<i>Событие</i>) - сигнал от браузера о том, что что-то произошло.
Событию можно назначить обработчик - функцию, которая сработает, как только событие произошло.
Способы назначения обработчиков событий:
Атрибут HTML: <b>onclick="..."</b>.
DOM-свойство: <b>elem.onclick = function</b>.
Методы: <b>elem.addEventListener(event, handler[, phase])</b> для добавления</span>
event - <span class="menu__komment">имя события, например "click".</span>
handler - <span class="menu__komment">ссылка на фуекцию обработчик.</span>
options - <span class="menu__komment">дополнительный объект со свойствами:
<b>once</b>: если true, тогда обработчик будет удалён после выполнения.
<b>capture</b>: фаза, на которой должен сработать обработчик (false/true)
<b>passive</b>: если true, то обработчик не вызовет preventDefault()

Обработчик всегда хранится в свойстве DOM-объекта, а атрибут - лишь один из способов его инициализации.
В DOM-свойстве один обработчик на один тип события, так как одно имя - одно свойство.
<i>Методы</i> - самый гибкий и используемый способ.
<b>addEventListener</b> поддерживает объекты в качестве обработчиков событий, вызывая метод объекта object.handleEvent(event).
Убрать обработчик elem.onclick = null.
Не используй setAttribute для обработчиков.
Регистр DOM-свойства имеет значение, а HTML-атрибута - нет.
Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.
Любой обработчик получает объект события первым аргументом</span>
event.type - <span class="menu__komment">тип события, например "click"</span>
event.clientX/event.clientY - <span class="menu__komment">координаты курсора для событий мыши в момент клика относительно окна.</span>

<em>События</em>:
onclick="JScode" - <span class="menu__komment">обработчик события, аттрибут тега.</span>
const button = document.querySelector('.button');
button.onclick = function () {}; - <span class="menu__komment">нет возможности повесить на одно событие несколько обработчиков</span>
<i>либо</i>
function showClick() {}
button.onclick = showClick; - <span class="menu__komment">нет возможности повесить на одно событие несколько обработчиков</span>

button.addEventListener("click", function (e) {}); - <span class="menu__komment">можно назначить обработчик несколько раз</span>
<i>либо</i>
button.addEventListener("click", func);
function func(e) {}

button.removeEventListener(event, handler); - <span class="menu__komment">отключает обработчик</span>

button.addEventListener(event, handler, options); - <span class="menu__komment">можно добавить параметры</span>
const options {
"capture: false", - <span class="menu__komment">фаза, на которой должен сработать обработчик (всплытие/погружение)</span>
"once": false, - <span class="menu__komment">если true, тогда обработчик будет удален после выполнения</span>
"passive": false - <span class="menu__komment">если true, то обработчик никогда не вызовет preventDefault()</span>
}
<i>либо</i>
button.addEventListener("click", func, {"once": true});
<span class="menu__komment">
Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его
в качестве аргумента (event) функции - обработчику:</span>
event.type - <span class="menu__komment">тип события</span>
event.target - <span class="menu__komment">объект, на котором сработал обработчик</span>
event.currentTarget - <span class="menu__komment">объект, которому назначен обработчик</span>
event.clientX - <span class="menu__komment">положение курсора по Х</span>
event.clientY - <span class="menu__komment">положение курсора по Y</span>
console.log(evant) - <span class="menu__komment">посмотреть все детали события</span>
event.stopPropagation(); - <span class="menu__komment">остановка всплытия</span>

<em>Делегирование</em> - <span class="menu__komment">вешаем прослушку на родителя</span>
Отмена действий браузера по умолчанию:
event.preventDefault(); - <span class="menu__komment">для addEventListener</span>
<i>либо</i>
button.addEventListener("click", func, {"passive": true});

link.onclick = function () { - <span class="menu__komment">для onclick</span>
return false;
}

<em>Всплытие и погружение:</em>
целевой элемент <b>(event.target)</b> - <span class="menu__komment">самый глубоко вложенный элемент, над которым произошло событие.
Сначала событие двигается вниз (погружение) от корня документа к event.target, по пути вызывая обработчики, 
поставленные через <b>addEventListener(..., true)</b>,
где true - сокращенно {capture: true}
Далее обработчики на целевом элементе.
Потом событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, 
поставленные через on< event> и addEventListener без третьего аргумента
или с третьим аргументом равным fasle.
Каждый обработчик имеет доступ к свойствам события event:</span>
event.target - <span class="menu__komment">самый глубокий элемент, на котором произошло событие</span>
event.currentTarget(=this) - <span class="menu__komment">элемент, на котором в данный момент сработал обработчик 
(тот, на котором "висит" конкретный обработчик)</span>
event.eventPhase - <span class="menu__komment">не какой фазе он сработал: (погружение = 1, фаза цели = 2, всплытие = 3)

Любой обработчик может остановить событие вызовом <b>event.stopPropagation()</b>.
Всплытие и погружение являются основой для делегирования событий.
Делегирование событий используется при схожей обработке многих элементов.
Вешаем обработчик на контейнер.
В обработчике проверяем целевой элемент <b>event.target</b>.
Если событие произошло на нужном элементе, то обрабатываем его.
Использование
Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
Удобство изменений DOM: можно массово добавлять или удалятьэлементы путём изменения innerHTML и ему подобных.

Событие должно всплывать. Низкоуровневые обработчики не должны вызывать event.stopPropagation().
Два способа отменить действие браузера по умолчанию:</span>
- event.preventDefault() - <span class="menu__komment">основной способ</span>
<i>либо</i>
- <.a href="/" onclick = "event.preventDefault()">здесь< /a><span class="menu__komment">
Опция <b>passive</b>: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено.
Это сообщит браузеру, что он не должен ждать выполнения всех обработчиков, 
а ему следует сразу приступать к выполнению действия по умолчанию, например к прокрутке.
event.defaultPrevented равно true если событие по умолчанию отменено, иначе false.
Чтобы сгенерировать событие из кода, вначале нужно создать объект события</span>
let event = newEvent(name[, options]);<span class="menu__komment">
Базовый конструктор Event(name, options) принимает обязательное имя события и options - объект с тремя свойствами:</span>
- bubbles: true - <span class="menu__komment">чтобы событие всплывало</span>
- cancelable: true - <span class="menu__komment">если нужно, чтобы работал event.preventDefault()</span>
- composed: true/false - <span class="menu__komment">если true, то событие будет всплывать наружу за пределы Shadow DOM.
По умолчанию все три свойства</span> - false: {bubbles: false, canselable: false, composed: false}.
elem.dispatchEvent(event) - <span class="menu__komment">запускает объект события на элементе.</span>
event.isTrusted - <span class="menu__komment">true для событий от пользователя и false для генерирующих.</span>
on<.event> - <span class="menu__komment">для встроенных событий, addEventListener - для генерируемых.
При создании встроенных событий использовать конструкторы встроенных событий (newMouseEvent("click") и др.)
Для пользовательских событий применять конструктор CustomEvent.
event.detail позволяет передавать информацию в объекте события.
Генерировать встроенные события в случаях:
- явный грубый хак, чтобы заставить работать сторонние библиотеки, если нет другого способа.
- скриптом нажать на кнопку для автоматического тестирования.</span>

<em>События мыши:</em>
click - <span class="menu__komment">кликнули на элемент левой кнопкой мыши (на устройсвах с сенсорными экранами - при касании).</span>
contextmenu - <span class="menu__komment">происходит, когда кликнули на элемент правой кнопкой мыши</span>
mouseover/mouseout - <span class="menu__komment">когда мышь наводится на/покидает элемент.</span>
mousedown/mouseup - <span class="menu__komment">когда нажали/отжали кнопку мыши на элементе.</span>
mousemove - <span class="menu__komment">при движении мыши.
Комплексные события состоят из простых, обработчики событий вызываются в следующем порядке: mousedown -> mouseup -> click
Свойство события мыши which - какая кнопка мыши нажата:</span>
- event.which == 1 - <span class="menu__komment">левая кнопка</span>
- event.which == 2 - <span class="menu__komment">средняя кнопка</span>
- event.which == 3 - <span class="menu__komment">правая кнопка
Клавиши - модификаторы</span> (true если нажаты): altKey, ctrKey и metaKey (Mac).<span class="menu__komment">
В Мас обычно Cmd вместо ctrl, поэтому лучше проверить: if(e.metaKey || e.ctrlKey).
Координаты относительно окна: clientX, clientY.
Координаты относительно документа: pageX/pageY.
Запрет копирования:</span> <.div oncopy = "alert('Копрование запрещено!'); return false"><span class="menu__komment">
При быстром движении мыши события не будут возникать на промежуточных элементах.
Браузер периодически проверяет позицию курсора и при изменении генерирует событие mousemove.
Если был mouseover, то будет и mouseout.
События mouseover/out и mouseenter/leave имеют дополнительное свойство relatedTarget.
Для события mouseover:</span>
event.target - <span class="menu__komment">это элемент, на который курсор пришёл.</span>
event.relatedTarget - <span class="menu__komment">это элемент, с которого курсор пришёл</span> (target -> relatedTarget)
event.relatedTarget равно null - <span class="menu__komment">указатель мыши пришёл из-за или ушёл за пределы окна.
В любой момент времени указатель может быть только над одним элементом - над самым глубоко вложенным.
События <b>mouseover/out</b> возникают, когда происходит переход с родительского элемента на потомка.
События <b>mouseenter/leave</b> не всплывают и генерируются, когда курсор переходит или уходит на элемент в целом (без учёта потомков).</span>

<em>Простые</em>:
mousedown / mouseup - <span class="menu__komment">кнопка мыши нажата / отпущена над элементом</span>
mouseover / mouseout - <span class="menu__komment">курсор мыши появляется над элементом и уходит с него</span>

<em>mouseover</em>:
event.target - <span class="menu__komment">элемент откуда ушёл курсор</span>
event.relatedTarget - <span class="menu__komment">элемент куда ушёл курсор</span>

<em>mouseout</em>:
event.target - <span class="menu__komment">элемент куда пришёл курсор</span>
event.relatedTarget - <span class="menu__komment">элемент откуда пришёл курсор</span>

mousemove - <span class="menu__komment">каждое движение мыши над элементом генерирует это событие</span>
contextmenu - <span class="menu__komment">вызывается при попытке открытия контекстного меню</span>

<em>Комплексные</em>
click - <span class="menu__komment">mousedown и mouseup над одним и тем же элементом</span>
dblclick - <span class="menu__komment">двойной клик на элементе</span>

event.which = 1 - <span class="menu__komment">нажата основная кнопка мыши (левая)</span>
event.which = 2 - <span class="menu__komment">нажата средняя кнопка мыши (колесо)</span>
event.which = 3 - <span class="menu__komment">нажата не основная кнопка мыши (правая)</span>

mouseover / mouseout - <span class="menu__komment">всплывают, можно использовать делегирование,</span>
mouseenter / mouseleave - <span class="menu__komment">нет</span>

<em>Базовый алгоритм Drag'n'Drop.</em>
При mousedown - готовим элемент к перемещению (если нужно создаём его копию).
При mousemove передвигаем элемент на новые координаты путём смены left/top и position: absolute.
При mouseup - остановить перенос элемента и произвести окончание Drag'n'Drop.
Ключевые идеи:
<b>object.mousedown -> document.mousemove -> object.mouseup</b><span class="menu__komment">
(обязательно отменить браузерный ondragstart)
В начале перетаскивания запоминаем начальное смещение указателя относительно элемента(shiftX/shiftY) и сохраняем его при перетаскивании.
Выявляем потенциальные цели переноса под указателем с помощью <b>document.elementFromPoint</b>.
На mouseup завершить перенос: изменить данные, переместить элементы.

<em>События указателя</em> (<i>Pointer events</i>) одновременно обрабатывают действия мыши, касания пера.
Содержат свойства мыши и дополнительно свои:</span>
pointerId - <span class="menu__komment">идентификатор указателя, вызвавшего событие, генерируется браузером, 
позволяет обрабатывать несколько указателей (стилус и мультитач).</span>
pointerType - <span class="menu__komment">тип указывающего устройства. Строка с одним из значений: "mouse", "pen" или "touch".</span>
isPrimary - <span class="menu__komment">равно true для основного указателя (<i>первый палец в мультитач</i>).
При обработке переносов и сложных касаний нужно отменить действие браузера и ставить <b>touch-events: none</b> в CSS для элементов.
Можно перенаправить (захватить) все события указателя на определённый элемент до наступления события pointerup/pointercancel.
Два связанных с захватом события:
<b>getpointercapture</b> срабатывает, когда элемент использует <b>setPointerCapture</b> для включения захвата.
<b>lostpointercapture</b> срабатывает при освобождении от захвата:
- явно с помощью <b>releasePointerCapture</b> или
- автоматически при событии <b>pointerup/pointercancel</b>.
</span>
<em>Сбытия указателя - мыши</em>:
pointerdown - mousedown
pointerup - mouseup
pointermove - mousemove
pointerover - mouseover
pointerenter - mouseenter
pointerleave - mouseleave
pointercancel - 
getpointercapture - 
lostpointercapture - 

<em>События клавиатуры</em>:
keydown - <span class="menu__komment">происходит при нажатии клавиши</span>
keyup - <span class="menu__komment">при отпускании клавиши</span>
event.code - <span class="menu__komment">код нажатой клавиши ("KeyA", "ArrowLeft" и т.д.)</span>
event.key - <span class="menu__komment">клавиша с учетом регистра и раскладки клавиатуры символ ("A", "a" и т.д.)</span>
event.repeat - <span class="menu__komment">вернет true при срабатывании повтора на зажатой клавише
Нажатие клавиши всегда генерирует клавиатурное событие, кроме клавиши Fn.</span>

<em>Прокрутка</em>:
scroll - <span class="menu__komment">событие прокрутки</span>
scrollY - <span class="menu__komment">количество прокрученных пикселей по вертикали</span>
scrollX - <span class="menu__komment">количество прокрученных пикселей по горизонтали</span>

<em>Загрузка</em>:
DOMContentLoaded - <span class="menu__komment">браузер полностью загрузил HTML, построил DOM-дерево, 
но внешние ресурсы могут быть ещё не загружены
срабатывает на объекте document</span>
load - <span class="menu__komment">браузер полностью загрузил HTML, и внешние ресурсы
срабатывает на объекте window</span>
beforeunload / unload - <span class="menu__komment">пользователь покидает сраницу</span>
beforeunload - <span class="menu__komment">можем вывести пользователю предупреждение о несохраненных данных в форме</span>
unload - <span class="menu__komment">пользователь уже ушёл состраницы, но можно поручить браузеру собрать статистику</span>

document.readyState - <span class="menu__komment">остояние загрузки:</span>с
loading - <span class="menu__komment">документ загружается</span>
interactive - <span class="menu__komment">документ был полностью прочитан</span>
complete - <span class="menu__komment">документ был полностью прочитан и все ресурсы загружены

События, отправленные сервером (SSE), позволяют веб-странице получать обновления с сервера.
В случае событий, отправленных сервером, обновления приходят автоматически.</span>
</small>
  </details>
  <details><!--Properties-->
  <summary>Properties</summary><small>
<span class="menu__komment">
Когда браузер загружает страницу, он читает (парсит) HTML и генерирует DOM-объекты.
Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся
свойствами DOM-объектов.
У каждого тега свои атрибуты:
Атрибуты написаны в HTML, свойства - в DOM-объектах.
Можно изменять DOM-узлы добавляя своё свойство.
Методы для работы с атрибутами:</span>
elem.hasAttribute(name) - <span class="menu__komment">проверить на наличие</span>
elem.getAttribute(name) - <span class="menu__komment">получить значение</span>
elem.setAttribute(name, value) - <span class="menu__komment">установить значение</span>
elem.removeAttribute(name) - <span class="menu__komment">удалить атрибут</span>
elem.attributes - <span class="menu__komment">коллекция всех аттрибутов</span>

<em>Свойства</em>:
nodeType - <span class="menu__komment">тип DOM-узла.</span>
Только для чтения.
Его значение-числовое: 1- элементы, 3 - текстовые узлы и т.д.

nodeName/tagName - <span class="menu__komment"></span>возвращает название тега.
Только для чтения.
Для узлов - неэлементов описывает, что за узел.</span>

innerHTML - <span class="menu__komment">внутренее HTML-содержимое узла-элемента.
Изменяемый.
С innerHTML вставка происходит "как HTML", со всеми HTML-тегами.</span>

console.dir(element); - <span class="menu__komment">выведет список доступных свйоств DOM-объекта element</span>
element.hasAttribute('some-name'); - <span class="menu__komment">проверить наличие аттрибута name</span>
element.getAttribute('some-name'); - <span class="menu__komment">получить значение аттрибута name</span>
element.setAttribute('some-name', value); - <span class="menu__komment">создать аттрибут (some-name) и 
              установить в него значение (value)</span>
element.removeAttribute('some-name'); - <span class="menu__komment">удалить аттрибут name</span>
element.tagName - <span class="menu__komment">показывает какой тег у объекта</span>
element.hidden = true; - <span class="menu__komment">скрыть или показать объект</span>
<img src="../img/js/JS58.png" alt="">
<img src="../img/js/JS59.png" alt="">
<img src="../img/js/JS60.png" alt="">
<img src="../img/js/JS61.png" alt="">

<em>Размеры и координаты</em>
const mainElement = document.documentElement; - <span class="menu__komment">получил объект html</span>
const mainElementWidth = mainElement.clientWidth; - <span class="menu__komment">доступная ширина окна без прокрутки</span>
const mainElementHeight = mainElement.clientHeight; - <span class="menu__komment">доступная высота окна без прокрутки</span>

const windowWidth = window.innerWidth; - <span class="menu__komment">ширина окна с полосой прокрутки</span>
const windowHeight = window.innerHeight; - <span class="menu__komment">высота окна с полосой прокрутки

Ширину и высоту всего документа (включая прокрученную часть) можно найти:</span>
let scrollWidth = Math.max(
document.body.scrollWidth, document.documentElement.scrollWidth,
document.body.offsetWidth, document.documentElement.offsetWidth,
document.body.clientWidth, document.documentElement.clientWidth,
);

let scrollHeight = Math.max(
document.body.scrollHeight, document.documentElement.scrollHeight,
document.body.offsetHeight, document.documentElement.offsetHeight,
document.body.clientHeight, document.documentElement.clientHeight,
);

<em>Метрики</em>
<img src="../img/js/metrics.png" alt="">
element.offsetParent; - <span class="menu__komment"></span>получаем родительский элемент, относительно которого позиционирован element</span>
element.offsetLeft; - <span class="menu__komment"></span>отступ слева от родительского элемента element.offsetParent</span>
element.offsetTop; - <span class="menu__komment"></span>отступ сверху от родительского элемента element.offsetParent</span>
element.offsetWidth; - <span class="menu__komment"></span>общая ширина element</span>
element.offsetHeight; - <span class="menu__komment"></span>общая высота element</span>
element.clientTop; element.clientLeft; - <span class="menu__komment"></span>отступы внутренней части element от внешней</span>
element.clientWidth; element.clientHeight; - <span class="menu__komment"></span>размеры объекта без рамок и полосы прокрутки</span>
element.scrollWidth; element.scrollHeight; - <span class="menu__komment"></span>размеры объекта без рамок и полосы прокрутки,
                      включая прокручиваемую часть внутри объекта</span>
element.scrollLeft; element.scrollTop; - <span class="menu__komment"></span>размеры прокрученной области внутри объекта, 
                  можно считывать и задавать значения
                  к объекту можно применять scrollBy, scrollTo, scrollIntoView</span>
element.getBoundingClientRect(); - <span class="menu__komment"></span>получить координаты относительно окна браузера</span>
element.getBoundingClientRect().top + window.pageYOffset; - <span class="menu__komment"></span>получить координаты относительно документа</span>
const elem = document.elementFromPoint(x, y); - <span class="menu__komment"></span>узнать какой элемент находится по указанным
                  координатам (координаты относительно окна браузера)</span>

data-аттрибут - <span class="menu__komment"></span>для ввода нестандартных аттрибутов:</span>
element.dataset.size = "1024"; - <span class="menu__komment"></span>установил в аттрибут data-size значение 1024</span>
<.script>
alert(document.body.innerHTML); - <span class="menu__komment"></span>читаем текущее содержимое</span>
document.body.innerHTML = 'Новый BODY!'; - <span class="menu__komment"></span>заменяем содержимое</span>
<./script>
Если innerHTML вставляет в документ тег <.script> - <span class="menu__komment">он становится частью HTML, но не запускается.

<em>outerHTML</em> - полный HTML узла-элемента.
Запись в elem.outerHTML заменяет elem во внешнем контексте.</span>
< div id = "elem"><i>Привет</i> <i>Мир</i>< /div>
<.script>
alert(elem.outerHTML); - < div id = "elem"><i>Привет</i> <i>Мир</i>< /div>
<./script>
<em>textContent</em> - <span class="menu__komment"></span>текст внутри элемента: HTML за вычетом всех тегов.
Запись в него помещает текст в элемент, при этом все спецюсимволы и теги интерпретируются как текст.
Можно использовать для защиты от вставки произвольного HTML кода.
<em>hidden</em> - если true, то скрывает элемент.
<em>nodeValue и data</em> - содержимое узла-неэлемнта (текст, комментарий).
Обычно используют data. Изменяемый.
< body>
<i>Привет</i>
Комментарий
<.script>
let comment = text.nextSibling;
alert(comment.data); - Комментарий
<./script>
< /body>
<span class="menu__komment"></span>
JS может прочитать if из свойства data и обработать инструкции:
if isAdmin
< div><i>Добро пожаловать, Админ!</i>< /div>
/if <span class="menu__komment"></span>
Лучше использовать DOM-свойства. Атрибуты используем тогда, когда нужны именно атрибуты.
Например нестандартный атрибут. Если он начинается с data-, то нужно использовать dataset.
< body data-about = "Elephants">
<.script>
alert(document.body.dataset.about); - Elephants
<./script><span class="menu__komment">
Атрибут из нескольких слов data-order-state это свойство dataset.orderState
Геометрические свойства (метрики) DOM-элементов
<em>offsetParent</em> - ближайший CSS-позиционированный родитель или td, th, table, body.
<em>offsetLeft/offsetTop</em> - позиция в пикселях верхнего левого угла offsetParent.
<em>offsetWidth/offsetHeight</em> - внешняя ширина/высота элемента, включая рамки.
<em>clientLeft/clientTop</em> - это border - отступ внутренней части элемента от внешней.
<em>clientWidth/clientHeight</em> - ширина/высота сожержимого вместе 
с внутренними отступами padding, но без полосы прокрутки.
<em>scrollWidth/scrollHeight</em> - ширина/высота содержимого с учетом 
прокрученной (невидимой) области элемента.
<em>scrollLeft/scrollTop</em> - ширина/высота прокрученной сверху части элемента,
считается от верхнего левого угла.

Все кроме scrollLeft/scrollTop доступны только для чтения.
Если элемент, или любой его родитель, имеет display:none или отсутствует в документе, 
то все его метрики равны нулю (или null если это offsetParent).
Лучше использовать свойства-метрики т.к. CSS-свойства width/height зависят от другого свойства - box-sizing,
которое определяет CSS-ширину/высоту.
Изменение box-sizing сломает код.
CSS-свойства width/height могут быть равны auto.
Ширина/высота видимой части документа:</span>
document.documentElement.clientWidth/Height<span class="menu__komment">
Ширина/высота всего документа с прокрученной частью:</span>
let scrollHeight = Math.max(
document.body.scrollHeight, document.documentElement.scrollHeight,
document.body.offsetHeight, document.documentElement.offsetHeight,
document.body.clientHeight, document.documentElement.clientHeight,
);
<em>Прокрутка</em>:
window.pageYOffset/pageXOffset - <span class="menu__komment">прокрутка окна.</span>
window.scrollTo(pageX, pageY) - <span class="menu__komment">абсолютные координаты.</span>
window.scrollTo(0, 0) - <span class="menu__komment">прокрутка в самое начало.</span>
window.scrollBy(x, y) - <span class="menu__komment">прокрутка относительно текущего места.</span>
window.scrollBy(0, 10) - <span class="menu__komment">прокручивает страницу на 10рх вниз.</span>
window.scrollIntoView(top) - <span class="menu__komment">прокрутить страницу, чтобы elem стал видимым
(выровнять относительно верхней/нижней части окна).

Количество прокрученных пикселей (только для чтения):</span>
const windowScrollTop = window.pageYOffset; - <span class="menu__komment">количество пикселей прокрученных сверху</span>
const windowScrollLeft = window.pageXOffset; - <span class="menu__komment">количество пикселей прокрученных слева</span>
window.scrollBy(x, y); - <span class="menu__komment">прокручивает страницу относительно текущего положения</span>
window.scroll(x, y); - <span class="menu__komment">прокручивает страницу на абсолютные координаты</span>
window.scrollTo(x, y) - <span class="menu__komment">прокручивает страницу на абсолютные координаты</span>
element.scrollIntoView(top); - <span class="menu__komment">прокрутит страницу до элемента element.
          Если top = true, то элемент будет вверху страницы
          Если top = false, то элемент будет внизу страницы
Запретить или разрешить прокрутку:</span>
document.body.style.overflow = "hidden"; - <span class="menu__komment">добавляет overflow = "hidden" в аттрибут style тега body</span>
<i>либо</i>
document.body.classList.toggle('scroll-lock'); - <span class="menu__komment">добавляет класс в тег body,
потом нужно добавить в класс css-свойство</span> overflow = "hidden"
<span class="menu__komment">
Для прокрутки страницы из JS её DOM должен быть полностью построен.</span>
document.body.style.overflow = "hidden"<span class="menu__komment">
Все координаты в контексте окна считаются от верхнего левого угла.</span>
position: fixed; - <span class="menu__komment">для координат относительно окна.</span>
position: absolute; - <span class="menu__komment">для координат относительно документа.
Любая точка на странице имеет координаты:
- относительно окна браузера</span> - elem.getBoundingClientRect()<span class="menu__komment">
- относительно документа</span> - elem.getBoundingClientRect() + прокрутка страницы.
document.elementFromPoint(x, y) - <span class="menu__komment">возвращает самый глубоко вложенный элемент по координатам (х, у). 
Для координат вне окна возвращает null.

<em>CSS</em>:
CSS-событие transitioned - CSS-анимация завершена.
Два способа задания стилей элементу:</span>
< div class=" "> - <span class="menu__komment">создать класс в CSS и использовать его</span>
< div style="color:some"> - <span class="menu__komment">писать стили в атрибуте style
JS может менять и классы CSS и свойство style.
Лучше использовать классы. Свойство style только если класс не подходит.
Для управления классами существует два DOM-свойства:</span>
className - <span class="menu__komment">строковое значение, заменяет всю строку с классами.</span>
classList - <span class="menu__komment">объект с методами для управления одним классом.</span>

<em>Методы classList</em>:
elem.classList.add/remove("class") - <span class="menu__komment">добавить/удалить класс.</span>
elem.classList.toggle("class") - <span class="menu__komment">добавит класс если его нет, иначе удалит.</span>
elem.classList.contains("class") - <span class="menu__komment">проверка наличия класса, возвращает true/false.

Свойство style это объект со стилями в camelCase:</span>
background-color - elem.style.backgroundColor
z-index - elem.style.zIndex
border-left-width - elem.style.borderLeftWidth
style = "width: 100px" - elem.style.width = "100px"
<span class="menu__komment">
Чтобы удалить elem.style.display нужно присвоить пустую строку:</span>
elem.style.display = "".<span class="menu__komment">
Свойство style.cssText - вся строка стилей атрибута style:</span>
< div id = "div">Button< /div>
<.script>
div.style.cssText = `
color: red !important;
background-color: yellow;
width: 100px;
text-align: center;`
alert(div.style.cssText);
<./script>

<em>getComputedStyle(elem, [psevdo])</em> - <span class="menu__komment">возвращает объект для чтения окончательных стилей 
с учетом всех классов, после применения CSS и вычисления окончательных значений.</span>
elem - <span class="menu__komment">элемент, значения для которого нужно получить.</span>
psevdo - <span class="menu__komment">если нужен псевдоэлемент ::before.
Без аргумента означает сам элемент.</span>
</small>
  </details>
  <details><!--Storage-->
  <summary>Storage</summary><small>
<em>localStorage и sessionStorage</em> - <span class="menu__komment">объекты вэб-хранилища, позволяют хранить пары ключ/значение в браузере.</span>
key и value - <span class="menu__komment">строки
Лимит 2 Mb - зависит от браузера
Данные не имеют срока хранения
Данные привязаны к источнику (домен/протокол/порт)
<em>localStorage</em> - используется между всеми вкладками и окнами одного источника совместно. Переживает перезапуск браузера.
<em>sessionStorage</em> - разделяется в рамках вкладки браузера, среди ифреймов из того же источника.
Переживает перезагрузку страницы, но не закрытие вкладки.</span>

<em>API</em>:
setItem(key, value) - <span class="menu__komment">сохранить пару ключ/значение</span>
getItem(key) - <span class="menu__komment">получить данные по ключу key</span>
removeItem(key) - <span class="menu__komment">удалить значение по ключу key</span>
clear() - <span class="menu__komment">удалить всё</span>
key(index) - <span class="menu__komment">получить ключ по заданной позиции</span>
length - <span class="menu__komment">количество элементов в хранилище</span>
Object.keys - <span class="menu__komment">получить все ключи
Если обращаться к ключам как к обычным свойствам объекта, то событие storage не срабатывает.

<em>Событие storage</em>:
Срабатывает при вызове <b>setItem, removeItem, clear</b>
Содержит все данные о произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea
Срабатывает на всех объектах window, которые имеют доспут к хранилищу, кроме того где оно было сгенерировано 
(внутри вкладкидля sessionStorage, глобально для localStorage)

<em>IndexedDB</em> - <i>встроенная база данных типа ключ-значение, мощнее localStorage.</i>
Интерфейс для IndexedDB основан на событиях IndexedDB имеет встроенный механизм версионирования схемы, 
который отсутствует в серверных базах данных.
IndexedDB работает на стороне клиента (в браузере) и у нас нет прямого доступа к данным.
При публикации новой версии приложения возможно обновлять базу данных.

<em>Использование</em>:
Пoдключить обёртку над промисами (idb)
Открыть базу данных: <b>idb.openDb(name, version, onupgradeneeded)</b>
Создание хранилищ объектов и индексов в обработчике onupgradeneeded
Обновление версии - либо сравнивая номера версий, либо проверить что есть, а что нет.

<em>Для запросов</em>:
Создать транзакцию <b>db.transaction('books')</b> - можно указать readwrite.
Получить хранилище объектов <b>transaction.objectStore('books')</b>.
Для поиска по ключу вызвать метод непосредственно у хранилища объектов.
Для поиска по любому полю объекта нужно создать индекс.
Если данных не помещаются в памяти, то используй курсор.</span>
</small>
  </details>
</details>
<details><!--Code-->
  <summary>Code</summary>
  <a href="../pages/jscode/counter.html" target="_blank">Counter</a>
  <a href="../pages/jscode/hello.html" target="_blank">hello</a>
  <a href="../pages/jscode/form1.html" target="_blank">form1</a>
  <a href="../pages/jscode/colors.html" target="_blank">colors</a>
  <a href="../pages/jscode/colors1.html" target="_blank">colors1</a>
  <a href="../pages/jscode/tasks.html" target="_blank">tasks</a>
  <a href="../pages/jscode/counter1.html" target="_blank">Counter1</a>
  <a href="../pages/jscode/counter2.html" target="_blank">Counter2</a>
  <a href="../pages/jscode/animation.html" target="_blank">Animation</a>
  <a href="../pages/jscode/posts.html" target="_blank">Posts</a>
  <a href="../pages/jscode/rates.html" target="_blank">Rates</a>
  <a href="../pages/jscode/scroll.html" target="_blank">Scroll</a>
  <a href="../pages/jscode/sections.html" target="_blank">Sections</a>
</details>
<details><!--React-->
  <summary>React</summary><small>
    npx create-react-app название папки (проекта)
    <span class="menu__komment">  - создаст папку с названием проекта и стартовым шаблоном внутри.</span>
    <em>JSX</em>:<span class="menu__komment">
      - это синтаксический сахар для React.createElement.
      - это расширение JS, чтобы объяснить React как выглядит UI.
      - напоминает язык шаблонов, наделённый силой JavaScript.
      - производит элементы React.
      - преобразуется в JS функцию, которая возвращает JS объект.
      После компиляции каждое JSX-выражение становится обычным вызовом JS-функции, результат которого  - объект JS.</span>

    < div >< /div > = < div /><span class="menu__komment"> - если тэг пустой, то самозакрывающийся тэг.
      Если разделить выражение на строки, то его нужно обернуть в ().
      Запись атрибутов в camelCase.
      Кавычки (для строковых литералов), фигурные скобки (для JS-выражений), но не то и другое вместе.</span>

    < div tabIndex=”0” >< /div ><span class="menu__komment"> - литералы в строке</span>
    < img src={user.avatarUrl} ><span class="menu__komment"> - JS выражения в { }</span>

    const name = ‘Иван-Царевич’;<span class="menu__komment"> - создали переменную</span>
    const element = < h1 >Здравствуй, {name}!< /h1 >;<span class="menu__komment">
      - создали элемент с переменной внутри.
      Элемент описывает то, что будет на экране.</span>
    ReactDOM.render(    <span class="menu__komment"> - команда ReactDOM-у отрисовать созданный элемент</span>
    element,
    document.getElementById('root'))<span class="menu__komment"> - внутри элемента страницы с выбранным id</span>

    < div /><span class="menu__komment"> - DOM-тэг с маленькой буквы</span>
    < Welcome /><span class="menu__komment"> - компонент с большой.

    Первоначальный рендеринг компонента в DOM называется “монтированием”</span> - (mounting).
    <span class="menu__komment">Каждый раз когда DOM-узел, созданный компанентом, удаляется, происходит “размонтирование”</span> - (unmounting).

    <em>Методы жизненного цикла</em>:
    componentDidMount() {...}<span class="menu__komment"></span> - запускается после того, как компонент отрендерился в DOM</span>
    componentWillUnmount() {...}<span class="menu__komment"> - запускается перед размонтированием

    Поля <em>this.props</em> и <em>this.state</em> в классах особенные, и их устанавливает сам React.
    Присвоить значение this.state можно только в конструкторе,
    в остальных случаях только через изменение:</span> this.state({comment: ‘Привет’}).
    <span class="menu__komment">Родитель-компонент передаёт своё состояние дочерним компонентам в виде пропса.
    Это однонаправленный поток данных.</span>

    <span class="menu__komment"><em>this.props</em> и <em>this.state</em> могут обновляться асинхронно поэтому операции с ними нужно проводить внутри функции,
    получая текущие значения в качестве параметров:</span>
    this.setState((state.props) => ({counter: state.counter + props.increment}))

    <em>Обработка событий</em>:
    <span class="menu__komment">HTML:</span> < button onclick="activateLasers()" > Активировать лазеры < /button >
    <span class="menu__komment">React:</span> < button onClick={activateLasers} > Активировать лазеры < /button >
    <span class="menu__komment">activateLasers - это функция-обработчик события

    В React есть соглашение об именах:</span>
    on[имя события]<span class="menu__komment"> - для пропсов, отвечающих за события,</span>
    handle[имя события]<span class="menu__komment"> - для методов, обрабатывающих события.
    События в React в camelCase.

    Чтобы предотвратить обработчик события по умолчанию, нужно вызвать preventDefault().</span>
    function ActionLink() {
      function handleClick(e) {
        e.preventDefault()
        console.log(‘По ссылке кликнули’)
      }
      return (< a href=”#” onClick={handleClick} > Нажми на меня < /a >)
    }<span class="menu__komment">

    Если ссылаться на метод как на ссылку - без вызова, т.е. без () поcле него, например, onClick={this.handleClick},
    этот метод нужно привязать к контексту:
    в конструкторе</span> this.handleClick = this.handleClick.bind(this);
    <span class="menu__komment">в render()</span> < button onClick={this.handleClick} >
    <span class="menu__komment">или так:</span>
    handleClick = () => {console.log('значение this: ', this)}
    < button onClick={this.handleClick} > Нажми на меня < /button >
    <span class="menu__komment">или так:</span>
    handleClick() {console.log('значение this: ', this)}
    < button onClick={this.handleClick()} > Нажми на меня < /button >

    <span class="menu__komment">Чтобы передать свой аргумент (например id строки) в обработчик события:</span>
    е<span class="menu__komment"> - событие React передаётся явно в стрелочных функциях и автоматически в bind.</span>
    <.button onClick={this.deleteRow.bind(this, id)} > Удалить строку < /button > - Function.prototype.bind
    < button onClick={(e) => this.deleteRow(id, e)}>Удалить строку< /button><span class="menu__komment">
    - стрелочная функция - при каждом рендере создаётся новый коллбэк.
    Если этот коллбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова.
    Снижение производительности.</span>

    <em>Структура проекта</em>:
    index.html<span class="menu__komment"> - точка входа в сайт</span>
    index.js<span class="menu__komment"> - подключает необходимое окружение (react, react-dom, index.css, App.js, serviceWorker.js)</span>
    index.css<span class="menu__komment"> - задаёт стили</span>
    serviceWorker.js<span class="menu__komment"></span>
    setupTests.js<span class="menu__komment"></span>
    context.js<span class="menu__komment"></span>
    App.js<span class="menu__komment"> - подключает (объединяет) все компоненты
    Файл .css можно не импортировать, т.к. React ищет его сам в своей папке, либо в папках выше.</span>

    <em>Компонент</em>:<span class="menu__komment">
    Это функция или класс (работают одинаково).
    Один компонент - одна ответственность.
    Компонент содержит логику и разметку в JSX.
    Компоненты можно вкладывать в друг друга.

    Чтобы создать компонент нужно в файле с расширением js написать:</span>
    import React from 'react';<span class="menu__komment"> - в начале
    и</span>
    export default App;<span class="menu__komment"> - в конце.

    Сначала создаём самый маленький компонент, потом вверх по иерархии.</span>

    <em>Компонент в виде класса</em>:
    class Example extends React.Component {
      constractor (props) {<span class="menu__komment"> - конструктор объектов</span>
      super (props)<span class="menu__komment"> - обязательная ссылка на родителя</span>
      this.state = { … }<span class="menu__komment"> - задаём начальное состояние</span>
    }
      render() {<span class="menu__komment"> - говорит React что нужно отобразиь на экране</span>
        return…<span class="menu__komment"> - возвращает JSX объект</span>
      }
    }

    <span class="menu__komment">В JS - классах всегда нужно вызывать <em>super</em> при объявлении конструктора подкласса.
    Все классовые React - компоненты, у которых есть constractor 
    должны начинаться с вызова super (props).</span>

    <em>Компонент в виде функции (функциональный компонент)</em>:
    import React from 'react';<span class="menu__komment"> - подключение</span>
    …
    const styles = { }

    function Example (props) {<span class="menu__komment"> - принимает пропсы
      либо так:</span>
      const Example = (props) => {{<span class="menu__komment">
        логика на JS
        разметка JSX</span>
        return …<span class="menu__komment"></span>    - возвращает JSX объект</span>
        
      }
      export default Example
    }

    class Clock extends React.Component {<span class="menu__komment"> - компонент объявлен как класс</span>
      constructor (props) {
        super (props);
        this.state = {date: new Date()};<span class="menu__komment"> - задаём начальное состояние при создании объекта</span>
      }

      componentDidMount() {<span class="menu__komment">
        метод жизненного цикла, который React вызывает когда коипонент < Clock /> примонтируется в DOM</span>
        this.timerID = setInterval (<span class="menu__komment"> - вызываем метод tick() каждую секунду</span>
        () => this.tick(), 1000
        );
      }

      componentWillUnmount() {<span class="menu__komment">
        метод жизненного цикла, который Ract вызывает когда компонент < Clock /> удалится из DOM</span>
      }

      tick() {
        this.setState({<span class="menu__komment">
          обновляем состояние компонента, присваивая новое значение свойства date</span>
          date: new Date()
        });
      }

      render() {
        return (
          < div >
            < h1 > Привет мир! < /h1 >
            < h2 > Сейчас {this.state.date.toLocaleTimeString()} < /h2 >
          < /div >
        );
      }
    }

    ReactDOM.render(
      < Clock />,
      document.getElementById('root')
    );

    <em>Пропс</em>:
    JSON<span class="menu__komment"> - объявляем объект в переменную:</span>
    const user = {
      firstName = ‘Марья’,
      lastName = ‘Маревна’
    }<span class="menu__komment">
    и обращаемся к пропсам:</span>
    user.firstName
    user.lastName

    <em>this.props</em><span class="menu__komment"> - объект, кототрый содержит свойства, которые были определены тем, кто вызывает этот компонент.
    Вложенный контент может быть доступен через</span> props.children

    function Square (props) {<span class="menu__komment"> - в props получаем значения value и onClick из класса Board ниже</span>
    return(< button className=”square” onClick={props.onClick} > {props.value} < /button >)}
    <span class="menu__komment"> - возвращаем кнопку для подстановки в качестве объекта this в блок render в классе Board</span>
                                                                                                 
    class Board extends React.Component{
      renderSquare(i){<span class="menu__komment"> - props i из блока render() ниже</span>
        return(<span class="menu__komment"> - в компанент Square втуливаем значения value и onClick</span>
          < Square
            value = {this.props.square[i]}<span class="menu__komment"> - собираем получаемые пропсы в массив</span>
            onClick = {() = this.props.onClick(i)}<span class="menu__komment"> - создаём обработчик на событие onClick для каждого пропса i</span>
          />
        )
      }
      render() {
        return(
          < div className=”board-row”><span class="menu__komment"> - передаем в функцию renderSquaer (props.value) - 0 или 1 или 2</span>
            {this.renderSquare(0)}<span class="menu__komment"> - первому объекту this передаём value = 0</span>
            {this.renderSquare(1)}<span class="menu__komment"> - второму объекту this передаём value = 1</span>
            {this.renderSquare(2)}<span class="menu__komment"> - третьему объекту this передаём value = 2</span>
          < /div >
        )
      }
    }

    function Welcome(props) {<span class="menu__komment"> - компонент объявлен как функция</span>
      return < h1 >Привет, {props.name}!< /h1 >;
    }<span class="menu__komment">
    или так:</span>
    class Welcome extends React.Component {<span class="menu__komment"> - компонент объявлен как класс</span>
      render () {
        return < h1 >Привет, {this.props.name}!< /h1 >;
      }
    }

    const element = < Welcome name="Алиса" />;
    ReactDOM.render(
      element,
      document.getElementById('root')
    );<span class="menu__komment">
    name=”Алиса” - передаётся в функцию Welcome в виде объекта {name: 'Алиса'} - это props.
    Функция Welcome возвращает элемент</span> < h1 >Привет, Алиса!< /h1 ><span class="menu__komment"> в ReactDOM.
    
    Пропсы нужно только читать.
    React-компоненты не меняют свои входные данные.
    Компонент никогда не должен что-то записывать в свои пропсы:</span>
    function sum(a, b) {
      return a + b;
    }<span class="menu__komment">
    а вот так нельзя:</span>
    function withdraw(account, amount) {
      account.total -= amount;
    }
    <span class="menu__komment">
    Передать пропс можно от родителя к потомку пропустив несколько промежуточных потомков
    напрямую с помощью</span> React.createContext().<span class="menu__komment">
    Для этого создаём отдельный файл context.js и используем</span> < Context.Provider >.

    <em>Файл context.js</em>:
    import React from 'react'
    const Context = React.createContext()
    export default Context

    < Context.Provider vakue={{ … }} ><span class="menu__komment"> - с помощью Context.Provider передаю любое JS сквозь всех потомков</span>
    < div className=”...” >
    < h1 > Hello world! < /h1 >
    < Example />
    < /div >
    < /Context.Provider >

    <em>Состояние</em>:<span class="menu__komment">
    Сохранять и изменять можно только состояния <em>(state)</em>.
    Конкретный state контролируется и доступен только конкретному компоненту.
    Состояние содержит данные, специфичные для этого компонента. Они могут изменятся со временем.
    Состояние определяется пользователем и должно быть простым объектом JS.
    Состояние можно изменять только через setState(), присвоить состоянию значение напрямую можно только в конструкторе.
    Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов.
    Этот процесс называется “нисходящим” (“top-down”) или “однонаправленным” (“unidirectional”) потоком данных.

    Если несколько компонентов должны отражать одни и теже изменяющиеся данные, 
    то нужно поднимать общее состояние до ближайшего общего предка.
    Чтобы собрать данные из нескольких дочерних элементов, или чтобы дать возможность двум компонентам общаться,
    вам нужно объявить общее состояние внутри родительского компонента. 
    Родительский компонент может передать состояние обратно дочерним элементам с помощью пропсов.
    Это поддерживает синхронизацию дочерних компонентов друг с другом и с родительким компонентом.</span>

    <em>Хуки</em>:
    const [todos, setTodos] = React.useState([ ])<span class="menu__komment">
    Это функции, с которыми можно “подцепиться” к состоянию
    и к методам жизненного цикла React из функциональных компонентов.
    Хуки не работают в классах, а используются вместо них.
    Хуки вызывают только на верхнем уровне (не в циклах, условиях и т.д.)
    Хуки вызывают только из функциональных компонентов React, не из обычных JS-функций.
    Если имя функции начинается с use (useSamething) и использует другие хуки,
    то такая функция это пользовательский хук.</span>

    <em>useState(i)</em><span class="menu__komment"> - возвращает массив из двух элементов:
      состояние (это state - состояние) и функцию, которая изменяет это состояние.
      Имена даём возвращаемому состоянию и функции произвольно.</span>

    <em>useEffect(i)</em><span class="menu__komment"> - React запускает эффекты</span> useEffect(() => {...})<span class="menu__komment"> после каждого рендера, включая первый рендер.</span>

    useEffect(() => {
    fetch('http://…')
      .then(responce=>responce.json())
      .then(todos=>{
        setTodos(todos)
      })
    }, [])
    <span class="menu__komment">
    вызвать хук можно либо</span>
    import React, { useEffect } from 'react'
    useEffect(i) {...}<span class="menu__komment">
    либо</span>
    React.useEffect(i) {...}

    <span class="menu__komment">Сравнение хука и класса</span>:
    <em>Хук</em>:
    import React, {useState} from 'react'<span class="menu__komment"> - подключение хука</span>
    function Example() {
      const [count, setCount] = useState(0)<span class="menu__komment"> - 0 это начальное состояние, это может быть не объект.</span>
      return (
        < div >
          < p >Вы нажали {count} раз < /p >
          <.button onClick={() => setCount(count + 1)} > Нажми на меня < /button >
        < /div >
      )
    }

    <em>Класс</em>:
    class Example extends React.Component {
      constractor (props) {
        super (props)
        this.state = {
          count: 0
        }
      }
      render () {
        return (
          < div >
            < p >Вы нажали {this.state.count} раз < /p >
            <.button onClick={() => this.setState({
              count.this.state.count + 1})}>
                Нажми на меня
            < /button >
          < /div >
        )
      }
    }<span class="menu__komment">
    Чтобы наделить функциональный компонент состоянием нужно либо преобразовать его в класс, либо добавить в него хук.
    React запоминает значение переменной состояния между вызовами функции.</span>
    <em>Итого</em>:
    import React, {useState} from 'react'<span class="menu__komment"> - подключаем хук</span>
    const [count, setCount] = useState(0)<span class="menu__komment"> - добавляем переменную в функцию</span>
    <.button onClick={() => setCount(count + 1)}><span class="menu__komment"> - вызываем функцию изменения

    <em>Хук еффекта выполняет побочные действия</em>:
     - загрузка данных
     - оформление подписки и изменение DOM вручную
     - представляет собой совокупность методов</span> componentDidMount, componentDidUpdate и componentWillUnmount.
    <span class="menu__komment">
    Эффекты позволяют выполнить дополнительный код после того, как React обновил DOM, т.е. после каждого рендера.
    Любой эффект может возвратить функцию, которая сбросит его.
    React будет сбрасывать эффект перед тем, как компонент размонтируется. Например оформление и отмена подписки:</span>
    import React , {useState, useEffect} from 'react'
    function FriendStatus(props) {
      const [isOnline, setIsOnline] = useState(null)
      useEffect(() => {
        function handleStatusChange(status) {
          setIsOnline(status.isOnline)
        }
        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)
        return function cleanup() {<span class="menu__komment"> - сброс эффекта</span>
          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)
        }
      })
      if (isOnline === null) {
        return ‘Загрузка…’
      }
      return isOnline ? ‘В сети’ : ‘Не в сети’
    }<span class="menu__komment">
    Чтобы React выполнял эффект только в случае изменения нужен второй аргумент в виде массива,
    с которым будет сравниваться значение первого аргумента.
    При каждом рендере react сравнивает новое значение переменной в первом аргументе со старым значением переменной,
    указанным во втором аргументе (в массиве).</span>
    useEffect(() => {
      function handleStatusChange(status) {
        setIsOnline(status.isOnline)
      }
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)
      return() => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)
      }
    }<span class="menu__komment"> - стрелочная функция это первый аргумент эффекта</span>
    [props.friend.id])<span class="menu__komment"> - это второй аргумент эффекта со старым значением переменной,
    по которому будет сравнение первого аргумента: повторно подписаться только если props.friend.id изменился.</span>

    <em>Обычный эффект без сброса</em>:
    import React, {useState, useEffect} from 'react'
    function Example() {
      const [count, setCount] = useState(0)
      useEffect(() => {
        document.title = `Вы нажали ${count} раз`
      }, [count])<span class="menu__komment"> - перезапускать эффект только если count поменялся</span>
      return (
        < div >
          < p >Вы нажали {count} раз< /p >
          <.button onClick={() => setCount(count + 1)} > Нажми на меня < /button >
        < /div >
      )
    }<span class="menu__komment">
    Для корректной работы с хуками нужно установить плагин для ESLint:</span>
    npm i eslint-plugin-react-hooks --save -dev

    useContext:
    import React, {useContext} from 'react'
    const themes = {
      light: {
        foreground: “#000000”,
        background: “#eeeeee”
      }
      dark: {
        foreground: “#ffffff”,
        background: “#222222”
      }
    }
    <span class="menu__komment"> - создаём объект контекста со свойством light</span>
    const ThemeContext = React.createContext(themes.light)
    function App() {
      return(
        < Theme	Context.Provider value={themes.dark} ><span class="menu__komment"> - значение value определяет текущее значение</span>
        < Toolbar /><span class="menu__komment"> передаваемого в Toolbar контекста. При обновлении значения - новый рендер.</span>
        < /ThemeContext.Provider ><span class="menu__komment">Меняем контекст на тёмную тему.</span>				
      )								
    }
    function Toolbar (props) {<span class="menu__komment"> - передаём контекст потомку</span>
      return(
        < div >
          < ThemedButton />
        < /div >
      )
    }
    function ThemedButton() {
      const theme = useContext(ThemeContext)<span class="menu__komment"> - используем контекст с тёмной темой</span>
      return (
        <.button style={{background: theme.background, color: theme.foreground}} > Я стилизован темой из контекста! < /button >
      )
    }

    <em>Управляемый компонент</em>:<span class="menu__komment">
    Если форму обрбатывать с помощью JS-функции, у которой есть доступ к введённым данным,
    то такая форма называется “управляемым компонентом”.
    Библиотека Formik.
    Или, другими словами, <em>управляемый компонент</em> - это элемент формы рендер,
    поведение при пользовательском вводе и значение которого контролирует React.</span>
    class NameForm extends React.Component{
      constructor(props){
        super(props)
        this.state={value:' '}
        this.handleChange=this.handleChange.bind(this)
        this.handleSubmit=this.handleSubmit.bind(this)
      }
      handleChange(event) {
        this.setState({value: event.target.value})
      }
      handleSubmit(event){
        alert('Отправленное имя: ' + this.state.value)
        event.preventDefault()<span class="menu__komment"> - отменяем действе по умолчанию</span>
      }
      render() {
        return (
          < form onSubmit={this.handleSubmit} >
            < label >
              Имя:
              < input type=”text” value={this.state.value} onChange={this.handleChange} />
            < /label >
            < input type=”Submit” value=”Отправить” />
          < /form >
        )
      }
    }<span class="menu__komment">
    в атрибуте value всегда будет отражаться React состояние</span> this.state.value<span class="menu__komment">,
    а каждое нажатие клавиш через handleChange будет это состояние изменять и React будет обновлять поле ввода по мере печатанья.</span>
    < textarea > также как < input />
    < textarea value={this.state.value} onChange={this.handleChange}><span class="menu__komment">
    Чтобы использовать несколько тегов input нужно каждому дать свой атрибут name.</span>
    < select >
      < option value=”grapefruit”>Грейпфрут< /option>
      < option value=”lime”>Лайм< /option>
      < option selected value=”coconut”>Кокос< /option>
      < option value=”mango”>Манго< /option>
    < /select><span class="menu__komment">
    если в value передать массив, то можно выбрать несколько опций:</span>
    < select multiple={true} value={[‘Б’, ‘В’]} ><span class="menu__komment">
    в React выбранный элемент присваивается в конструкторе по умолчанию:</span> this.state={value='cocnut'}<span class="menu__komment">,
    а потом изменяется через setState:</span> < select value={this.state.value} onChange={this.handleChange} > < /select ><span class="menu__komment">
    Если установить значение value, то пользователь изменить его не сможет:</span>
    ReactDOM.render(< input value=”Привет” />)<span class="menu__komment">
    Для любых изменяемых данных в React -приложении должен быть один “источник истины” (state).
    Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера.
    Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка.
    Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами,
    вы должны полагаться на однонаправленный поток данных
     - это водопад пропсов от родителя к потомку,
    в который каждый компонент добавляет свой state в виде пропса (props).</span>

    <em>Композиция</em>:<span class="menu__komment">
    Вместо наследования:</span>
    function FancyBorder(props) {
      return (
        <span class="menu__komment"> - поместить в div всё, что выделено тэгом < FancyBorder ></span>
        < div className={'FancyBorder FancyBorder-' + props.color}> {props.children} < /div >
      )
    }
    function Dialog(props) {
      return (
        <span class="menu__komment"> - определяю тэг < FancyBorder > и его содержимое для подстановки</span>
        < FancyBorder color="blue" >
          < h1 className="Dialog-title" > {props.title} < /h1 >
          < p className="Dialog-message" > {props.message} < /p >
        < /FancyBorder >
      )
    }
    function WelcomDialog() {
      return (
        <span class="menu__komment"> - определяю компонент для рендера и задаю значение пропсов</span>
        < Dialog
          title="Welcom"
          message="Thank you for visiting our spacecraft!"
        />
      )
    }
    ReactDOM.render(
      < WelcomDialog />,
      document.getElementById('root')
    )

    <em>Ключи</em>:<span class="menu__komment">
    Ключи помогают React определить, какие элементы были изменены, добавлены или удалены.</span>
    const todoItems = todos.map((todo) => 
      < li key={todo.id} >
        {todo.text}
      < /li>
    )
    function NumberList(props) {
      const numbers = props.numbers
      const listItems = numbers.map((number) =><span class="menu__komment"> - функция map() преобразует массив numbers в список</span>
        < ListItem
          key={number.toString()}<span class="menu__komment"> - ключ нужно определить внутри массива, ключ это строка</span>
          value={number}
        />
      )
      return (
        < ul >
          {listItems}
        < /ul >
      )
    }<span class="menu__komment">
    или так:</span>
    function NumberList(props) {
      const numbers = props.numbers
      return (
        < ul >
          {numbers.map((number) => 
            < ListItem
              key={number.toString()}
              value={number}
            />
          )}
        < /ul >
      )
    }

    <em>Валидирование типов</em>:<span class="menu__komment">
    Библиотека prop-types нужна для задания типов переменных:</span> npm i prop-types.

    import PropTypes from 'prop-types'

    function Example ({prop1, prop2, prop3}) {...}
    Example.propTypes={
      prop1: PropTypes.object.isRequired,
      prop2: PropTypes.number,
      prop3: PropTypes.func.isRequired,
    }
    export default Example

    <em>Условный рендеринг</em>:
    if (isLoggedIn) {
      return < UserGreeting />;
    }
    return < GuestGreeting />;

    {unreadMessages.length > 0 && < h2 > у вас {unreadMessages.length} непрочитанных сообщений. < /h2 >}
    Пользователь < b >{isLoggedIn ? 'сейчас' : 'не'}< /b > на сайте.
  </small>
<img src="../img/react/react.png" alt="">
<img src="../img/react/react0.png" alt="">
<img src="../img/react/React1.png" alt="">
<img src="../img/react/React2.png" alt="">
<img src="../img/react/React3.png" alt="">
<img src="../img/react/React4.png" alt="">
<img src="../img/react/React5.png" alt="">
<img src="../img/react/React6.png" alt="">
<img src="../img/react/React7.png" alt="">
<img src="../img/react/React8.png" alt="">
<img src="../img/react/React9.png" alt="">
<img src="../img/react/React10.png" alt="">
<img src="../img/react/React11.png" alt="">
<img src="../img/react/React12.png" alt="">
<img src="../img/react/React13.png" alt="">
<img src="../img/react/React14.png" alt="">
<img src="../img/react/React15.png" alt="">
<img src="../img/react/React16.png" alt="">
<img src="../img/react/React17.png" alt="">
<img src="../img/react/React18.png" alt="">
<img src="../img/react/React19.png" alt="">
<img src="../img/react/React20.png" alt="">
<img src="../img/react/React21.png" alt="">
<img src="../img/react/React22.png" alt="">
<img src="../img/react/React23.png" alt="">
<img src="../img/react/React24.png" alt="">
<img src="../img/react/React25.png" alt="">
<img src="../img/react/React26.png" alt="">
<img src="../img/react/React27.png" alt="">
<img src="../img/react/React28.png" alt="">
<img src="../img/react/React29.png" alt="">
<img src="../img/react/React30.png" alt="">
<img src="../img/react/React31.png" alt="">
<img src="../img/react/React32.png" alt="">
<img src="../img/react/React33.png" alt="">
<img src="../img/react/React34.png" alt="">

  <details><!--Redux-->
    <summary>Redux</summary><small><span class="menu__komment">
Весь базовый функционал redux умещается в малюсенький файлик</span>
function createStore(reducer, initialState) {
  let state = initialState
  return {
    dispatch: action => { state = reducer(state, action) },
    getState: () => state
  }
}

<em>createStore</em><span class="menu__komment"> - возвращает объект с полем “dispatch”.</span>
<em>dispatch</em><span class="menu__komment"> - это функция, которая всего лишь применяет редюсер к нашему текущему состоянию</span>
(newState = reducer(state, action)).
<span class="menu__komment">
С этими 7 строками уже можно писать TodoApp.
Инициализация хранилища:</span>
function todosReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          id: action.id,
          text: action.text,
          completed: false
        }
      ]
    case 'TOGGLE_TODO':
      return state.map(todo => {
        if (todo.id === action.id) {
          return { ...todo, completed: !todo.completed }
        }
        return todo
      })
      default: return state
  }
}

const initialTodos = []

const store = createStore(todoReducer, initialTodos)
<span class="menu__komment">
Использование:</span>
store.dispatch({
  type: 'ADD_TODO',
  id: 1,
  text: 'Понять на сколько redux прост'
})

store.getState()<span class="menu__komment"> - [{ id: 1, text: ‘Понять насколько redux прост’, completed: false }]</span>
store.dispatch({
  type: 'TOGGLE_TODO',
  id: 1
})

store.getState()<span class="menu__komment"> - [{ id: 1, text: ‘Понять насколько redux прост’, completed: true }]
Метод combineReducers позволяет вместо того, чтобы создавать один огромный reducer для всего состояния приложения сразу,
разбивать его на отдельные модули.</span>

function counterReducer(state, action) {
  if (action.type === 'ADD') {
    return state + 1
  } else {
    return state
  }
}

const reducer = combineReducers({
  todoState: todoReducer, 
  counterState: counterReducer
})

const initialState = {
  todoState: [],
  counterState: 0,
}

const store = createStore(reducer, initialState)
<span class="menu__komment">
Усли упростить, то:</span>
function reducer(state, action) {
  return {
    todoState: todoReducer(state, action),
    counterState: counterReducer(state, action),
  }
}
<span class="menu__komment">
Но этот код плохо масштабируется.
Если у нас 2 “под-состояния”, нам нужно дважды написать</span> (state, action)<span class="menu__komment">,
а хорошие программисты так не делают.

Если редюсоров и стэйтов много, то через обработку коллекции редюсеров:</span>
function combineReducers(reducersMap) {
  return function combinationReducer(state, action) {
    const nextState = {}
    Object.entries(reducersMap).forEach(([key, reducer]) => {
      nextState[key] =  reducer(state[key], action)
    })
    return nextState
  }
}

<em>middleware в разрезе redux</em><span class="menu__komment"> - это какая-то штука, 
которая слушает все dispatch и при определенных условиях делает что-то.</span>
const createStoreWithMiddleware = applyMiddleware(someMiddleware)(createStore)
const store = createStoreWithMiddleware(reducer, initialState)
<em>applyMiddleware</em><span class="menu__komment"> переопределяет метод dispatch,
добавляя перед (или после) обновлением состояния какую-то пользовательскую логику.
самый популярный middleware от создателей redux - <em>redux-thunk</em>, чаще всего используют при асинхронных операциях.
Его смысл сводится к тому, что можно передавать в store.dispatch сложные функции</span>
const thunk = store => dispatch => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState)
  }
  return dispatch(action)
}<span class="menu__komment">
метод createStore принимал атрибуты (reducer, initialState) и возвращал объект с ключами { dispatch, getSate }.
метод applyMiddleware берёт уже реализованный метод createStore и переопределяет его возвращаемое значение:</span>

function applyMiddleware(middleware) {
  return function createStoreWithMiddleware(createStore) {
    return (reducer, state) => {
      const store = createStore(reducer, state)
      return {
        dispatch: action => middleware(store)(store.dispatch)(action),
        getState: store.getState,
      }
    }
  }
}

<em>form</em>:
import { useDispatch } from 'react-redux'
import { createPost } from 'actions/posts'

const [postData, setPostData] = useState({ creator: ' ', title: ' ', message: ' '})
const dispatch = useDispatch()

const handleSubmit = (e) => {
  e.preventDefault()
  dispatch(createPost(postData))
}

<em>action</em>:
export const createPost = (post) => async (dispatch) => {
try {
  const { data } = await api.createPost(post)
  dispatch ({ type: 'CREATE', payload: data })
  } catch (error) {
    console.log(error)
  }
}

<em>api</em>:
export const createPost = (newPost) => axios.post(url, newPost)

<em>server/controllers</em>:
export const createPost = async (req, res) => {
  const post = req.body;
  const newPostMessage = new PostMessage({   …post, creator: req.userId, createdAt: new Date().toISOString() })

  try {
    await newPostMessage.save();
    res.status(201).json(newPostMessage);
  } catch (error) {
    res.status(409).json({ message: error.message });
  }
}

<em>server/models</em>:
import mongoose from 'mongoose'

const postSchema = mongoose.Schema({
  title: String,
  message: String,
  name: String,
  creator: String,
  tags: [String],
  selectedFile: String,
  likes: { type: [String], default: [] },
  createdAt: {
    type: Date,
    default: new Date(),
  },
})

export default mongoose.model('PostMessage', postSchema);

<em>reducers</em>:
export default (post = [ ], action) => {
  switch (action.type) {
    case 'FATCH_ALL':
      return action.payload;
    case 'CREATE':
      return [ …posts, action.payload ];
    default: return posts;
  }
}</small>
  <img src="../img/react/redux.jpg" alt="">
  </details>
</details>
</pre>
            </div>
          </details>
        </nav>
      </div>
    </div>
  </div>
</body>
</html>