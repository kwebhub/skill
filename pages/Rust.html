<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <meta name="robots" content="none">
  <meta name="robots" content="noimageindex, nofollow">
  <title>Rust</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <div class="wrapper">
    <div class="main__container">
      <div class="logo"><a href="../">MAY THE FORCE BE WITH YOU</a></div>
      <div class="menu__inner">
      <p><em>Rust</em> — мультипарадигменный компилируемый язык программирования общего назначения, 
        сочетающий парадигмы функционального и процедурного программирования с объектной системой, основанной на типажах.
    </p>
<pre>
    <details><!--Introduction-->
        <summary>Introduction</summary>
<div class="menu__komment"><em>Cargo</em> - <i>система сборки и менеджер пакетов.</i>
<small>cargo new name_folder</small> - создать проект name_folder
<small>cargo build</small> - создать исполняемій файл
<small>cargo run</small> - пересобирает исполняемый файл и запускает его
<small>cargo check</small> - проверяет, что код компелируется, но не создаёт исполняемый файл
<small>cargo build -- release</small> - создаёт исполнфемый файл с оптимизаией, собирает финальную версию.

<em>Упорядочивание кода</em>:
- группировка связанных функций
- разделение кода по основным функциональностям (фичам, feature).

<em>Модульная система</em>:
- <small>Пакеты</small>: функционал Cargo позволяющий собирать, тестировать и делиться крейтами.
- <small>Крейты</small>: дерево модулей, которое создаёт библиотечный или исполняемый файл.
- <small>Модули и use</small>: позволяют вместе контролировать организацию, область видимости и скрытие путей.
- <small>Пути</small>: способ именования элемента, такого как структура, функция или модуль.

<em>Крейт</em> - <i>это наименьший объём кода, который компилятор Rust рассматривает за раз.</i>
<em>Бинарный крейт</em> - <i>обязательно содержит функцию main.</i> Программа, которую можно скомпелировать в
исполняемый файл.
<em>Библиотечный крейт</em> - <i>не имеет функции main и не компелируется в исполняемый файл.</i> Определяет
функциональность для совместного использования другими проектами.

Корневой модуль крейта - исходный файл.
Пакет - набор из одного или нескольких крейтов, представляющий набор функциональности.
Пакет содержит файл Cargo.toml, в котором описывается как собирать эти крейты.
Пакет может содержать любое количество бинарных крейтов, но не более одного библиотечного крейта.
Пакет должен содержать хотябы один крейт, библиотечный или бинарный.

По умолчанию:
<small>src/main.rs</small> - это корневой модуль бинарного крейта
<small>src/lib.rs</small> - это корневой модуль библиотечного крейта
Cargo передаёт файлы корневого модуля крейта в rustc для сборки этого крейта.
Пакет может иметь несколько бинарных крейтов, помещая их файлы в каталог src/bin: каждый файл будет
отдельным бинарным крейтом, с тем же именем, что и пакет.
<i>Несколько бинарных крейтов помещаются в src/bin.</i>
Пакет включает в себя минимум один бинарный крейт, может содержать несколько бинарных и максимум один
библиотечный крейты.
Совокупность пакетов образуют рабочее пространство (workspace)

<em>Правила</em>:
- При компеляции компилятор сначала ищет корневой модуль крейта (src/lib.rs или src/main.rs)
- В файле корневого модуля крейта можно объявить новые модули; при объявлении mod garden
компилятор будет искать код модуля в местах:
- в этом же файле, между фигурных скобок, которые заменяют точку с запятой после mod garden
- в файле src/garden.rs
- в файле src/garden/mod.rs
- Если объявить модуль в файле, например объявить mod vegetables в src/garden.rs, то компилятор будет
искать код модуля в каталоге родительского модуля:
- в файле где объявили (garden.rs) сразу после mod vegetables, между фигурных скобок, которые
заменяют точку с запятой.
- в файле src/garden/vegetables.rs
- в файле src/garden/vegetables/mod.rs
- Обратиться к коду (к типу) можно используя путь: crate::garden::vegetables::Asparagus. Asparagus - это тип,
код которого в модуле vegetables.
- Чтобы сделать модуль общедоступным нужно добавить pub впереди объявления: pub mod.
Чтобы сделать элемент общедоступного модуля общедоступным нужно добавить pub перед его
объявлением.
- Ключевое слово use создаёт псевдоним для элемента для уменьшения длинных путей:
после use crate::garden::vegetables::Asparagus можно просто писать Asparagus.

Пример:
<small>
  src/main.rs
  use crate::garden::vegetables::Asparagus;
  pub mod garden;
  
  fn main () {
    let plant = Asparagus {};
    println! (“I’m growing {:?}!”, plant);
  }
  
  src/garden.rs
  pub mod vegetables;
  src/garden/vegetables.rs
  #[derive(Debug)]
  pub struct Asparagus {}
</small>
Код внутри модуля по умолчанию закрытый.
Создать библиотечный крейт restaurant:
<small>cargo new restaurant --lib;</small>
Получаем src/lib.rs.

Модуль размещается внутри фигурных скобок.
Модуль может находиться внутри другого модуля или в отдельном файле.
Файли src/main.rs и src/lib.rs называются корневыми модулями крейта. Содержимое любого из этих файлов
образует модуль с именем crate в корне структуры модулей дерево модулей.

Crate   - родитель всего дерева (parent)
-A      - A и B потомки crate (child)
-B      - A и B братья (siblings)

Чтобы найти элемент в дереве модулей используем путь:
<em>- абсолютный путь</em> - это полный путь, начинающийся от корневого модуля крейта;
для кода из внешнего крейта абсолютный путьначинается с имени крейта, а для кода из текущего крейта
он начинается с литерала crate.
<em>- относительный путь</em> - начинается с текущего модуля и использует ключевые слова self, super или
идентификатор в текущем модуле.
Абсолютные и относительные пути состоят из одного или нескольких идентификаторов, разделённых двойными
двоеточиями(::).

Чтобы сделать функцию или структуру приватой нужно поместить её в модуль.
Дочерние модули оборачивают и скрывают детали своей реализации, но могут видеть контекст родителей, в
котором они определены.

Дерево модулей должно быть определено в src/lib.rs, тогда любые общедоступные элементы можно
использовать в бинарном крейте, начав пути с имени пакета.
С помощью ключевого слова super можно построить относительные пути, которые начинаются в родительском
модуле.

Rust не позволяет подключать оператором use два элемента с одинаковыми именами из разных родительских
модулей.
Идиоматические пути с use
<small>
  use std::fmt;
  use std::io;
  fn function1 () -> fmt::Result {
    //--snip--
  }
  
  fn function2 () -> io::Result {
    //--snip--
  }
</small>

С использованием ключевого слова as:
<small>
  use std::fmt::Result;
  use std::io::Result as IoResult;
  fn function1 () -> Result {
    //--snip--
  }
  
  fn function2 () -> IoResult <()> {
    //--snip--
  }
</small>

<em>Реэкспорт pub use</em> - подключаем элемент в область видимости и делаем этот элемент доступным для
подключения в других областях видимости.
Добавить внешний пакет rand:
в файл Cargo.toml написать rand = “0.8.3”
Код:
<small>
  use rand::Rng;
  fn main () {
    let secret_number = rand::thread_rng().gen_range(1..=100);
  }
</small>

Чтобы указать несколько элементов, определённых в одном крейте или в том же модуле используем вложенные
пути:

<small>use std::cmp::Ordering;</small>
или
<small>
  use std::{cmp::Ordering, io};
  use std::io;
</small>

<small>
  use::io;
  use::io::Write;
</small>
или
<small>use std::io::{self, Write};</small>

Лучше всего разделить функциональность, чтобы каждая функция отвечала за одну задачу. 
<i>main.rs занимается запуском программы, а lib.rs обрабатывает всю логику задачи.</i>
Разделите код программы на два файла main.rs и lib.rs. Перенесите всю логику работы программы в
файл lib.rs.
Пока ваша логика синтаксического анализа командной строки мала, она может оставаться в файле
main.rs.
Когда логика синтаксического анализа командной строки становится сложной, извлеките её из main.rs и
переместите в lib.rs.
Функциональные обязанности, которые остаются в функции main после этого процесса должно быть
ограничено следующим:
Вызов логики разбора командной строки со значениями аргументов
Настройка любой другой конфигурации
Вызов функции run в lib.rs
Обработка ошибки, если run возвращает ошибку мы запустим программу с помощью > и именем файла
output.txt в который мы хотим перенаправить стандартный поток вывода.
<small>$ cargo run > output.txt</small>
Синтаксис > указывает оболочке записывать содержимое стандартного вывода в output.txt вместо
экрана.
Программирование в функциональном стиле зачастую предполагает использование функций в
качестве значений, которые передаются в качестве аргументов, возвращаются из других функций,
присваиваются переменным для последующего выполнения и так далее.

<i>Cargo имеет два основных профиля:</i> профиль dev, используемый Cargo при запуске cargo build, и
профиль release, используемый Cargo при запуске cargo build --release.
Добавляя секции [profile.*] для любого профиля, который вы хотите настроить, вы переопределяете
любое подмножество параметров по умолчанию.
В Rust также есть особый вид комментариев к документации, который обычно называется
комментарием к документации, который генерирует документацию HTML.

<em>Комментарии к документации</em> используют три слеша, /// вместо двух и поддерживают нотацию
Markdown для форматирования текста. Размещайте комментарии к документации непосредственно
перед элементом, который они документируют.
<i>
  Мы можем сгенерировать документацию HTML из этого комментария к документации, запустив cargo
  doc.
</i>
авторы библиотек обычно используют в своей документации:
<small>Panics</small>: Сценарии, в которых документированная функция может вызывать панику. Вызывающие
функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают
функцию в этих ситуациях.

<small>Ошибки</small>: Если функция возвращает Result, описание типов ошибок, которые могут произойти и какие
условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для
вызывающих, так что они могут написать код для обработки различных типов ошибок разными
способами.

<small>Безопасность</small>: Если функция является unsafe для вызова (мы обсуждаем безопасность в главе 19),
должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты,
которые функция ожидает от вызывающих сторон.
Добавление примеров кода в комментарии к документации может помочь продемонстрировать, как
использовать вашу библиотеку, и это даёт дополнительный бонус: запуск cargo test запустит примеры
кода в вашей документации как тесты!

Стиль комментариев к документам //! добавляет документацию к элементу, содержащему комментарии,
а не к элементам, следующим за комментариями.

По мере развития вашего проекта может возникнуть ситуация, когда библиотечный крейт будет
становиться все больше, и вы захотите разделить ваш пакет на несколько библиотечных крейтов.
Cargo предоставляет функциональность под названием workspaces, которая помогает управлять
несколькими взаимосвязанными пакетами, которые разрабатываются в тандеме.

<em>Workspace</em> - это набор пакетов, которые используют один и тот же Cargo.lock и директорию для
хранения результатов компиляции.
Команда cargo install позволяет локально устанавливать и использовать исполняемые крейты. Она не
предназначена для замены системных пакетов; она используется как удобный способ Rust
разработчикам устанавливать инструменты, которыми другие разработчики поделились на сайте
crates.io.

Если исполняемый файл доступен через переменную окружения $PATH и назван по шаблону
cargo-something, то его можно запускать как субкоманду Cargo cargo something. Пользовательские
команды подобные этой также перечисляются в списке доступных через cargo --list.

В большинстве современных операционных систем программный код выполняется в виде процесса,
причём операционная система способна управлять несколькими процессами сразу. Программа, в свою
очередь, может состоять из нескольких независимых частей, выполняемых одновременно.
Конструкция, благодаря которой эти независимые части выполняются, называется потоком. Например,
веб-сервер может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного
запроса за раз.

Для обеспечения отправки многопоточных сообщений в стандартной библиотеке языка Rust
реализованы каналы. 
<em>Канал в программировании</em> - это общепринятый механизм, с помощью которого
данные из одного потока отправляются другому потоку.
Канал считается закрытым , если либо передающая, либо принимающая его половина уничтожена.
Мы создаём новый канал, используя функцию mpsc::channel; mpsc означает несколько
производителей, один потребитель (multiple producer, single consumer).
, что несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в
конце концов окажется в одной реке.

<img src="../img/rust/Rust132.png" alt="">
<img src="../img/rust/Rust133.png" alt="">
<img src="../img/rust/Rust134.png" alt="">
<img src="../img/rust/Rust135.png" alt="">
<img src="../img/rust/Rust136.png" alt="">
<img src="../img/rust/Rust137.png" alt="">
<img src="../img/rust/Rust138.png" alt="">
<img src="../img/rust/Rust139.png" alt="">
<img src="../img/rust/Rust140.png" alt="">
<img src="../img/rust/Rust141.png" alt="">
</div>
    </details>
    <details><!--Variable-->
        <summary>Variable</summary>
<div class="menu__komment">Переменные по умолчаню не изменяемые.
let x - объявление переменной
mut - измеяемый, с константами использовать нельзя
let mut x - объявление изменяемой переменной
const - константа, при объявлении константы обязательно указать тип
const THIS_IS_CONSTANT: U32 - объявление константы
Затенение - вторая переменная с тем же именем затеняет первую, присваивая себе любое использование
имени переменной до тех пор пока либо она сама не будет затенена, либо область действия не закончится.
let x = 5; - Используя слово let, мы создвём новую переменную. Менять тип переменной нельзя.
let x = x + 1; - Затенение
let x = 5; - привязываем значение к переменной
let y = x; - копируем значение в другую переменную. Оба значения помещаются в стек.
let s1 = String::from(“hello”); - привязываем указатель. Указатель находится в стеке. Указатель указывает на
память, в которой хранится содержимое строки, длина и емкость. Содержимое строки хранится в куче.
let s2 = s1; - перемещение. Ссылка (указатель) в переменной s1 на данные в куче не действительна. Указатель
только в переменной s2.
let s1 = String::from(“hello”);
let s2 = s1.clone(); - указатель в стеке перемещается, а содержание строки в куче копируется.
Передача переменной в функцию приведет к перемещению или копированию как и при присваивании значения
переменной.
Основная разница в том, что значения копируются, находясь в стеке; и доступны обе переменные с
одинаковыми значениями, а при копировании указателя, который ссылается на данные в куче, доступной будет
только новая переменная, содержащая указатель. То же самое при передачи в функцию.
& - амперсанд (&String) - это ссылка, которая позволяет ссылаться на некоторое значение, не принимая
владение им.
Процесс создания ссылки называется заимствованием.
Чтобы можно было изменять по ссылке:
fn main () {
let mut s = String::from (“hello”);
- изменяемая переменная s
change (&mut s);
- изменяемая перменная s со ссылкой, т.е. изменяемая ссылка на
}
изменяемую перменную.
Изменяемая ссылка всегда одна в своей области видимости, никаких других ссылок. В один момент времени в
одной области видимости может существовать либо одна изменяемая ссылочная переменная, либо любое
количество неизменяемых ссылочных переменных.
Все ссылки должны быть действительны, т.е. ссылаться на существующие в памяти данные.
Срез позволяет ссылаться на непрерывную последовательность элементов в коллекции, а не на всю коллекцию,
без права владения.
iter () - метод, который возвращает каждый елемент в коллекции.
enumerate () - оборачивает результат iter и возвращает каждый элемент как часть кортежа. Первый элемент
кортежа это индекс, а второй - ссылка на элемент (i, &item).
for (i, &item) in bytes.iter().enumerate()
Строковые срезы (&str - тип “срез строки”).
Строковый срез - это ссылка на часть строки String и он выглядит так:
let s = String::from (“hello world”);
let hello = &s[0..5];
let world = &s[6..11];
Срез хранит начальную позицию и длину среза.
let slice = &s[0..2]; одно и тожеlet slice = &s[..2];
let len = s.len();
let slice = &s[3..len]; одно и тожеlet slice = &s[3..];
let slice = &s[0..len]; одно и тожеlet slice = &s[..];
Строковые литералы - это срезы:
let s = “Hello world!”;
s имеет тип &str.
s - указывает на место в бинарном файле программы.
Строковый литерал неизменяемый, потому что тип &str - это не изменяемая ссылка.
Строковый срез может быть параметром: fn first (s:&str) -> &str {}
Срезы могут быть разные:
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
assert_eq! (slice, &[2, 3]); - тип среза [i32].
У каждой ссылки в Rust есть своё время жизни - область кода, на протяжении которого данная ссылка
действительна (valid).
Мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть
определены компилятором по-разному.
Rust требует от нас объявлять взаимосвязи посредством обобщённых параметров сроков жизни -
чтобы убедиться в том, что во время исполнения все действующие ссылки будут корректными.
Основное предназначение сроков жизни — предотвращать появление так называемых "повисших
ссылок" (dangling references), из-за которых программа обращается не к тем данным, к которым она
собиралась обратиться.
&i32
// a reference
&'a i32 // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
Сигнатура функции сообщает Rust, что для некоторого времени жизни 'a функция принимает два
параметра, оба из которых являются срезами строк, которые живут не меньше, чем время жизни 'a.
Сигнатура функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как
минимум столько, сколько длится время жизни 'a. На практике это означает, что время жизни ссылки,
возвращаемой функцией longest, равно меньшему времени жизни передаваемых в неё ссылок.
Структуры могут содержать и ссылки, но при этом необходимо добавить аннотацию времени жизни для
каждой ссылки в определении структуры.
struct ImportantExcerpt<'a> {
part: &'a str,
}
Как и в случае с обобщенными типами данных мы объявляем имя обобщенного параметра времени
жизни внутри угловых скобок после имени структуры, чтобы иметь возможность использовать его
внутри определения структуры. Данная аннотация означает, что экземпляр ImportantExcerpt не
может пережить ссылку, которую он содержит в своем none part.
Шаблоны, запрограммированные в анализаторе ссылок языка Rust, называются правилами неявного
выведения времени жизни. Это не правила, которым должны следовать программисты; а набор
частных случаев, которые рассмотрит компилятор, и, если ваш код попадает в эти случаи, вам не
нужно будет указывать время жизни явно.
Времена жизни параметров функции или метода называются временем жизни ввода, а времена жизни
возвращаемых значений называются временем жизни вывода.
Три правила применяются к объявлениям fn, а также к блокам impl:
Первое правило заключается в том, что каждый параметр являющийся ссылкой, получает свой
собственный параметр времени жизни. Другими словами, функция с одним параметром получит один
параметр времени жизни fn foo<’a> (x: &’a i32); функция с двумя аргументами получит два отдельных
параметра времени жизни: fn foo <’a, ‘b> (x: &’a i32, , y: &’b i32), и так далее.
Второе правило говорит, что если есть ровно один входной параметр времени жизни, то его время
жизни назначается всем выходным параметрам: fn foo<’a> (x: &’a i32) -> &’a i32.
Третье правило о том, что если есть множество входных параметров времени жизни, но один из них
является ссылкой &self или &mut self, так как эта функция является методом, то время жизни self
назначается временем жизни всем выходным параметрам. Это третье правило делает методы намного
приятнее для чтения и записи, потому что требуется меньше символов.
'static означает, что данная ссылка может жить всю продолжительность работы программы. Все
строковые литералы по умолчанию имеют время жизни 'static:
let s: &'static str = "I have a static lifetime.";
Указатель — это общая концепция для переменной, которая содержит адрес участка памяти. Этот
адрес «относится к», или «указывает на» некоторые другие данные. Наиболее общая разновидность
указателя в Rust — это ссылка
Умные указатели, с другой стороны, являются структурами данных, которые не только действуют как
указатель, но также имеют дополнительные метаданные и возможности.
ссылки только заимствуют данные, умные указатели часто владеют данными, на которые указывают
Характерной чертой, которая отличает умный указатель от обычной структуры, является то, что для
умных указателей реализованы типажи Deref и Drop.
Наиболее простой умный указатель - это box, чей тип записывается как Box<.T>. Такие переменные
позволяют хранить данные в куче, а не в стеке. То, что остаётся в стеке, является указателем на
данные в куче.
Использовать его чаще всего в следующих ситуациях:
Когда у вас есть тип, размер которого невозможно определить во время компиляции, а вы хотите
использовать значение этого типа в контексте, требующем точного размера.
Когда у вас есть большой объем данных и вы хотите передать владение, но при этом быть
уверенным, что данные не будут скопированы
Когда вы хотите получить значение во владение и вас интересует только то, что оно относится к
типу, реализующему определённый трейт, а не то, является ли оно значением какого-то конкретного
типа.
Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную
стрелочку направляющую к значению, хранящемуся в другом месте.
Box-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других
специальных возможностей
Сравнение числа и ссылки на число не допускается, потому что они различных типов. Мы должны
использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она
указывает.
Сильные ссылки - это то с помощью чего вы можете поделиться владением экземпляра Rc<T>. Слабые
ссылки не отражают связи владения, и их подсчёт не влияет на то, когда экземпляр Rc<T> будет
очищен. Они не приведут к ссылочному циклу, потому что любой цикл, включающий несколько слабых
ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет
равным 0.
Игнорирование неиспользуемой переменной, начинающейся с символа _ в имени
Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных
fn main() {
let _x = 5;
let y = 10;
}
Синтаксис _x по-прежнему привязывает значение к переменной, тогда как _ не привязывает ничего.
Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене
владельца значения
fn main() {
let s = Some(String::from("Hello!"));
if let Some(_s) = s {
println!("found a string");
}
println!("{:?}", s);
}

Использование подчёркивания не привязывает значение
fn main() {
let s = Some(String::from("Hello!"));
if let Some(_) = s {
println!("found a string");
}
println!("{:?}", s);
}
Связывание @
Оператор at (@) позволяет создать переменную, которая содержит значение, одновременно с тем, как
мы проверяем, соответствует ли это значение шаблону.
мы хотим проверить, что перечисление Message::Hello со значением поля id находится в диапазоне
3..=7. Но мы также хотим привязать такое значение к переменной id_variable, чтобы использовать его
внутри кода данной ветки.
Использование @ для привязывания значения в шаблоне, с одновременной его проверкой
fn main() {
enum Message {
Hello { id: i32 },
}
let msg = Message::Hello { id: 5 };
match msg {
Message::Hello {
id: id_variable @ 3..=7,
} => println!("Found an id in range: {}", id_variable),
Message::Hello { id: 10..=12 } => {
println!("Found an id in another range")
}
Message::Hello { id } => println!("Found some other id: {}", id),
}
}
</div>
    </details>
    <details><!--Type-->
        <summary>Type</summary>
<div class="menu__komment">Rust статически типизированный язык.
Целочисленные типы:
Длина       Со знаком       Без знака
8 bit           i8          u8
16 bit          i16         u16
32 bit          i32         u32
64 bit          i64         u64
128 bit         i128        u128
arch            isize       usize

arch - основное использование - это индекация коллекции. Зависит от архитектуры компьютера 34-bit или 64-bit.
Склярный тип представляет единственное значение. В Rust четыре склярных типа:
целые и вещественные числа, логический тип и символ.
Числовые литералы:
Десятиричный - 98_222
Шестнадцатиричный - Oxff
Восьмиричный - 0o77
Двоичный - 0b1111_0000
Байт (только u8) - b’A’
Типы чисел с плавающей запятой f32 и f64
Логистический тип данных bool: true или false
Символический тип данных char. Литералы char в одинарных кавычках:
let c = ‘Z’;    let z:char = ‘Z’;
Сложные типы данных: кортежи и массивы, могут группировать несколько значений в один тип.
Кортеж: группировка нескольких значений различного типа в единый комбнированный тип фиксированной
длины.
Let tup: (i32, f64, u8) = (500, 6.4, 1);
Дуструктуризация: let (x,y,z) = tup;
Обращение к элементу кортежа по индексу:
let five_hundred = tup.0;
unit - обозначается ( ) и представляет собой пустое значение или пустой возвращаемый тип.
Игнорирование нескольких частей кортежа
fn main() {
let numbers = (2, 4, 8, 16, 32);
match numbers {
(first, _, third, _, fifth) => {
println!("Some numbers: {first}, {third}, {fifth}")
}
}
}
Игнорирование оставшихся частейц значения с помощью . .
Игнорирование полей структуры Point кроме поля x с помощью ..
fn main() {
struct Point {
x: i32,
y: i32,
z: i32,
}
let origin = Point { x: 0, y: 0, z: 0 };
match origin {
Point { x, .. } => println!("x is {}", x),
}
}
Сопоставление только первого и последнего значений в кортеже и игнорирование всех других значений
fn main() {
let numbers = (2, 4, 8, 16, 32);
match numbers {
(first, .., last) => {
println!("Some numbers: {first}, {last}");
}
}
}
Массивы: набор значений одного типа и фиксированной длины.
let a = [1, 2, 3, 4, 5];
[i32; 5] - тип и длина
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5]; - получим массив let a = [3, 3, 3, 3, 3];
Доступ к элементам массива: let first = a [0];
Вектор - аналогичный массиву тип коллекции без фиксированной величины.
String - строковый тип управляет данными, выделенными в куче, и поэтому может хранить объем текста, который
во время компиляции не известен.
Типы, размер которых известен во время компиляции, полностью храняться в стеке и быстро копируются. Для
указателей на данные в куче происходит перемещение.
Для создания копии данных в куче происходит клонирование.
За копирование типа отвечает типаж Copy. Он анотирован для типов хранящихся в стеке.
Типаж Copy не совместим с типажем Drop и типами, которые хранятся в куче.
Структура (struct) - пользовательский тип данных, позволяющий назвать и упаковать вместе несколько
связанных значений, составляющих значимую логическую группу. Похоже на атрибуты данных объекта.
Структура, как и кортежи, это способы группировки данных.
Каждая часть данных структуры имеет имя и свой тип, типы могут быть разные.
Каждая пара “имя: тип” называется полем.
Объявление струтуры - это шаблон нашего типа, а экземпляр использует этот шаблон, заполняя его данными.
struct User {
active: bool,
username: String,
email: String,
sign_in_count: u64,
}
Создание экземпляра структуры User:
let user1 = User {
email: String::from (“someone@example.com”),
username: String::from (“someusername123”),
active: true,
sign_in_count: 1,
};
Доступ к полю через точку: user1.email
User {
User {
email: email,
username: username,
active: true,
sign_in_count: 1,
}
email,
username,
active: true,
sign_in_count: 1,
=
}
Синтаксис .. указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного
экземпляра:
let user2 = User {
email: String::from (“another@example.com”),
..user1
};
..user1 должен стоять последним для указания на получение значений всех оставшихся полей из
соответствующих полей в user1.
Кортежные структуры - именованные кортежи:
struct Color (i32, i32, i32); - картежная структура.
let black = color (0, 0, 0); - экземпляр типа color.
Экземпляры кортежных структур можно как кортежи деструктурировать и использовать точку с индексом для
доступа к значению.
Единично-подобные структуры - структуры, которые не имеют полей. Требуются когда нужно реализовать типаж
для типа, но нет данных, которые нужно хранить в типе:
struct AlwaysEqual;
По умолчанию фигурные скобки в println! означают использование форматирования, известного как типаж
Display.
Структуры не имеют встроенной реализации Display, поэтому можно распечатать в Debug:println! ({:?}).
Макрос dbg! распечатывает значение в формате Debug. Для этого нужно подключить атрибут derive:
#[derive(Debug)]
Структуры создают типы, позволяют хранить связанные данные и давать названия частям данных.
Методы позволяют определить поведение экземпляров структур, а ассоциированные функции привязывают
функциональность к вашей структуре, не обращаясь к её экземпляру.
Метод - поведение экземпляра
Ассоциированная функция - поведение структуры
Перечисления (enumerations, enums) дают способ сказать, что значение является одним из возможных наборов
значений, структура данных enum.
В любой из вариантов перечисления можно поместить данные:
enum IpAddr {
V4(String),
V6(String),
}
let home = IpAddr::V4(String::from(“127.0.0.1”));
let loopback = IpAddr::V6(String::from(“ : :1”));
Каждый вариант перечисления (V4, V6) - это функция, которая создаёт экземпляр перечисления, т.е. принимает
String и возвращает экземпляр типа IpAddr, это функция-конструктор.
В отличии от структуры (struct) перечисление (enum) может иметь разное количество данных в разных типах,
можно включать перечисления в другие перечсления.
enum IpAddr {
V4(u8, u8, u8, u8),
V6(String),
}
let home = IpAddr::V4(String::from(“127.0.0.1”));
let loopback = IpAddr::V6(String::from(“ : :1”));
С помощью impl блока, мы можем определять методы для перечисления.
Тип Option кодирует сценарий, в котором значение может быть чем-то, а может быть ничем.
enum Option < T> {
None,
Some (T),
}
Нужно познакомиться с методами перечисления Option < T> в документации.
Перечисление Option < T> и его варианты Some и None включены в прелюдию. Поэтому Option не нужно вводить
в область видимости, а Some и None используем без префикса Option::.
Чтобы иметь значение, которое может быть null его тип нужно явно описать с помощью Option <T> и явно
обрабатывать случай, когда значение равно null.
Значение может быть равно null только имея тип Option < T>, в остальных случаях (с другими типами) значение
всегда not-null.
Если использовать pub перед определением структуры, то это делает структуру публичной, но поля этой
структуры остаются приватными.
Чтобы поле структуры стало публичным добавляем pub.
Если сделать перечисление общедоступным pub enum, то все его варианты будут общедоступными.
Коллекция хранит множество однотипных значений в куче, т.е. размер коллекции может быть не известен в
момент компиляции, может изменяться в размере во время работы программы.
Каждый вид коллекции имеет свои возможности:
- Вектор (Vector) - сохраняет различное количество последовательно хранящихся значений.
- Строка (String) - последовательность символов.
- Хеш-таблица (hash map) - коллекция, которая позволяет хранить перечень ассоциаций значения с ключом
(перечень пар ключ: значение).
Коллекция вектор (vector): Vec < T>
Создание пустого вектора для хранения значений типа i32:
let v: Vec< i32> = Vec::new();
Макрос vec! - создает новый вектор.
let v = vec![1, 2, 3]; - новый вектор целочисленного типа i32 со значениями 1, 2, 3.
Создать новый вектор и добавить значения:
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
Доступ к элементу вектора:
v.[2] - индекс (нумерация индексов с 0)
v.get(2) - метод get, получаем тип Option<&T>
При обращении по индексу за пределами вектора, произойдет паника.
При обращении к индексу за пределами вектора через get - вернется None без паники.
Получение неизменяемых ссылок на каждый элемент в векторе:
let v = vec![100, 32, 57];
for i in &v {
println!(“{}”, i);
}
Добавление к каждому элементу вектора:
let mut v = vec![100, 32, 57];
for i in &mut v {
*i += 50;
}
*i - получение значения переменной i с помощью оператора разыменовывания ссылки *.
Строки (String) реализованы в виде набора байтов.
В Rust есть только один строковый тип в ядре языка - срез строки &str.
Тип String предоставляется стандартной библиотекой.
И String и строковые срезы &str кодируются в UTF-8.
String фактически реализован как обертка вокруг вектора байтов.
СТАНДАРТНУЮ БИБЛИОТЕКУ ВЫУЧИТЬ!!!
Индексирование строк это плохая идея, т.к. не ясно каким должен быть возвращаемый тип такой операции:
байтовым значением (код UTF-8), символом (char), кластером графем или срезом строки.
Коллекция hash map (хеш карта).
Тип HashMap < K, V> хранит ключ типа К на значение типа V. Организует и хранит данные с помощью функции
хеширования. Как и векторы, HashMap однородны: все ключи должны иметь одинаковый тип и все значения
должны иметь одинаковый тип.
По умолчанию HashMap использует функцию хеширования SipHach, который может противостоять Dos-атакам с
использованием таблиц siphash.
Обобщённые типы данных generics - это абстрактные подставные типы на место которых
возможно поставить какой-либо конкретный тип или другое свойство.
(Option< T>, Vec< T>, HashMap< K, V>, Result< T, E>).
Мы используем обобщённые типы данных для объявления функций или структур, которые
затем можно использовать с различными конкретными типами данных.
fn largest< T>(list: &[T]) -> &T {}
Объявление читается так: функция largest является обобщённой по типу T. Эта функция имеет
один параметр с именем list, который является срезом значений с типом данных T. Функция
largest возвращает значение этого же типа T.
Синтаксис использования обобщённых типов в определении структуры такой же как у функции.
Объявляем имена типов параметров внутри треугольных скобок сразу после названия
структуры.
Мы также можем определить структуры, использующие обобщённые типы в одном или
нескольких своих полях, с помощью синтаксиса <>.
Поля структуры с обопщенным типом имеют одинаковый тип, каким бы он не являлся.
Чтобы определить структуру Point, где оба значения x и y являются обобщёнными, но
различными типами, можно использовать несколько параметров обобщённого типа.
struct Point< T, U> {
x: T,
y: U,
}
Определение методов может использовать обобщённые типы:
impl< T> Point< T> {}
Мономорфизация — это процесс превращения обобщённого кода в конкретный код путём
подстановки конкретных типов, использующихся при компиляции.
< Т> - обопщенный тип
вы можете реэкспортировать элементы, чтобы сделать публичную структуру, отличную от вашей
внутренней структуры, используя pub use.
Box< T> для распределения значений в куче (памяти).
Rc< T> тип счётчика ссылок, который допускает множественное владение.
Типы Ref< T> и RefMut< T>, доступ к которым осуществляется через тип RefCell< T>, который
обеспечивает правила заимствования во время выполнения вместо времени компиляции.
Тип Box< T> является умным указателем, поскольку он реализует трейт Deref, который позволяет
обрабатывать значения Box< T> как ссылки. Когда значение Box< T> выходит из области видимости,
данные кучи, на которые указывает box, также очищаются благодаря реализации типажа Drop.
Устанавливаем y как экземпляр Box< T>, указывающий на скопированное значение x, а не как ссылку,
указывающую на значение x.
Без типажа Deref компилятор может только разыменовывать & ссылки. Метод deref даёт компилятору
возможность принимать значение любого типа, реализующего Deref и вызывать метод deref чтобы
получить ссылку &, которую он знает, как разыменовывать.
Когда типаж Deref определён для задействованных типов, Rust проанализирует типы и будет
использовать Deref::deref столько раз, сколько необходимо, чтобы получить ссылку, соответствующую
типу параметра.
Rust выполняет разыменованное приведение, когда находит типы и реализации типажей в трёх
случаях:
Из типа &T в тип &U когда верно T: Deref< Target=U>
Из типа &mut T в тип &mut U когда верно T: DerefMut< Target=U>
Из типа &mut T в тип &U когда верно T: Deref< Target=U>
Rust также приводит изменяемую ссылку к неизменяемой. Но обратное не представляется возможным:
неизменяемые ссылки никогда не приводятся к изменяемым ссылкам.
Drop позволяет регулировать, что происходит, когда значение вот-вот выйдет из области видимости.
Тело функции drop - это место, где должна располагаться вся логика, которую вы захотите выполнять,
когда экземпляр вашего типа выйдет из области видимости.
Rust автоматически вызывал функцию drop в момент выхода наших экземпляров из области
видимости, тем самым выполнив заданный нами в drop код. Переменные ликвидируются в обратном
порядке их создания.
Rust не позволяет вызвать метод типажа Drop вручную; вместо этого вы должны вызвать функцию
std::mem::drop предоставляемую стандартной библиотекой, если хотите принудительно удалить
значение до конца области видимости.
Тип Rc< T> отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё.
Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет
недействительной.
Тип Rc< T> используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими
частями нашей программы и не можем определить во время компиляции, какая из частей завершит
использование данных последней.
Обратите внимание, что Rc< T> используется только в одно поточных сценариях.
Вызов Rc::clone только увеличивает счётчик ссылок, что не занимает много времени.
Внутренняя изменяемость - это паттерн проектирования Rust, который позволяет вам изменять данные
даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами
заимствования.
RefCell< T> предоставляет единоличное владение данными, которые он содержит.
С помощью ссылок и типа Box< T> инварианты правил заимствования применяются на этапе
компиляции. С помощью RefCell< T> они применяются во время работы программы.
Тип RefCell< T> полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но
компилятор не может понять и гарантировать этого.
Вот список причин выбора типов Box< T>, Rc< T> или RefCell< T>:
Тип Rc< T> разрешает множественное владение одними и теми же данными; типы Box< T> и
RefCell< T> разрешают иметь единственных владельцев.
Тип Box< T> разрешает неизменяемые или изменяемые владения, проверенные при компиляции;
тип Rc< T> разрешает только неизменяемые владения, проверенные при компиляции; тип RefCell< T>
разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.
Поскольку RefCell< T> разрешает изменяемые заимствования, проверенные во время выполнения,
можно изменять значение внутри RefCell< T> даже если RefCell< T> является неизменным.
Изменение значения внутри неизменного значения является шаблоном внутренней изменяемости
(interior mutability).
Инсценировочные (Mock) объекты - это особый тип тестовых дублёров, которые сохраняют данные
происходящих во время теста действий тем самым позволяя вам убедиться впоследствии, что все
действия были выполнены правильно.
Вызвать образование ссылочной зацикленности не просто, но и не невозможно. Если у вас есть
значения RefCell< T> которые содержат значения Rc< T> или аналогичные вложенные комбинации
типов с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте
зацикленность
Тип Box< T> имеет известный размер и указывает на данные размещённые в куче. Тип Rc< T>
отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев.
Тип RefCell< T> с его внутренней изменяемостью предоставляет тип, который можно использовать при
необходимости неизменного типа, но необходимости изменить внутреннее значение этого типа; он
также обеспечивает соблюдение правил заимствования во время выполнения, а не во время
компиляции.
Mutex - это сокращение от взаимное исключение (mutual exclusion), так как мьютекс позволяет только
одному потоку получать доступ к некоторым данным в любой момент времени. Для того, чтобы
получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить
доступ запрашивая блокировку (lock) мьютекса. Блокировка - это структура данных, являющаяся
частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным.
Поэтому мьютекс описывается как объект защищающий данные, которые он хранит через систему
блокировки.
Mutex< T> является умным указателем, точнее, вызов lock возвращает умный указатель, называемый
MutexGuard, обёрнутый в LockResult, который мы обработали с помощью вызова unwrap. Умный
указатель типа MutexGuard реализует типаж Deref для указания на внутренние данные; умный
указатель также имеет реализацию типажа Drop, автоматически снимающего блокировку, когда
MutexGuard выходит из области видимости.
Arc< T> является типом аналогичным типу Rc< T>, который безопасен для использования в ситуациях
многопоточности. Буква А означает атомарное, что означает тип ссылка подсчитываемая атомарно.
Atomics - работают как примитивные типы, но безопасны для совместного использования между
потоками: дополнительную информацию смотрите в документации стандартной библиотеки для
std::sync::atomic.
стандартные типы библиотек не реализованы для использования вместе с типом Arc< T> по
умолчанию. Причина в том, что безопасность потоков сопровождается снижением производительности.
типы Arc< T> и Rc< T> имеют одинаковый API.
Mutex< T> сопряжён с риском создания взаимных блокировок (deadlocks). Это происходит, когда
операции необходимо заблокировать два ресурса и каждый из двух потоков получил одну из
блокировок, заставляя оба потока ждать друг друга вечно.
В язык встроены две концепции многопоточности: std::marker типажи Sync и Send.
Маркерный типаж Send указывает, что владение типом реализующим Send, может передаваться между
потоками. Почти каждый тип Rust является типом Send, но есть некоторые исключения, вроде Rc< T>:
он не может быть Send, потому что если вы клонировали значение Rc< T> и попытались передать
владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно. По этой
причине Rc< T> реализован для использования в однопоточных ситуациях, когда вы не хотите платить
за снижение производительности.
Маркерный типаж Sync указывает, что на тип реализующий Sync можно безопасно ссылаться из
нескольких потоков. Другими словами, любой тип T является типом Sync, если &T (ссылка на T )
является типом Send, что означает что ссылку можно безопасно отправить в другой поток. Подобно
Send, примитивные типы являются типом Sync, а типы полностью скомбинированные из типов Sync,
также являются Sync типом.
Умный указатель Rc< T> не является Sync типом по тем же причинам, по которым он не является Send.
Тип RefCell< T> и семейство связанных типов Cell< T> не являются Sync.
Этот код позволяет нам разбивать сложные типы на составные части, чтобы мы могли использовать
интересующие нас значения по отдельности.
Деструктуризация с помощью шаблонов - это удобный способ использования фрагментов значений,
таких как как значение из каждого поля в структуре, по отдельности друг друга.
Ассоциированные типы (Associated types) связывают заполнитель типа с типажом, таким образом, что
объявления методов типажа могут использовать эти заполнители типов в своих сигнатурах.
С ассоциированными типами не нужно аннотировать типы, потому что мы не можем реализовать типаж
у типа несколько раз.
Тип по умолчанию указывается при объявлении обобщённого типа с помощью синтаксиса
< PlaceholderType=ConcreteType>.
Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Но
можно перегрузить перечисленные операции и соответствующие им типажи из std::ops путём
реализации типажей, связанных с этими операторами.

// Integer addition
    assert!(1u32 + 2u32 == 3u32);

    // Integer subtraction
    assert!(1i32 - 2 == -1);
    assert!(1i32 - 2 == -1); 
    
    assert!(3 * 50 == 150);

    assert!(9.6f32 / 3.2f32 == 3.0);

    assert!(24 % 5 == 4);
    // Short-circuiting boolean logic
    assert!(true && false == false);
    assert!(true || false == true);
    assert!(!true == false);
</div>
    </details>
    <details><!--Function-->
        <summary>Function</summary>
<div class="menu__komment">fn - объявление функции
fn main ( ) { } - точка входа в программу
fn another_function ( ); - определение функции
another_function ( ); - вызов функции
another_function (5); - вызов функции с передачей значения “5” как аргумент (параметр) функции.
Объявлять тип каждого параметра сигнатуры функции обязательно:
fn another_function (valu: i32, label: char) { };
Методы как и функции:
- ключевое слово fn
- имеют параметры и возвращаемое значение
- содержат код, который выполняется при вызове
Методы - это функции, которые определяются в контексте структуры. Первый параметр метода всегда self -
экземпляр структуры, на который вызывается метод.
impl Rectangle {
fn area (&self) -> u32 (
self.width * self.height
}
}
Создание блока impl (implementation - реализация) определяет функцию area в контексте типа Rectangle.
rect1.area() - вызов метода area на экземпляре rect1 типа Rectangle.
Всё, что хотим сделать с экземпляром типа, помещаем в один блок impl.
Методу можно давать имя такое же как и у поля структуры. Отличие в обращении - это наличие круглых скобок у
метода.
Как правило, метод с таким же именем как у поля возвращает значение этого поля.
Такие методы называются геттерами.
Все функции определенные в блоке impl, называются ассоциированными функциями, потому что они
ассоциированы с типом, указанным после ключевого слова impl.
Можно определить ассоциированные функции без self в качестве первого параметра. Такие функции не
являются методами и их часто используют для конструкторов, возвращающих новый экземпляр структуры.
Вызвать ассоциированную функцию можно через ::.
:: - это синтаксис для обращения к ассоциированным функциям и к пространству имен, созданое модулем.
Ассоциированная функция - в блоке impl
Ассоциированная функция в контексте структуры - метод
Ассоциированная функция без параметра self - конструктор
Замыкания - конструкции, подобные функциям, которые можно помещать в переменные
Замыкания: анонимные функции, которые запечатлевают ("захватывают") своё окружение.
Замыкания в Rust - это анонимные функции, которые можно сохранять в переменных или передавать в
качестве аргументов другим функциям.
В отличие от функций, замыкания могут использовать значения из области видимости в которой они
были определены.
fn giveaway(&self, user_preference: Option< ShirtColor>) -> ShirtColor {
user_preference.unwrap_or_else(|| self.most_stocked())
}
|| self.most_stocked() - замыкание
|| - между вертикальными линиями указываются параметры
self.most_stocked() - тело замыкания
Замыкания, как правило, короткие и уместны только в узком контексте, а не в произвольном сценарии.
Определение функции и замыкания:
fn add_one_v1 (x: u32) -> u32 { x + 1 } - функция
let add_one_v2 = |x: u32| -> u32 { x + 1 }; - замыкание с полной аннотацией
let add_one_v3 = |x|
{ x + 1 }; - замыкание без аннотации типа
let add_one_v4 = |x|
x + 1 ; - в теле замыкания одна операция, скобки не нужны.
Строки add_one_v3 и add_one_v4 требуют, чтобы замыкания были вычислены до компиляции,
поскольку типы будут выведены из их использования.
Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют
тем же трём способам, которыми функция может принимать параметры: заимствование неизменяемых,
заимствование изменяемых и получение владения. Замыкание самостоятельно определяет, какой из
этих способов использовать, исходя из того, что тело функции делает с полученными значениями.
Если вы хотите заставить замыкание принять владение значениями, которые оно использует в
окружении, даже если в теле замыкания нет кода, требующего владения, вы можете использовать
ключевое слово move перед списком параметров.
Замыканиям автоматически присваивается реализация одного, двух или всех трёх из
нижеперечисленных трейтов Fn, аддитивным образом, в зависимости от того, как тело замыкания
обрабатывает значения:
FnOnce применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания реализуют
по крайней мере этот трейт, потому что все замыкания могут быть вызваны. Замыкание, которое
перемещает захваченные значения из своего тела, реализует только FnOnce и ни один из других
признаков Fn, потому что оно может быть вызвано только один раз.
FnMut применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но
могут изменять захваченные значения. Такие замыкания могут вызываться более одного раза.
Fn применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не
модифицируют захваченные значения, а также к замыканиям, которые ничего не захватывают из
своего окружения. Такие замыкания могут выполняться более одного раза и не меняют ничего в своём
окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.
Трейты Fn важны при определении или использовании функций или типов, использующих замыкания.
Итераторы — способ обработки последовательности элементов.
Использование паттерна Итератор помогает при необходимости поочерёдного выполнения какой-либо
операции над элементами последовательности. Итератор отвечает за логику перебора элементов и
определение момента завершения последовательности.
Все итераторы реализуют типаж Iterator, который определён в стандартной библиотеке.
Метод iter создаёт итератор по неизменяемым ссылкам. Если мы хотим создать итератор, который
становится владельцем v1 и возвращает принадлежащие ему значения, мы можем вызвать into_iter
вместо iter. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать iter_mut
вместо iter.
Методы, вызывающие next, называются потребляющими адаптерами, поскольку их вызов потребляет
итератор.
Адаптеры итераторов - это методы, определённые для трейта Iterator, которые не потребляют
итератор. Вместо этого они создают различные итераторы, изменяя некоторые аспекты исходного
итератора.
В Rust итераторы ленивые (lazy), то есть они не делают ничего, пока вы не вызовете специальные
методы, потребляющие итератор, чтобы задействовать его.
Вы можете выстроить цепочку из нескольких вызовов адаптеров итератора для выполнения сложных
действий в удобочитаемом виде. Но поскольку все итераторы являются "ленивыми", для получения
результатов вызовов адаптеров итератора необходимо вызвать один из методов потребляющего
адаптера.
Разворачивание - это оптимизация, которая устраняет издержки кода управления циклом и вместо
этого генерирует повторяющийся код для каждой итерации цикла.
Реализации замыканий (closures) и итераторов (iterators) таковы, что нет влияния на
производительность выполнения кода. Это одна из целей Rust, направленных на обеспечение
абстракций с нулевой стоимостью (zero-cost abstractions).
Чтобы создать новый поток, мы вызываем функцию thread::spawn и передаём ей замыкание,
содержащее код, который мы хотим запустить в новом потоке.
Вызовы thread::sleep заставляют поток на короткое время останавливать своё выполнение, позволяя
выполняться другим потокам.
Тип возвращаемого значения thread::spawn — JoinHandle . JoinHandle — это владеющее значение,
которое, при вызове метода join , будет ждать завершения своего потока.
Мы будем часто использовать ключевое слово move с замыканиями, переданными в thread::spawn ,
потому что замыкание будет затем владеть значениями, взятыми из окружающего кода, а значит
передаст владение этими значениями от одного потока к другому.
Добавляя ключевое слово move перед замыканием, мы заставляем замыкание забирать используемые
значения во владение, вместо того, чтобы позволить Rust вывести необходимость заимствования
значения.
Игнорирование значений в шаблоне
Есть несколько способов игнорировать целые значения или части значений в шаблоне: используя
шаблон _ внутри другого шаблона, используя имя, начинающееся с подчёркивания, либо используя ..,
чтобы игнорировать оставшиеся части значения.
Игнорирование всего значения с помощью шаблона _
Использование _ в сигнатуре функции
fn foo(_: i32, y: i32) {
println!("This code only uses the y parameter: {}", y);
}
fn main() {
foo(3, 4);
}
Игнорирование параметра функции может быть особенно полезно в случаях когда, например, вы
реализуете типаж с определённой сигнатурой, но тело функции в вашей реализации не нуждается в
одном из параметров.
Игнорирование частей значения с помощью вложенного _
Использование подчёркивания в шаблонах, соответствующих вариантам Some, когда нам не нужно использовать значение внутри
Some
fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);
match (setting_value, new_setting_value) {
(Some(_), Some(_)) => {
println!("Can't overwrite an existing customized value");
}
_ => {
setting_value = new_setting_value;
}
}
println!("setting is {:?}", setting_value);
}
Бизнес-требования заключаются в том, что пользователь не должен иметь права перезаписывать
существующую настройку параметра, но может сбросить параметр и присвоить ему значение, если он
в данный момент не установлен.
</div>
    </details>
    <details><!--Operator-->
        <summary>Operator</summary>
<div class="menu__komment">Операторы - это инструкции, которые выполняют действие и не возвращают значение.
Выражения - вычесляют результирующее значение.
{ } - создают область видимости (scope).
let - это оператор
fn - это оператор
let y = 6; - оператор
6 - выражение
; - окончание оператора
fn main ( ) {let y = 6;} - оператор
{let y = 6;} - выражение
Вызов функции, вызов макроса - это выражение.
Если добавить точку с запятой в конец выражения, то оно превратится в оператор и не вернет значение.
fn five ( ) -> i32 {5} - функция возвращает значение.
-> i32 {5} - объявляет тип возвращаемого значения.
// - комментарий только однострочный
Область видимости - это диапозон внутри программы, для которого допустим элемент.
Когда переменная появляется в области видимости, она считается действительной до момента выхода за
границы этой области.
let s = String::from(“hello”); - создать String из строкового литерала.
Оператор :: позволяет использовать пространство имен функции from под типом String.
Связанное понятие - это область видимости: вложенный контекст в котором написан код имеющий набор имён,
которые определены “в текущей области видимости”.
Оператор * (glob) - включает в область видимости все общедоступные элементы, определенные в пути:
use std::collections::*;
Сокращение для проброса ошибок: оператор ?
Оператор ? может использоваться только в функциях, тип возвращаемого значения которых
совместим со значением, для которого используется ?.
Исполняемые файлы, написанные на C, при выходе возвращают целые числа: успешно
завершённые программы возвращают целое число 0, а программы с ошибкой возвращают
целое число, отличное от 0. Rust также возвращает целые числа из исполняемых файлов, чтобы
быть совместимым с этим соглашением.

0011 AND 0101 is 0001
0011 OR 0101 is 0111
0011 XOR 0101 is 0110
1 << 5 is 32
0x80 >> 2 is 0x20
</div>
    </details>
    <details><!--Construction-->
        <summary>Construction</summary>
<div class="menu__komment">Условие всегда типа bool:
if number < 5 {println!(“Hi!”);} else {println!(“Buy”);}
if - выражение
number < 5 - условие
{println!(“Hi!”);} - ответвление
println!(“Hi!”); - макрос
else - выражение
{println!(“Buy”);} - ответвление
println!(“Buy”); - макрос
По очереди проверяется каждое выражение if и выполняется первое тело, для которого условие истино,
остальные блоки уже не проверяет.
Управляющая конструкция match:
Механизм управления потоком, который сравнивает значение с различными шаблонами и выполняет код в
зависимости от того, какой из шаблонов совпал.
enum Coin {
Penny,
Nickel,
Dime,
Quarter,
}
fn value_in_cents (coin: Coin) -> u8 {
match coin {
Coin::Penny => 1,
Coin::Nickel => 5,
Coin::Dime => 10,
Coin::Quarter => 25,
}
}
match coin:
match - ключевое слово
coin - - выражение, которое возвращает любой тип. В данном случае значение coin.
Coin::Penny => 1, - ветка
Coin::Penny - шаблон. В данном случае значение Coin::Penny.
=> - оператор
1 - выражение, код для выполнения. В данном случае значение 1.
Код, связанный с каждой веткой, является выражением, а полученное значение выражения в соответствующей
ветке - это значение, которое возвращается для всего выражения match.
Если код для выполнения больше одной строки, то в фигурные скобки { } - запятая не обязательно.
Универсальный шаблон:
let dice_roll = 9;
match dice_roll {
3 => add_fancy_hat(),
7 => remove_fancy_hat(),
other => move_player(other), - универсальный шаблон с привязкой к значению
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
fn move_player(num_spaces: u8) {}
Для последней ветки шаблоном является переменная, которая передаётся в функцию move_player. Последняя
ветка является универсальным шаблоном с привязкой к значению переменной шаблона.
Заполнитель _ - специальный шаблон, который используется если не нужно привязываться к значению.
let dice_roll = 9;
match dice_roll {
3 => add_fancy_hat(),
7 => remove_fancy_hat(),
_=> reroll (), - универсальный шаблон без привязки к значению.
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
fn reroll () {}
Используем пустой кортеж - единичное значение, чтобы обозначить, что не используем никакое другое значение,
кроме предыдущих веток и не запускаем никакого кода:
let dice_roll = 9;
match dice_roll {
3 => add_fancy_hat(),
7 => remove_fancy_hat(),
_=> (),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
if let - не запускается если значение не соответствует шаблону. Шаблон и выражение разделены знаком
равенства.
let config_max = Some (3u8);
if let Some (max) = config_max {
println! (“The maximum is configured to be { }”, max);
}
Ветки match
match VALUE {
PATTERN => EXPRESSION,
PATTERN => EXPRESSION,
PATTERN => EXPRESSION,
}
Value - значение
Pattern - шаблон
Expression - выражение
Одно из требований к выражениям match состоит в том, что они должны быть исчерпывающими
(exhaustive) в том смысле, что они должны учитывать все возможности для значения в выражении
match.
Шаблон _ может быть полезен, если вы, например, хотите игнорировать любое не указанное значение.
Дополнительные условия оператора сопоставления (Match Guards)
Условие сопоставления (match guard) является дополнительным условием if, указанным после
шаблона в ветке match, которое также должно быть выполнено, чтобы ветка была выбрана. Условия
сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон.
Добавление условия сопоставления в шаблон
fn main() {
let num = Some(4);
match num {
Some(x) if x % 2 == 0 => println!("The number {} is even", x),
Some(x) => println!("The number {} is odd", x),
None => (),
}
}
Использование условия сопоставления для проверки на равенство со значением внешней переменной
fn main() {
let x = Some(5);
let y = 10;
match x {
Some(50) => println!("Got 50"),
Some(n) if n == y => println!("Matched, n = {n}"),
_ => println!("Default case, x = {:?}", x),
}
println!("at the end: x = {:?}, y = {y}", x);
}
Комбинирование нескольких шаблонов с условием сопоставления
fn main() {
let x = 4;
let y = false;
match x {
4 | 5 | 6 if y => println!("yes"),
_ => println!("no"),
}
}
приоритет условия сопоставления по отношению к шаблону ведёт себя так:
(4 | 5 | 6) if y => ...
а не так:
4 | 5 | (6 if y) => ...
Можно также смешивать и сопоставлять выражения if let, else if и else if let. Это даёт больше
гибкости, чем match выражение, в котором можно выразить только одно значение для сравнения с
шаблонами.
Недостатком использования if let выражений является то, что компилятор не проверяет полноту
(exhaustiveness) всех вариантов, в то время как с помощью выражения match это происходит.
let PATTERN = EXPRESSION;
Шаблоны бывают двух форм: опровержимые и неопровержимые. Шаблоны, которые будут
соответствовать любому возможному переданному значению, являются неопровержимыми (irrefutable).
Примером может быть x в выражении let x = 5;, потому что x соответствует чему-либо и,
следовательно, не может не совпадать. Шаблоны, которые могут не соответствовать некоторому
возможному значению, являются опровержимыми (refutable). Примером может быть Some(x) в
выражении if let Some(x) = a_value, потому что если значение в переменной a_value равно None, а не
Some, то шаблон Some(x) не будет совпадать.
Сопоставление с литералом
fn main() {
let x = 1;
match x {
1 => println!("one"),
2 => println!("two"),
3 => println!("three"),
_ => println!("anything"),
}
}
Сопоставление именованных переменных
fn main() {
let x = Some(5);
let y = 10;
match x {
Some(50) => println!("Got 50"),
Some(y) => println!("Matched, y = {y}"),
_ => println!("Default case, x = {:?}", x),
}
println!("at the end: x = {:?}, y = {y}", x);
}
Поскольку match начинает новую область видимости, то переменные, объявленные как часть шаблона
внутри выражения match, будут затенять переменные с тем же именем вне конструкции match как и в
случае со всеми переменными.
Группа шаблонов
fn main() {
let x = 1;
match x {
1 | 2 => println!("one or two"),
3 => println!("three"),
_ => println!("anything"),
}
}
Сопоставление диапозонов с помощью ..=
fn main() {
let x = 5;
match x {
1..=5 => println!("one through five"),
_ => println!("something else"),
}
}
Деструктуризация структуры
struct Point {
x: i32,
y: i32,
}
fn main() {
let p = Point { x: 0, y: 7 };
let Point { x: a, y: b } = p;
assert_eq!(0, a);
assert_eq!(7, b);
}
Или
struct Point {
x: i32,
y: i32,
}
fn main() {
let p = Point { x: 0, y: 7 };
let Point { x, y } = p;
assert_eq!(0, x);
assert_eq!(7, y);
}
Деструктуризация и сопоставление с литералами в одном шаблоне
struct Point {
x: i32,
y: i32,
}
fn main() {
let p = Point { x: 0, y: 7 };
match p {
Point { x, y: 0 } => println!("On the x axis at {x}"),
Point { x: 0, y } => println!("On the y axis at {y}"),
Point { x, y } => {
println!("On neither axis: ({x}, {y})");
}
}
}
Вместо создания переменных для всех полей мы также можем деструктурировать с помощью
литеральных значений являющихся частью структуры.
struct Point {
x: i32,
y: i32,
}
fn main() {
let p = Point { x: 0, y: 7 };
match p {
Point { x, y: 0 } => println!("On the x axis at {x}"),
Point { x: 0, y } => println!("On the y axis at {y}"),
Point { x, y } => {
println!("On neither axis: ({x}, {y})");
}
}
}
Деструктуризация перечислений
enum Message {
Quit,
Move { x: i32, y: i32 },
Write(String),
ChangeColor(i32, i32, i32),
}
fn main() {
let msg = Message::ChangeColor(0, 160, 255);
match msg {
Message::Quit => {
println!("The Quit variant has no data to destructure.");
}
Message::Move { x, y } => {
println!("Move in the x direction {x} and in the y direction {y}");
}
Message::Write(text) => {
println!("Text message: {text}");
}
Message::ChangeColor(r, g, b) => {
println!("Change the color to red {r}, green {g}, and blue {b}",)
}
}
}
Этот код напечатает Change the color to red 0, green 160, and blue 255.
Деструктуризация вложенных структур и перечислений
До сих пор все наши примеры сопоставляли структуры или перечисления на один уровень глубины, но
сопоставление может работать и с вложенными элементами!
enum Color {
Rgb(i32, i32, i32),
Hsv(i32, i32, i32),
}
enum Message {
Quit,
Move { x: i32, y: i32 },
Write(String),
ChangeColor(Color),
}
fn main() {
let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
match msg {
Message::ChangeColor(Color::Rgb(r, g, b)) => {
println!("Change color to red {r}, green {g}, and blue {b}");
}
Message::ChangeColor(Color::Hsv(h, s, v)) => {
println!("Change color to hue {h}, saturation {s}, value {v}")
}
_ => (),
}
}
</div>
    </details>
    <details><!--Memory-->
        <summary>Memory</summary>
<div class="menu__komment">Владение позволяет обеспечивать безопасность памяти без использования сборщика мусора.
Владение - это набор правил, определяющих как программа на Rust управляет памятью.
Стек - часть памяти, который хранит значения в порядке их получения, а удаляет - в обратном. “Последний
пришёл, первый вышел”.
Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер.
Данные, размер которых во время компиляции неизвестен или может измениться, должны храниться в куче.
Куча - часть памяти, в которой распределитель памяти находит для данных подходящее место, помечает его как
используемое и возвращает указатель - адрес этого места. Это выделение в куче или просто выделение.
Правила владения:
У каждого значения в Rust есть владелец.
У значения может быть только один владелец в один момент времени.
Когда владелец покидает область видимости, значение удаляется.
При вызове String::from происходит запрос необходимой памяти.
Память автоматически возвращается, как только владеющая памятью переменная выходит из области
видимости { }.
Rust автоматически вызывает функцию drop после закрывающей фигурной скобки и очищает память.
Вектор освобождает память когда выходит из области видимости, при этом удаляются все значения, которые он
содержит.
</div>
    </details>
    <details><!--Cycle-->
        <summary>Cycle</summary>
<div class="menu__komment">loop, while, for
loop - выполняет блок кода пока нет команды остановиться (break)
break - прерывает выполнение цикла и выходит из него
continue - пропустить оставшийся код в данной итерации цикла и перейти к следующей итерации
break counter*2 - останавливает выполнение цикла и возвращает значение выражения counter*2
break и continue применяется к самому внутреннему циклу внутри цепочки циклов.
Метка цикла ‘ :
‘counting_up: loop {
...
loop {
...
if count == 2 {
break ‘counting_up;} - выход из цикла к ‘counting_up в начале цикла
}
...
}
}
while number! = 0 {...} - пока условие истинно, код выполняется, в противном случае происходит выход из цикла.
Конструкция условного цикла while let позволяет повторять цикл while до тех пор, пока шаблон
продолжает совпадать.
В цикле for значение, которое следует непосредственно за ключевым словом for , является шаблоном.
Например, в for x in y выражение x является шаблоном.
Цикл for:
fn main () {
let a = [10, 20, 30, 40, 50];
for element in a {
println! (“the value is: {element}”);
}
}
fn main () {
for number in (1..4).rev() {
println! (“{number}!”);
}
println! (“LIFTOFF !!!”);
}
</div>
    </details>
    <details><!--Error-->
        <summary>Error</summary>
<div class="menu__komment">В Rust ошибки группируются на две основные категории: исправимые (recoverable) и неисправимые
(unrecoverable).
Rust имеет тип Result<T, E> для обрабатываемых (исправимых) ошибок и макрос panic!, который
останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку.
На практике существует два способа вызвать панику: путём выполнения действия, которое вызывает
панику в нашем коде (например, обращение к массиву за пределами его размера) или путём явного
вызова макроса panic!.
По умолчанию, когда происходит паника, программа начинает процесс раскрутки стека, означающий
в Rust проход обратно по стеку вызовов и очистку данных для каждой обнаруженной функции. Rust как
альтернативу предоставляет вам возможность немедленного прерывания (aborting), которое завершает
работу программы без очистки. Память, которую использовала программа, должна быть очищена
операционной системой. Добавьте panic = 'abort' в раздел [profile] вашего Cargo.toml файла.
Мы можем использовать обратную трассировку вызовов функций которые вызвали panic! чтобы
выяснить, какая часть нашего кода вызывает проблему.
получить обратную трассировку можно с помощью установки переменной среды RUST_BACKTRACE в
любое значение, кроме 0. Обратная трассировка создаёт список всех функций, которые были
вызваны до какой-то определённой точки выполнения программы. Другие строки, которые выше над
строками с упоминанием наших файлов, - это код, который вызывается нашим кодом; строки ниже
являются кодом, который вызывает наш код.
enum Result<T, E> {
Ok(T),
Err(E),
}
T представляет тип значения, которое будет возвращено в случае успеха внутри варианта Ok, а E
представляет тип ошибки, которая будет возвращена при сбое внутри варианта Err.
Метод unwrap - это метод быстрого доступа к значениям. Если значение Result является вариантом Ok,
unwrap возвращает значение внутри Ok. Если Result - вариант Err, то unwrap вызовет для нас макрос
panic!.
Метод expect позволяет указать сообщение об ошибке для макроса panic!.
expect используется так же как и unwrap: либо возвращается дескриптор файла либо вызывается
макрос panic!.
Наше сообщение об ошибке в expect будет передано в panic! и заменит стандартное
используемое сообщение.
Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться
ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий
код, чтобы он мог решить, что с ней делать. Такой приём известен как распространение ошибки
(propagating the error).
</div>
    </details>
    <details><!--Trait-->
        <summary>Trait</summary>
<div class="menu__komment">Типаж сообщает компилятору Rust о функциональности, которой обладает определённый тип и
которой он может поделиться с другими типами. Можно использовать типажи, чтобы
определять общее поведение абстрактным способом. Мы можем использовать ограничение
типажа (trait bounds) чтобы указать, что общим типом может быть любой тип, который имеет
определённое поведение.
Определение типажей - это способ сгруппировать сигнатуры методов вместе для того, чтобы
описать общее поведение.
pub trait Summary {
fn summarize(&self) -> String;
}
После сигнатуры метода, вместо предоставления реализации в фигурных в скобках, мы
используем точку с запятой. Каждый тип, реализующий данный типаж, должен предоставить
своё собственное поведение для данного метода.
Реализация типожа у типа
impl Summary for NewsArticle {
fn summarize(&self) -> String {}
impl Summary for Tweet {
fn summarize(&self) -> String {)
Мы не можем реализовать внешние типажи для внешних типов. Это ограничение является
частью свойства называемого согласованность (coherence), а ещё точнее сиротское правило
(orphan rule), которое называется так потому что не представлен родительский тип. Без этого
правила два крейта могли бы реализовать один типаж для одинакового типа и Rust не сможет
понять, какой реализацией нужно пользоваться.
Типажи как параметры
pub fn notify(item: &impl Summary) {
println!("Breaking news! {}", item.summarize());
}
Вместо конкретного типа у параметра item указывается ключевое слово impl и имя типажа. Этот
параметр принимает любой тип, который реализует указанный типаж.
Обе записи одинаковы:
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
pub fn notify< T: Summary>(item1: &T, item2: &T) {
Более одного типажа
pub fn notify(item: &(impl Summary + Display)) {
Это выражение:
fn some_function< T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
Можно записать так:
fn some_function< T, U>(t: &T, u: &U) -> i32
where
T: Display + Clone,
U: Clone + Debug,
{
fn returns_summarizable() -> impl Summary {
Используя impl Summary для возвращаемого типа, мы указываем, что функция returns_summarizable
возвращает некоторый тип, который реализует типаж Summary без обозначения конкретного типа.
Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать метод to_string
определённый типажом ToString для любого типа, который реализует типаж Display:
impl< T: Display> ToString for T {
// --snip--
}
Общие реализации приведены в документации к типажу в разделе "Implementors".
Типажи и ограничения типажей позволяют писать код, который использует параметры обобщённого
типа для уменьшения дублирования кода, а также указывая компилятору, что мы хотим обобщённый
тип, чтобы иметь определённое поведение. Затем компилятор может использовать информацию про
ограничения типажа, чтобы проверить, что все конкретные типы, используемые с нашим кодом,
обеспечивают правильное поведение.
В Rust применяется подход с использованием типажей-объектов вместо наследования.
Мы можем использовать типаж-объекты вместо универсального или конкретного типа. Везде, где мы
используем типаж-объект, система типов Rust проверит во время компиляции, что любое значение,
используемое в этом контексте, будет реализовывать нужный типаж у типаж-объекта. Следовательно,
нам не нужно знать все возможные типы во время компиляции.
В структуре или перечислении данные в полях структуры и поведение в блоках impl разделены, тогда
как в других языках данные и поведение объединены в одну концепцию, часто обозначающуюся как
объект. Тем не менее, типаж-объекты являются более похожими на объекты на других языках, в том
смысле, что они сочетают в себе данные и поведение. Но типаж-объекты отличаются от традиционных
объектов тем, что не позволяют добавлять данные к типаж-объекту. Типаж-объекты обычно не
настолько полезны, как объекты в других языках: их конкретная цель - обеспечить абстракцию через
общее поведение.
Когда мы используем типаж-объекты, Rust должен использовать динамическую диспетчеризацию.
Компилятор не знает всех типов, которые могут быть использованы с кодом, использующим
типаж-объекты, поэтому он не знает, какой метод реализован для какого типа при вызове. Вместо
этого, во время выполнения, Rust использует указатели внутри типаж-объекта, чтобы узнать какой
метод вызвать. Такой поиск вызывает дополнительные затраты во время исполнения, которые не
требуются при статической диспетчеризации.
Деструктуризация структур и кортежей
fn main() {
struct Point {
x: i32,
y: i32,
}
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
}
</div>
    </details>
    <details><!--Test-->
        <summary>Test</summary>
<div class="menu__komment">Тесты - это функции Rust, которые проверяют, что не тестовый код работает ожидаемым образом.
Содержимое тестовых функций обычно выполняет следующие три действия:
1. Установка любых необходимых данных или состояния.
2. Запуск кода, который вы хотите проверить.
3. Утверждение, что результаты являются теми, которые вы ожидаете.
Чтобы превратить функцию в тестирующую функцию добавьте #[test] в строку перед fn. Когда вы
запускаете тесты командой cargo test, Rust создаёт бинарный модуль выполняющий функции
аннотированные атрибутом test и сообщающий о том, успешно или нет прошла каждая тестирующая
функция.
Макрос assert! доступен из стандартной библиотеки и является удобным, когда вы хотите проверить
что некоторое условие в тесте вычисляется в значение true.
Когда проверка не срабатывает, макросы печатают значения аргументов с помощью отладочного
форматирования и это означает, что значения сравниваемых аргументов должны реализовать типажи
PartialEq и Debug. Все примитивные и большая часть типов стандартной библиотеки Rust реализуют
эти типажи. Для структур и перечислений, которые вы реализуете сами будет необходимо реализовать
типаж PartialEq для сравнения значений на равенство или неравенство. Для печати отладочной
информации в виде сообщений в строку вывода консоли необходимо реализовать типаж Debug. Так как
оба типажа являются выводимыми типажами, то эти типажи можно реализовать добавив аннотацию
#[derive(PartialEq, Debug)] к определению структуры или перечисления.
Общим способом проверки функциональности является использование сравнения результата
тестируемого кода и ожидаемого значения, чтобы убедиться в их равенстве. Для этого можно
использовать макрос assert!, передавая ему выражение с использованием оператора ==. Cтандартная
библиотека предлагает пару макросов assert_eq! и assert_ne!, чтобы сделать тестирование более
удобным. Эти макросы сравнивают два аргумента на равенство или неравенство соответственно.
Макросы также печатают два значения входных параметров, если тест завершился ошибкой, что
позволяет легче увидеть почему тест ошибочен. Противоположно этому, макрос assert! может только
отобразить, что он вычислил значение false для выражения ==, но не значения, которые привели к
результату false.
В своей работе макросы assert_eq! и assert_ne! неявным образом используют операторы == и !=
соответственно.
Другой атрибут тест-функции #[should_panic]. Этот атрибут сообщает системе тестирования, что тест
проходит, когда метод генерирует ошибку.
#[cfg(test)]
mod tests {
use super::*;
#[test]
#[should_panic]
fn greater_than_100() {
Тест с атрибутом should_panic пройдёт, даже если тест паникует по причине, отличной от той, которую
мы ожидали. Чтобы сделать тесты с should_panic более точными, мы можем добавить необязательный
параметр expected для атрибута should_panic.
#[cfg(test)]
mod tests {
use super::*;
#[test]
#[should_panic(expected = "less than or equal to 100")]
fn greater_than_100() {
Написание тестов так, чтобы они возвращали Result<T, E> позволяет использовать оператор
"вопросительный знак" в теле тестов, который может быть удобным способом писать тесты, которые
должны выполниться не успешно, если какая-либо операция внутри них возвращает вариант ошибки
Err.
#[cfg(test)]
mod tests {
#[test]
fn it_works() -> Result<(), String> {
if 2 + 2 == 4 {
Ok(())
} else {
Err(String::from("two plus two does not equal four"))
}
}
}
Поскольку тесты выполняются параллельно, вы должны убедиться, что ваши тесты не зависят друг от
друга или от какого-либо общего состояния, включая общее окружение, например, текущий рабочий
каталог или переменные окружения.
cargo test -- --test-threads=1
Мы устанавливаем количество тестовых потоков равным 1 , указывая программе не использовать
параллелизм. Выполнение тестов с использованием одного потока займёт больше времени, чем их
параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют
состояние.
Если мы хотим видеть напечатанные результаты прохождения тестов, мы можем сказать Rust, чтобы
он также показывал результаты успешных тестов с помощью --show-output.
cargo test -- --show-output
Запустить только несколько тестов, используя команду cargo test, передав в качестве
аргумента имена тестов.
cargo test it_works
Мы можем указать часть имени теста, и будет запущен любой тест, имя которого соответствует этому
значению.
Можно аннотировать тесты атрибутом ignore, чтобы исключить их из исполнения:
#[test]
fn it_works() {
assert_eq!(2 + 2, 4);
}
#[test]
#[ignore]
fn expensive_test() {
// code that takes an hour to run
}
Если вы хотите выполнить только проигнорированные тесты, вы можете воспользоваться командой
cargo test -- --ignored
Если вы хотите запустить все тесты независимо от того, игнорируются они или нет, выполните cargo
test -- --include-ignored.
Модульные тесты это небольшие и более сфокусированные на тестировании одного модуля в
отдельности или могут тестироваться приватные интерфейсы. Интеграционные тесты являются
полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как
любой другой внешний код, используя только общедоступные интерфейсы и потенциально выполняя
тестирование нескольких модулей в одном тесте.
Целью модульных тестов является тестирование каждого блока кода, изолированное от остального
функционала, чтобы можно было быстро понять, что работает некорректно или не так как ожидается.
Аннотация #[cfg(test)] у модуля с тестами указывает Rust компилировать и запускать только код
тестов, когда выполняется команда cargo test, а не когда запускается cargo build.
Тем не менее, так как модульные тесты идут в тех же файлах что и основной код, вы будете
использовать #[cfg(test)] чтобы указать, что они не должны быть включены в скомпилированный
результат.
Мы создаём папку tests в корневой папке вашего проекта, рядом с папкой src. Cargo знает, что искать
файлы с интеграционными тестами нужно в этой директории.
Нам не нужно комментировать код в tests/integration_test.rs с помощью #[cfg(test)]. Cargo
специальным образом обрабатывает каталог tests и компилирует файлы в этом каталоге только тогда,
когда мы запускаем команду cargo test.
Выходные данные представлены тремя разделами: модульные тесты, интеграционные тесты и тесты
документации.
Чтобы запустить все тесты в конкретном файле интеграционных тестов, используйте аргумент --test
сопровождаемый именем файла у команды cargo test:
cargo test --test integration_test
Файлы в подкаталогах каталога tests не компилируются как отдельные крейты или не появляются в
результатах выполнения тестов.
Если наш проект является бинарным крейтом, который содержит только src/main.rs и не содержит
src/lib.rs, мы не сможем создать интеграционные тесты в папке tests и подключить функции
определённые в файле src/main.rs в область видимости с помощью оператора use. Только
библиотечные крейты могут предоставлять функции, которые можно использовать в других крейтах;
бинарные крейты предназначены только для самостоятельного запуска.
Процесс разработки через тестирование (TDD), который следует этим шагам:
Напишите тест, который не прошёл и запустите его, чтобы убедиться, что он не прошёл по той причине,
которую вы ожидаете.
Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый тест.
Выполните рефакторинг кода, который вы только что добавили или изменили, и убедитесь, что тесты
продолжают проходить.
Повторите с шага 1!
</div>
    </details>
    <details><!--Unsafe Rust-->
        <summary>Unsafe Rust</summary>
<div class="menu__komment">Чтобы переключиться на небезопасный Rust, используйте ключевое слово unsafe, а затем начните новый блок, содержащий
небезопасный код. В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы
называем небезопасными супер силами. Эти супер силы включают в себя следующее:
● Разыменование сырого указателя
● Вызов небезопасной функции или небезопасного метода
● Доступ или изменение изменяемой статической переменной
● Реализация небезопасного типажа
● Доступ к полям в union
Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх
небезопасных операции внутри блоков, помеченных как unsafe, вы будете знать, что любые
ошибки, связанные с безопасностью памяти, будут находиться внутри unsafe блоков. Делайте
unsafe блоки маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с
памятью.
Части стандартной библиотеки реализованы как проверенные, безопасные абстракции над
небезопасным кодом.
Создание необработанных указателей из ссылок
fn main() {
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
}
В отличие от ссылок и умных указателей, сырые указатели:
● могут игнорировать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых
указателей на одну и ту же область памяти
● не гарантируют что ссылаются на действительную память
● могут быть null
● не реализуют автоматическую очистку памяти
Разыменование сырых указателей в блоке unsafe
fn main() {
let mut num = 5;
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
unsafe {
println!("r1 is: {}", *r1);
println!("r2 is: {}", *r2);
}
}
Вызов небезопасной функции или метода
fn main() {
unsafe fn dangerous() {}
unsafe {
dangerous();
}
}
обёртывание небезопасного кода в безопасную функцию - это обычная абстракция.
Использование небезопасного кода в реализации функции split_at_mut
use std::slice;
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
let len = values.len();
let ptr = values.as_mut_ptr();
assert!(mid <= len);
unsafe {
(
slice::from_raw_parts_mut(ptr, mid),
slice::from_raw_parts_mut(ptr.add(mid), len - mid),
)
}
}
fn main() {
let mut vector = vec![1, 2, 3, 4, 5, 6];
let (left, right) = split_at_mut(&mut vector, 3);
}
мы можем быть уверены, что все сырые указатели, используемые в unsafe блоке будут
действительными указателями на данные внутри среза. Это приемлемое и правильное использование
unsafe.
Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на
другом языке. Для этого в Rust есть ключевое слово extern, которое облегчает создание и
использование интерфейса внешних функций (Foreign Function Interface - FFI). FFI - это способ для
языка программирования определить функции и позволить другому (внешнему) языку
программирования вызывать эти функции.
extern "C" {
fn abs(input: i32) -> i32;
}
fn main() {
unsafe {
println!("Absolute value of -3 according to C: {}", abs(-3));
}
}
мы делаем функцию call_from_c доступной из кода на языке C, после того как она скомпилирована в
разделяемую библиотеку и прилинкована из C
#![allow(unused)]
fn main() {
#[no_mangle]
pub extern "C" fn call_from_c() {
println!("Just called a Rust function from C!");
}
}
Определение и использование неизменяемой статической (глобальной) переменной
static HELLO_WORLD: &str = "Hello, world!";
fn main() {
println!("name is: {}", HELLO_WORLD);
}
Имена статических переменных по общему соглашению пишутся в нотации SCREAMING_SNAKE_CASE, и мы
должны указывать тип переменной, которым в данном случае является &'static str.
Чтение из изменяемой статической переменной или запись в неё небезопасны
static mut COUNTER: u32 = 0;
fn add_to_count(inc: u32) {
unsafe {
COUNTER += inc;
}
}
fn main() {
add_to_count(3);
unsafe {
println!("COUNTER: {}", COUNTER);
}
}
Мы можем использовать unsafe для реализации небезопасного трейта. Трейт является небезопасным,
если хотя бы один из его методов имеет некоторый инвариант, который компилятор не может
проверить.
unsafe trait Foo {
// methods go here
}
unsafe impl Foo for i32 {
// method implementations go here
}
fn main() {}
</div>
    </details></pre>
    <small>
      <table class="menu__table"><!--Syntax-->
          <caption><b>Syntax</b></caption>
          <thead>
              <tr>
                  <th><b>Syntax</b></th>
                  <th><b>Meta</b></th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>let</td>
                  <td>ключевое слово для объявления переменной</td>
              </tr>
              <tr>
                  <td>{}</td>
                  <td>Scope - блок кода, в котором живёт объявленная переменная</td>
              </tr>
              <tr>
                  <td>Shadowing</td>
                  <td>затенение - позволяет переобъявить переменную в том же блоке кода под тем же именем</td>
              </tr>
              <tr>
                  <td>let x: i32;</td>
                  <td>объявление переменной х типа интежер 32-бита<br>
                  тип указывать желательно</td>
              </tr>
              <tr>
                  <td>;</td>
                  <td>если есть ; то не возвращаем <br>
                      Statment: let x = 3; - ничего не вернём, т.к. есть ; - это Statment.<br>
                      Если есть = то это всегда statment.
                      Expression: x += 1 - вернем значение 4, т.к. нет ; - это Expression
                  </td>
              </tr>
              <tr>
                  <td>let x: i32 = 5;</td>
                  <td>инициализация переменной - присваиваем переменной значение <br>
                  значения, размер которых известен храняться в стэке, если размер не известен то в куче.</td>
              </tr>
              <tr>
                  <td>assert_eq!(x, 5);</td>
                  <td>assert - утверджать, equal - равенство. Макрос (!), который проверяет на равенство.</td>
              </tr>
              <tr>
                  <td>println!("Success"):</td>
                  <td>Макрос (!), который выводит в стандартный вывод (терминал) то, что в "" 
                      и переводит курсор на новую строку</td>
              </tr>
              <tr>
                  <td>format!("{}", x)</td>
                  <td>возвращает String</td>
              </tr>
              <tr>
                  <td>let _y: i32;</td>
                  <td>_y означает неиспользуемая переменная</td>
              </tr>
              <tr>
                  <td>#[allow(unused_variables)]</td>
                  <td>говорит компелатору позволить неиспользуемые переменные <br>
                  при такой записи имена переменных можно без _</td>
              </tr>
              <tr>
                  <td>#[derive(Debug)]</td>
                  <td>говорит компилятору использовать анотацию "{:?}". dbg!(x) - выводит значение переменной х в режиме дебага</td>
              </tr>
              <tr>
                  <td>#[derive(Display)]</td>
                  <td>говорит компилятору использовать анотацию "{}"</td>
              </tr>
              <tr>
                  <td>let (x, y);</td>
                  <td>объявление сразу нескольких переменных let x; и let y;</td>
              </tr>
              <tr>
                  <td>let mut x;</td>
                  <td>mut означает что значение переменной можно изменять</td>
              </tr>
              <tr>
                  <td>x += 2;</td>
                  <td>короткая запись х = х + 2;</td>
              </tr>
              <tr>
                  <td>let &x = y;</td>
                  <td>&x ссылка по имени х ссылается на у</td>
              </tr>
              <tr>
                  <td>let &mut x = mut y;</td>
                  <td>изменяемая ссылка х ссылается на изменяемую переменную у</td>
              </tr>
              <tr>
                  <td>let &<'a> x</td>
                  <td><'a> время жизни ссылки &</td>
              </tr>
              <tr>
                  <td>*x</td>
                  <td>Если х содержит ссылку &x, то * даёт нам значение по ссылке &x</td>
              </tr>
              <tr>
                  <td>let t = (2, "hello", 6.4);</td>
                  <td>tuple - коллекция разнотипных значенией, доступ t.0, println!((только до 12 значений));</td>
              </tr>
              <tr>
                  <td>let (x, y) = (1, 2);</td>
                  <td>Деструктуризация tuple (1, 2) - х = 1, у = 2</td>
              </tr>
              <tr>
                  <td>let (x, y); <br>
                      (x, ..) = (3, 4);<br>
                      [.., y] = [1, 2];
                  </td>
                  <td>Деструктуризация: х принимает значение 3, .. означает пропустить<br>
                      у принимает значение 2. <br>
                      [x, y] = [3, 2]
                  </td>
              </tr>
              <tr>
                  <td>Integers: i32 <br>
                      Floats: f64</td>
                  <td>По умолчанию целое число i32, а число с плавающей точкой - f64 <br>
                      при операциях с f64 большая точность выявляет погрешность чисел, поэтому равенства могут на работать <br>
                      в таких случаях нужно использовать f32: 0.1 + 0.2 == 0.300000000000000001.
                  </td>
              </tr>
              <tr>
                  <td>let x: u16 = 38_u8 as u16;</td>
                  <td>объявил переменную х типа u16 и присваиваю ей значение 38 типа u8 <br>
                  но т.к. присваивать можно значения только того же типа, то меняем тип as u16</td>
              </tr>
              <tr>
                  <td>()</td>
                  <td>unit тип, который не имеет значения, размер 0 байт. let _v: () = ();<br>
                      представляет собой пустой tuple, возвращается когда функция ничего не возвращает.</td>
              </tr>
              <tr>
                  <td>bool</td>
                  <td>логический тип false и true, иметт размер 1 байт</td>
              </tr>
              <tr>
                  <td>char</td>
                  <td>тип символа имеет размер 4 байта. обозначается одинарной кавычкой ''.</td>
              </tr>
              <tr>
                  <td>String</td>
                  <td>тип строки - набор символов в виде вектора байт. обозначается двойной кавычкой "". let x = String::from("hello");<br>
                      переменная x хранит ярлык с длиной, ёмкостью и указателем на адрес памяти в куче где хранится "hello"<br>
                      Методы приведения к типу String: String::from("hallo"); "hello".to_string(); s.replace("word1", "word2"); - заменяет word1 на word2 в строке s<br>
                      s.push_str("hello, world"); - когда добавляем в строку другую строку, s.push('!'); - когда добавляем в строку один символ
                      s3: String = s1: String + s2.as_str(); - при конкатенации строк второе слагаемое должно быть &str. Метод s.clear() - делает строку пустой.</td>
              </tr>
              <tr>
                  <td>str</td>
                  <td>тип строкового литерала "hello", используется только по ссылке &str <br>
                  хранится в стэке и является представлением (фотографией на данный момет) строки типа String,<br>
                    которая храниться в куче. <br>
                  Т.е. при инициализации переменной типа &str мы идём в кучу делаем срез нужной строки <br>
                  и сохраняем его в стэке под именем инициализируемой переменной</td>
              </tr>
              <tr>
                  <td>\</td>
                  <td>экранирование символов в стоке</td>
              </tr>
              <tr>
                  <td>let row_str = r"\x3F";</td>
                  <td>в row строке экранирование не работает, конвертации в символ не будет</td>
              </tr>
              <tr>
                  <td>let s = &s1[0..1];</td>
                  <td>доступ к символам в строке s только через срез. В срезе указываетс диапозон байт строки в котором находится нужный символ</td>
              </tr>
              <tr>
                  <td>=</td>
                  <td>Присваивание. Значение, которое имеет фиксированный размер живёт в стеке и принадлежит переменной. <br>
                      значение, которое может изменяться живёт в куче, на его адрес в куче указывает переменная,<br>
                      в которй хранится указатель, длина значения и количество памяти зарезервированное под это значение. <br>
                      При присваивании значения переменной из стэка другой переменной происходит копирование значения. <br>
                      При присваивании значения переменной из кучи другой переменной происходит перемещение указателя, <br>
                      длины и количества памяти из старой переменной в новую. Старая переменная уничтожается. <br>
                      let new_var = old_var.clone(); - копия значения в куче и указатель на копию в новой переменной
                  </td>
              </tr>
              <tr>
                  <td>::</td>
                  <td>обращение к ассоциированной функции String::from("hello");<br>
                  ассоциированная - это функция без аргумента self</td>
              </tr>
              <tr>
                  <td>.</td>
                  <td>обращение к методу "hello".to_string();<br>
                  метод - это функция первый аргумент которой self</td>
              </tr>
              <tr>
                  <td>0xff</td>
                  <td>16-ти ричное значение 255</td>
              </tr>
              <tr>
                  <td>0o77</td>
                  <td>8-ти ричное значение 63</td>
              </tr>
              <tr>
                  <td>0b1111_1111</td>
                  <td>бинарное (0 и 1) значение 255 </td>
              </tr>
              <tr>
                  <td>for i in 'a'..='z' {<br>
                      println!("{}", i);}</td>
                  <td>for _ in _ {} - цикл. 'a'..='z' - диапозон от..до. если есть =, значит включительно. <br>
                      "{}", i - вставить в стоку значение i</td>
              </tr>
              <tr>
                  <td>for c in "hello".chars() {<br>
                          println!("{}", c) }</td>
                  <td>Метод chars() переведёт символы строки в итератор (в последовательность для итерирования). <br>
                      Цикл for пройдёт по всей последовательности и выведет каждый символ на печать</td>
              </tr>
              <tr>
                  <td>Function</td>
                  <td>именованный блок кода, который используется несколько раз</td>
              </tr>
              <tr>
                  <td>fn name(x: i32, y: i32) -> i32 {<br>
                          x + y<br>
                      }</td>
                  <td>fn - ключевое слово для объявления функции; name(x: i32, y: i32) - имя функции с параметрами х и у, анотация типа параметра обязательна;<br>
                      если в параметр передается переменная, которая указывает на значение в куче,<br>
                      то эта переменная перемещается из своей области видимости в область видимости функции. <br>
                      если в параметр передается переменная со значением в стэке, то переменная остается в своей области видимости, <br>
                      а в область видимости функции передается её копия.
                      -> i32 - возвращает значение типа i32, обязательно указывать если функция что-нибудь возвращает; <br>
                      {} - scope, блок кода, область видимости функции; <br>
                      x + y - выражение, результат которого возвращает функция</td>
              </tr>
              <tr>
                  <td>fn never_return() -> ! { <br>
                          panic!() <br>
                      }</td>
                  <td>функция, которая никогда не вернет поток. Макрос panic!() вызовет ошибку и завершение программы. <br>
                      unimplemented!() - макрос для функций, которые пока ещё не имплементированы. <br>
                      todo!() - <br>
                  </td>
              </tr>
              <tr>
                  <td>Option<.i32></td>
                  <td>Some() None</td>
              </tr>
              <tr>
                  <td>Result<.Res, Err></td>
                  <td>Ok() Err()</td>
              </tr>
              <tr>
                  <td>match x {<br>
                          1 => { } <br>
                          _ => { } <br>
                      }</td>
                  <td></td>
              </tr>
              <tr>
                  <td>let x: Box<.i32> = Box::new(5);</td>
                  <td>Box позволяет разместить любое значение в куче.</td>
              </tr>
              <tr>
                  <td>let s: Box<.str> = "hello, world".into();</td>
                  <td>Метод into() переводит значение, на которои его вызвали в указанный тип переменной.</td>
              </tr>
              <tr>
                  <td>struct Person {<br>
                          name: String,
                          age: Box<.u8>, <br>
                      }</td>
                  <td>создаёт сруктуру с полями. Так создаются новые пользовательские типы.</td>
              </tr>
              <tr>
                  <td>let person: Person = struct Person {<br>
                          name: String::from("Alice"),
                          age: Box::new(20), <br>
                      };</td>
                  <td>инициализируем сруктуру с конкретными значенями. Переменная person имеет тип Person.</td>
              </tr>
              <tr>
                  <td>let Person {name, age} = person;</td>
                  <td>деструктуризируем переменную. Получаем переменные name и age с указателями на значения.</td>
              </tr>
              <tr>
                  <td>let arr = [];</td>
                  <td>let arr: [i32, 3] = [1, 2, 3]; let arr: [i32, 10] = [1; 10]; // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>
                      arr[0], arr.get(0).unwrap(); get(0) - возвращает Option<.T><td>
              </tr>
          </tbody>
      </table>
    </small>
    Rust https://www.rust-lang.org/ru
    Esbuild - сборщик для фронта
    Yew - framework for building front-end web apps
    Percy - библиотека для rust web apps
    Seed - Rust framework for creating fast and reliable web apps
    Sycamore - library for creating web apps
    Laptos - full-stack framework for building web applications in Rust with WebAssembly
            docs.rs/leptos/latest/leptos/
    Stork - простая библиотека, основанная на фичах, для рекурсивного сканирования источников в стиле поисковой системы.
    SWC - Speedy Web Compiler - Rust-based platform for the Web
    <pre>
        1. rust + bash + SQL
        2. свои программы (2Д игра - не ютуб видео с обучением переписываем на rust)
        3. Фреймворки (Работать программистом).
        4. Оценка сложности алгоритмов big O
        5. Базовые структуры данных:
          - массивы
          - связные списки
          - хэш-таблицы
          - стэк
          - очередь
          реализовать с нуля самостоятельно (поиск, вставка, удаление элемента)
        6. Системы счисления
          - шестнадцатиричные
          - двоичные
        7. Архитектура компьютэра
          - модульность памяти
          - сборщики мусора
          - разрядность процессора
          - регистры процессора
        8. Битовые операции
        9. Числа с плавающей точкой
        10. Строки
          - ASCII
          - UNICODE
          - Кодировки
        11. Язык Ассемблера (понимание как работает программа, ОС, вирус)
        12. Стек (программный)
          - передача параметров функции
          - кадры функции
          - возврат функции
        13. Рекурсия (взаимодействие со стеком)
        14. Сортировки (разобрать базовые алгоритмы сортировок:
          - пузырьком
          - вставками
          - кучей
          - Хоара
          - Ламуто
          - т.д.)
        15. Поиск (деревья и графы)
          - бинарное дерево поиска с реализацией вставки, поиска и удаления узлов
          - вэйл дерево
          - красночерное дерево
          - поиск в глубину и ширину графы
        16. Интернет
          - OSI
          - TCP/IP
        17. Операционные  системы
          - организация памяти
          - процессы
          - поток
        18. Файловая система
          - FAT 32
          - NTFS
          - EXT 4
        19. Исполняемые файлы
          - PE
          - ELF
        20. Сжатие
          - изображение
          - звук
          - видео
        21. Криптография
          - HTTPS
          - SSH
          - RSA
        22. 3Д графика
          - шейдеры
          - освещение объектов
          - реализации камеры
        23. Компиляторы
          - Лексический анализ
          - Синтаксический анализ
          - Симантический анализ
          - AST
          - Генерация машинного кода
        24. Математика и алгоритмы
          - книги кнута и корбана
        
        Свой путь
      </pre>
      </div>
    </div>
  </div>
</body>
</html>