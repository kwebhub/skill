<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Testing</title>
</head>
<body>

1. Соответствие макету. Расположение элементов, кнопки, слайдеры работают.
2. Кроссбраузерность. Открыть в разных браузерах.
3. Валидность. html и css проверить в валидаторах, js - проверить в консоле браузера.
4. Адаптивность. Нормально отображаются на смартфоне, планшете и т.д.
5. Оптимизация. Сжать картинки, файлы и т.д. для ускорения загрузки.

Check
1. Сборка Gulp
2. Минимальная вложенность css
3. Проверить переполняемостью контента текст и картинки (отсутствие, меньше, больше).
4. SVG, Webp, Avif, через тег picture, lazy load.
5. Семантика и доступность.
6. Методология (БЭМ).
7. Теги alt у картинок, фавикон, title.
8. Закоментированный код удалить.
9. У текстого поля убрать ресайз. Стилизовать ввод текста.
10. Отступы между элементами марджином.
11. форматы шрифтов — WOFF 2.0 и WOFF.
12. link rel="preload" для ускорения загрузки шрифтов браузером.

Рейтинг технологий https://w3techs.com/
Возможность применения технологий https://caniuse.com/
Кроссбраузерность https://www.browserstack.com/
Валидатор HTML https://validator.w3.org/
Сжатие картинок https://tinypng.com/
Сжатие картинок https://squoosh.app/
TinyImage Compressor
TinyPNG
Kraken
JPEGmini
I love IMG

объединенные в спрайты иконки

PageSpeed Insights от Google, GTMetrix

Page Ruler
PerfectPixel от Well Done Code

<details class="menu__item"><!--Life Cycles-->
  <summary>Life Cycles</summary>
  <div class="menu__inner">
      <p><i>STLC входит в SDLC.</i></p>
      <details><!-- STLC -->
          <summary>STLC</summary>
          <table class="menu__table">
              <caption>STLC - Software Test Life Cycle</caption>
              <thead>
                  <tr>
                      <th>Этап</th>
                      <th>Активность</th>
                      <th>Документы</th>
                  </tr>
              </thead>
              <tbody>
                  <tr>
                      <td>Планирование</td>
                      <td class="dfn">Планирование тестирования состоит из активностей, которые определяют цели тестирования и подход 
                          к достижению целей тестирования с ограничениями, налагаемыми контекстом <br>
                          (например, определение подходящих методов тестирования и задач, 
                          а также формирование графика тестирования для соблюдения крайнего срока).</td>
                      <td><dfn>План тестирования</dfn> <br>(<i>Test Plan</i>)</td>
                  </tr>
                  <tr>
                      <td>Анализ</td>
                      <td class="dfn">В процессе анализа тестирования анализируют базис тестирования для определения тестируемых функций
                          и установление соответствующих тестовых условий. <br>
                          Другими словами, анализ тестирования решает “что тестировать” с точки зрения измеримых критериев покрытия</td>
                      <td><dfn>Дефект</dfn> <br>(<i>Defect</i>)</td>
                  </tr>
                  <tr>
                      <td>Проектирование и реализация</td>
                      <td class="dfn">Во время проектирования тестов тестовые условия воплощаются в высокоуровневые тестовые сценарии,
                          наборы высокоуровневых тестовых сценариев и другое тестовое обеспечение. <br>
                          Так, анализ тестирования отвечает на вопрос «что тестировать?», а проектирование тестов отвечает на вопрос «как тестировать?» <br>
                          Во время реализации тестов создается и/или подготавливается необходимое тестовое обеспечение для 
                          выполнения тестов, включая упорядочивание тестовых сценариев в процедурах тестирования. <br>
                          Таким образом, проектирование тестов отвечает на вопрос «как проверить?», в то время как реализация тестов отвечает 
                          на вопрос: «у нас теперь есть все для запуска тестов?»</td>
                      <td class="dfn">- <dfn>Чек-листы</dfn> <br>(<i>Check lists</i>) <br>
                          - <dfn>Тестовые данные</dfn> <br>(<i>Test Data</i>) <br>
                          - <dfn>Тестовые сценарии</dfn> <br>(<i>Test Cases</i>) <br>
                          - <dfn>Наборы тестовых сценариев</dfn> <br>(<i>Test Suites</i>)</td>
                  </tr>
                  <tr>
                      <td>Выполнение</td>
                      <td class="dfn">Во время выполнения тестов, наборы тестов запускаются в соответствии с расписанием выполнения тестов</td>
                      <td class="dfn">- <dfn>Чек-листы</dfn> <br>(<i>Check lists</i>) <br>
                          - <dfn>Дефект</dfn> <br>(<i>Defect</i>)</td>
                  </tr>
                  <tr>
                      <td>Завершение</td>
                      <td class="dfn">Активности по завершению тестирования собирают данные из выполненных активностей тестирования для обобщения
                          опыта, тестового обеспечения и любой другой соответствующей информации </td>
                      <td class="dfn">- <dfn>Итоговый отчет</dfn> <br>(<i>Test Summary Report</i>) <br>
                          - <dfn>Запросы на улучшение</dfn> <br>(<i>Change Requests</i>)</td>
                  </tr>
                  <tr>
                      <td>Мониторинг и контроль</td>
                      <td class="dfn">Мониторинг тестирования предполагает непрерывное сравнение на всём протяжении цикла фактического хода работы с планом тестирования,
                          используя любые метрики мониторинга тестирования, определённые в плане тестирования. <br>
                          Контроль тестирования подразумевает принятие мер, необходимых для достижения целей плана тестирования
                          (который может быть обновлен с течением времени).</td>
                      <td class="dfn">- <dfn>Отчет о ходе тестирования</dfn> <br>(<i>Test Progress Report</i>) <br>
                          - <dfn>Итоговый отчет</dfn> <br>(<i>Test Summary Report</i>)</td>
                  </tr>
              </tbody>
          </table>
      </details>
      <details><!-- SDLC -->
          <summary>SDLC</summary>
          <img src="../img/qc/SDLC.png" alt="SDLC"> 
          <table class="menu__table">
              <caption>Software Develop Life Cycle</caption>
              <thead>
                  <tr>
                      <th>Step</th>
                      <th>Executor</th>
                      <th>Product</th>
                      <th>Comment</th>
                      <th>QA</th>
                  </tr>
              </thead>
              <tbody>
                  <tr>
                      <td>Idea</td>
                      <td>Product Owner (PO)</td>
                      <td>Idea</td>
                      <td>Владелец продукта озвучивает идею</td>
                      <td>
                          Сможем ли мы это протестировать? <br>
                          Зачем это нужно? <br>
                          Существует ли более простая альтернатива? <br>
                      </td>
                  </tr>
                  <tr>
                      <td>Analysis</td>
                      <td>
                          Business Analyst (BA), <br>
                          System Analyst (SA)
                      </td>
                      <td>
                          Software Requirements Specification (SRS), <br>
                          Business Requirements Document (BRD), <br>
                          User story
                      </td>
                      <td>Бизнес аналитик формирует бизнес требования</td>
                      <td>Все ли варианты развития событий учтены?</td>
                  </tr>
                  <tr>
                      <td>
                          Architecture, <br>
                          Design
                      </td>
                      <td>
                          System Architect, <br>
                          Leads
                      </td>
                      <td>Documentation</td>
                      <td>Архитектор составляет технические требования на основании бизнес требований.</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>Development</td>
                      <td>Developers</td>
                      <td>Build</td>
                      <td>Разработчики получают каждый свою часть продукта для разработки</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>Testing</td>
                      <td>QC</td>
                      <td>
                          Reports, <br>
                          Bug Reports
                      </td>
                      <td>Выполнение тестов</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>Bug fixing</td>
                      <td>Developers</td>
                      <td>Validation</td>
                      <td>Разработчики исправляют баги</td>
                      <td rowspan="3">Проверка снова и снова</td>
                  </tr>
                  <tr>
                      <td>Validation</td>
                      <td>
                          QA, <br>
                          DevOps
                      </td>
                      <td>
                          Release condidate build, <br>
                          Acceptance Testing
                      </td>
                      <td>Владелец продукта тестирует продукт</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>Release</td>
                      <td>DevOps</td>
                      <td>Production</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>Support</td>
                      <td>Developers</td>
                      <td>Feedback from customers</td>
                      <td  style="text-align:left; padding-left: .9375rem;">
                          - Успокоить пользователя. <br>
                          - Пофиксить или передать проблему разработчикам. <br>
                          - Агрегировать и систематизировать пожелания потребителей.
                      </td>
                      <td rowspan="2" style="text-align:left; padding-left: .9375rem;">
                          Уровни поддержки: <br>
                          L1 - первый контакт с потребителем, попытка решить проблему без специальных знаний. <br>
                          L2 - более глубокие технические знания для устранения или обхода проблемы. <br>
                          L3 - разработчики вносят изменения в код программы.
                      </td>
                  </tr>
                  <tr>
                      <td>Death</td>
                      <td></td>
                      <td></td>
                      <td></td>
                      <td></td>
                  </tr>

              </tbody>
          </table>                
      </details>
  </div>
  </details>
  <details class="menu__item"><!-- Models -->
      <summary>Models</summary>
      <div class="menu__inner">
          <details><!-- Waterfall --> 
              <summary>Waterfall</summary>
              <p class="label"><dfn>Каскадная модель</dfn> <br>(или водопадная – <i>waterfall</i>)</p>
              <p>
                  Самая старая и известная модель разработки. <br>
                  - Каждый этап разработки, соответствующий стадии жизненного цикла ПО, продолжает предыдущий. <br>
                  - Для того, чтобы перейти на новый этап, мы полностью должны завершить текущий. <br>
                  - Предусматривает <i>Quality Gate</i> при переходе с этапа на этап. <br>
                  - <dfn>Quality Gate</dfn> - сверка результата этапа с требованиями под розпись.<br>
                  - Много правил и ритуалов.<br>
                  - За каждым в команде закреплена его роль.<br>
                  <br>
                  Применяется: <br>
                  - В проектах с четко определенными требованиями, для которых не предусматривается их изменений в процессе разработки. <br>
                  - Для проектов, которые мигрируют с одной платформы на другую. То есть, требования остаются те же, меняется только 
                  системное окружение и/или язык программирования. <br>
                  - Очень важно качество. <br>
                  - Сроки не критичны. <br>
                  - Есть достаточно денег.
              </p>
              <img src="../img/qc/waterfall.png" alt="">
              <ul>Достоинства:
                  <li>Полное документирование каждого этапа.</li>
                  <li>Простая в организации.</li>
                  <li>Стабильность требований.</li>
                  <li>Четкое планирование сроков и стоимости.</li>
                  <li>Прозрачность процессов для заказчика</li>
              </ul>
              <ul>Недостатки:
                  <li>Необходимость утверждения полного объема требований к системе еще на первом этапе.</li>
                  <li>Увеличение затрат средств и времени в случае необходимости изменения требований.</li>
                  <li>В случае внесения изменений в требования прийдется вернуться к первому этапу и всё сначала.</li>
                  <li>Нет возможности узнать возможный результат проекта.</li>
              </ul>
          </details>
          <details><!-- V-модель -->
              <summary>V-модель</summary>
              <p class="label"><dfn>V-модель</dfn></p>
              <p>
                  Улучшенная версия классической каскадной модели. <br>
                  - Компромис между качеством и гибкостью. <br>
                  - Не много правил и ритуалов. <br>
                  - На каждом этапе происходит контроль текущего процесса, для того чтобы убедится в возможности перехода 
                  на следующий уровень. <br>
                  - Возможно совмещение или сокращение ролей в команде. <br>
                  <br>
                  Применяется:
                  - Требования меняются редко. <br>
                  - Качество важно, но не критично. <br>
                  - В проектах, в которых существуют временные и финансовые ограничения; <br>
                  - Для задач, которые предполагают более широкое, по сравнению с каскадной моделью, тестовое покрытие. <br>
              </p>
              <img src="../img/qc/V-model.jpg" alt="">
              <ul>Software testing levels:
                  <li>Unit testing</li>
                  <li>Integration testing</li>
                  <li>System testing</li>
                  <li>Acceptance testing</li>
              </ul>
              <ul>Достоинства:
                  <li>Планирование тестирования и верификация системы производятся на ранних этапах</li>
                  <li>Улучшенный, по сравнению с каскадной моделью, тайм-менеджмент</li>
                  <li>Промежуточное тестирование</li>
              </ul>
              <ul>Недостатки:
                  <li>Недостаточная гибкость модели</li>
                  <li>Недостаточный анализ рисков</li>
                  <li>Нет работы с параллельными событиями и возможности динамического внесения изменений.</li>
              </ul>
          </details>
          <details><!-- Итеративная / Инкрементальная -->
              <summary>Итеративная / Инкрементальная</summary>
              <p>
                  <dfn>Итеративная и Инкрементальная модели</dfn> - не предполагают полного объема требований для начала работ над продуктом. <br>
                  Применяется когда: <br>
                  - Когда основные требования к системе четко определены и понятны, 
                  в то же время некоторые детали могут дорабатываться с течением времени. <br>
                  - Разработка программы может начинаться с требований к части функционала, которые могут впоследствии дополняться
                  и изменяться. <br>
                  - Есть несколько рисковых функциональностей или целей. <br>
                  - Требуется ранний вывод продукта на рынок. <br>
                  - Процесс повторяется, обеспечивая создание новой версии продукта для каждого цикла. <br>
                  - При понимании и создании первой версии, вторая команда может уже анализировать и планировать вторую версию. <br>
                  - Создание версий внахлёст.
              </p>
              <img src="../img/qc/Incremental.png" alt="">
              <img src="../img/qc/Int.png" alt="">
              <ul>Достоинства:
                  <li>Ранний выход на рынок.</li>
                  <li>Гибкость – готовность к изменению требований на любом этапе разработки.</li>
                  <li>Каждая итерация – маленький этап, для которого тестирование и анализ рисков обеспечить проще,
                      чем для всего жизненного цикла продукта</li>
              </ul>
              <ul>Недостатки:
                  <li>Каждая фаза – самостоятельна, отдельные итерации не накладываются.</li>
                  <li>Могут возникнуть проблемы с реализацией общей архитектуры системы, поскольку не все требования
                      известны к началу проектирования.</li>
              </ul>
          </details>
          <details><!-- Спиральная -->
              <summary>Спиральная</summary>
              <p>
                  Спиральная модель похожа на инкрементную, но с акцентом на анализ рисков. <br>
                  Она хорошо работает для: <br>
                  - решения критически важных бизнес-задач <br>
                  - когда неудача несовместима с деятельностью компании <br>
                  - когда важен анализ рисков и затрат. <br>
                  - в крупных долгосрочных проектах с отсутствием четких требований или вероятностью их динамического изменения. <br>
                  - при разработке новой линейки продуктов.
              </p>
              <img src="../img/qc/spiral.png" alt="">
              <p>
                  - Сначала выпускаем версию с минимальным функционалом. <br>
                  - Каждая последующая версия разработки использует предыдущую. <br>
                  - Создание версий последовательно. <br>
                  - Быстрый выпуск.
              </p>
              <ul>Достоинства:
                  <li>Улучшенный анализ рисков.</li>
                  <li>Хорошая документация процесса разработки.</li>
                  <li>Гибкость – возможность внесения изменений и добавления новой функциональности даже на относительно поздних этапах.</li>
              </ul>
              <ul>Недостатки:
                  <li>Может быть достаточно дорогой в использовании.</li>
                  <li>Управление рисками требует привлечения высококлассных специалистов.</li>
                  <li>Успех процесса в большой степени зависит от стадии анализа рисков.</li>
              </ul>
          </details>
      </div>
  </details>
  <details class="menu__item"><!-- Agile -->
      <summary>Agile</summary>
      <div class="menu__inner">
          <p>Agile - Это не модель, а методы и практики! <br>
              Гибкая методология разработки (англ. Agile software development), agile-методы — обобщающий термин для целого
              ряда подходов и практик, основанных на ценностях Манифеста гибкой разработки программного обеспечения и 
              12 принципах, лежащих в его основе  </p>
          <details><!--Agile Manifesto-->
              <summary>Agile Manifesto</summary>
              <details><!--Values-->
                  <summary>Values</summary>
                  <ol>
                      <li>Люди и взаимодействие <b>важнее</b> процессов и инструментов</li>
                      <li>Работающий продукт <b>важнее</b> исчерпывающей документации</li>
                      <li>Сотрудничество с заказчиком <b>важнее</b> согласования условий контракта</li>
                      <li>Готовность к изменениям <b>важнее</b> следования первоначальному плану</li>
                      <small><em>Не отрицая важности того, что справа, больше ценим то, что слева.</em></small>
                  </ol>
              </details>
              <details><!--Agile Principles-->
                  <summary>Agile Principles</summary>
                  <ol>
                      <li>Наивысшим приоритетом является удовлетворение потребностей заказчика, благодаря регулярной и
                          ранней поставке ценного программного обеспечения.</li>
                      <li>Изменение требований приветствуется,
                          даже на поздних стадиях разработки</li>
                      <li>Работающий продукт следует выпускать
                          как можно чаще, с периодичностью от
                          пары недель до пары месяцев</li>
                      <li>На протяжении всего проекта
                          разработчики и представители бизнеса
                          должны ежедневно работать вместе</li>
                      <li>Над проектом должны работать
                          мотивированные профессионалы.
                          Чтобы работа была сделана, создайте
                          условия, обеспечьте поддержку и
                          полностью доверьтесь им</li>
                      <li>Непосредственное общение является
                          наиболее практичным и эффективным
                          способом обмена информацией как с
                          самой командой, так и внутри команды</li>
                      <li>Работающий продукт — основной
                          показатель прогресса</li>
                      <li>Инвесторы, разработчики и
                          пользователи должны иметь
                          возможность поддерживать
                          постоянный ритм бесконечно</li>
                      <li>Постоянное внимание к техническому
                          совершенству и качеству
                          проектирования повышает гибкость
                          проекта</li>
                      <li>Простота — искусство минимизации
                          лишней работы — крайне необходима</li>
                      <li>Самые лучшие требования,
                          архитектурные и технические решения
                          рождаются у самоорганизующихся
                          команд</li>
                      <li>Команда должна систематически
                          анализировать возможные способы
                          улучшения эффективности и
                          соответственно корректировать стиль
                          своей работы</li>
                  </ol>
              </details>
          </details>
          <details><!--Agile методологии-->
              <summary>Agile методологии</summary>
              <details><!--Kanban-->
                  <summary>Kanban</summary>
                  <p>Kanban — это инструмент управления Agile-проектами, который помогает наглядно представить задачи, 
                      ограничить объем незавершенной работы и добиться максимальной эффективности (или скорости). 
                      С помощью карточек и столбцов на доске Kanban команды могут понять, какой объем работы следует взять на себя, 
                      и выполнить этот объем, придерживаясь принципов непрерывного совершенствования.</p>
              </details>
              <details><!--Extreme Programming (XP)-->
                  <summary>Extreme Programming (XP)</summary>
                  <ul>Пять ценностей XP:
                      <li>общение</li>
                      <li>простота</li>
                      <li>обратная связь</li>
                      <li>смелость</li>
                      <li>уважение</li></ul>
                  <ul>Практики:
                      <li>Игра «Планирование»</li>
                      <li>Маленькие релизы</li>
                      <li>Метафора</li>
                      <li>Простой дизайн</li>
                      <li>Тестирование</li>
                      <li>Рефакторинг</li>
                      <li>Парное программирование</li>
                      <li>Коллективная собственность</li>
                      <li>Непрерывная интеграция</li>
                      <li>40-часовая неделя</li>
                      <li>Клиент на месте</li>
                      <li>Стандарт кодирования</li></ul>
              </details>
              <details><!--Scrum-->
                  <summary>Scrum</summary>
                  <ul> <a href="https://scrumguides.org/">Scrum</a> – это НЕ методология, а фреймворк! <br>
                      <img src="../img/qc/Scrum.png" alt="">
                      <br>
                      <ul>Scrum
                          <li>Roles: <br>
                              PO - product owner <br>
                              SM - scrum master <br>
                              Team        
                          </li>
                          <li>
                              PB - product backlog - требования (приоритизированный список задач) к продукту <br>
                              PO приоритизирует задачи в PB
                          </li>
                          <li><dfn>Эстимация</dfn> - оценка задач в: <br>
                              • часах, днях <br>
                              • story point <br>                                            
                          1 story point - это одна элементарная задача, с которой сравниваются остальные задачи. <br>                                            
                          <dfn>capacity</dfn> - количество story point в спринте. <br>
                          <dfn>velocity</dfn> - производительность команды, т.е. сколько story point может выполнить за спринт</li>
                          <li>сессии спринта: <br>
                              • <em>planing</em> - в начале; формируется SB - sprint backlog, т.е. выбираем из PB задачи для спринта <br>
                              • <em>stand up (Daily Scrum)</em> - каждый день: что делал, что буду делать, какие вижу риски <br>
                              • <em>demo (Sprint Review)</em> - sprint review - показать PO что сделали за спринт <br>
                              • <em>retro (Sprint Retrospective)</em> - что было хорошо, что плохо <br>
                          </li>
                          <li><dfn>Grooming</dfn> - это митинг для пересмотра PB. Организуется PO-ром.</li>
                      </ul>
                      <br>
                      <li>Спринт (Sprint). — итерация в скраме, в ходе которой создается инкремент бизнес-продукта. <br> 
                      Жестко фиксирован по времени. Длительность одного спринта от 1 до 4 недель. <br>
                      Чем короче спринт, тем более гибким является процесс разработки, релизы выходят чаще, быстрее поступают отзывы от потребителя,
                      меньше времени тратится на работу в неправильном направлении</li>
                      <br>
                      <li>Инкремент Продукта — это готовый продукт в конце спринта. Показывают заинтересованным на демонстрации,
                      чтобы собрать отзывы и решить, что делать с продуктом дальше</li>
                      <li>
                          <ul>Scrum - Роли
                              <li>Владелец Продукта (Product Owner) полностью понимает его
                                  ценность для бизнеса. Этот человек доносит потребности клиента
                                  / заказчика до Команды разработки, но не отвечает за
                                  техническую сторону процесса. Владелец Продукта также
                                  отвечает за пользовательские истории и определяет их
                                  приоритетность</li>
                              <li>Скрам-мастер (Scrum Master) помогает Владельцу Продукта и
                                  Команде разработки выполнять работу без препятствий и
                                  отвлекающих факторов. Вся коммуникация людей вне команды
                                  с Командой разработки проходит через Скрам-Мастера</li>
                              <li>Команда разработки (Scrum team) численностью 5-9 человек
                                  выполняет все технические задачи по разработке. Команда кросс
                                  функциональна и отвечает за анализ, дизайн,
                                  программирование, тестирование, техническую коммуникацию и
                                  т. д. В этом она руководствуется пользовательскими историями и
                                  их приоритетностью</li>
                          </ul>
                      </li>
                      <li>
                          <ul>Scrum - Встречи
                              <li>Ежедневный Скрам (Daily Scrum) — Скрам-мероприятия, которые
                                  проходят ежедневно во время спринтов. Они короткие (до 15
                                  минут) и предназначены для того, чтобы спланировать дневное
                                  расписание Команды разработки. Здесь можно обсудить рабочие
                                  сложности или прояснить пользовательские истории. Встреча
                                  обязательна для Команды разработки в полном составе. Скрам-
                                  мастер может на ней присутствовать</li>
                              <li>Обзор Спринта (Sprint Review) — демонстрация действующего
                                  продукта, разработанного во время спринта. Это мероприятие
                                  проходит в конце спринта и предназначено в первую очередь
                                  для того, чтобы в подробностях показать достигнутое Заказчикам</li>
                              <li>Ретроспектива Спринта (Sprint Retrospective) — это своего рода
                                  вскрытие, обсуждение того, как команда справилась во время
                                  спринта и как можно повысить качество её работы в будущем</li>
                          </ul>
                      </li>
                      <li>
                          <ul>Scrum - Артефакты
                              <li>Журнал пожеланий проекта (Product Backlog) — все необходимые
                                  действия, связанные с пользовательской и технической
                                  сторонами проекта</li>
                              <li>Журнал пожеланий спринта (Sprint Backlog) – совокупность всех
                                  задач, которые нужно выполнить за итерацию спринта. Их
                                  выводят из журнала пожеланий продукта во время
                                  Планирования Спринта.</li>
                              <li>История пользователя (User Story) — требуемую бизнес-
                                  функциональность, которую добавляют в бэклог, часто называют
                                  историей.  <br>Зачастую User Story имеет следующую структуру: <br>
                                  «Будучи пользователем 'тип пользователя' я хочу сделать
                                  'действие', чтобы получить 'результат'».  <br>Такая структура удобна
                                  тем, что понятна как разработчикам, так и заказчикам. <br>
                                  User Story - это заголовок для кретериев приемки (Acceptance Criteria). <br>
                                  Одна функциональность - одно User Story</li>
                              <li>Очки за пользовательскую историю (Story Points) — Абстрактная
                                  метрика оценки сложности истории, которая не учитывает
                                  затраты в человеко-часах.
                                  Обычно используют одну из следующих шкал: <br>
                                  - ряд Фибоначчи (1,2,3,5,8,13,21,34,55);<br>
                                  - линейную шкалу (1,2,3,4 ... n);<br>
                                  - степень двойки (1,2,4,8 ... 2n);<br>
                                  - размеры одежды (XS, S, M, L, XL) <br>
                              </li>
                              <li>
                                  Диаграмма сгорания задач (Burndown chart) — Диаграмма,
                                  демонстрирующая количество сделанной и оставшейся работы
                                  относительно времени на разработку проекта. <br>
                                  Данные диаграммы необходимо ежедневно обновлять, чтобы в
                                  реальном времени показывать подвижки и издержки в работе
                                  над спринтом и проектом, доступные для всех членов SCRUM-
                                  команды: скрам-мастера и скрам-владельца продукта. <br>
                                  Диаграмма сгорания работ для спринта — показывает, сколько задач сделано и сколько
                                  еще остается сделать в текущем спринте
                              </li>
                          </ul>
                      </li>
                  </ul>
                  
              </details>
              <details><!--Lean-->
                  <summary>Lean</summary>
                  <ul>
                      <li>Основатель Toyota - Киитиро Тойода разработал методологию бережливого производства после Второй мировой войны
                          для экономии ресурсов и устранения потерь.</li>
                      <li>Методология бережливого производства опирается на два столпа, которые обеспечивают основу 
                          для всех проектов бережливого производства: постоянное совершенствование и уважение к людям.</li>
                      <li><ol>Принципы методологии Lean:
                          <li>Определите ценность</li>
                          <li>Составьте карту потока создания ценности</li>
                          <li>Создайте поток</li>
                          <li>Установить притяжение</li>
                          <li>Стремитесь к совершенству</li>
                      </ol></li>
              </details>
              <details><!--FDD-->
                  <summary>Feature Driven Development (FDD)</summary>
                  <p>Организует разработку программного обеспечения вокруг улучшения фичи. <br>
                      Однако фичи в контексте FDD не обязательно являются фичами продукта в общепринятом понимании. <br>
                      Они, скорее, больше похожи на пользовательские истории в Scrum.</p>
                  <ol>Жизненный цикл проекта:
                      <li>Разработать общую модель</li>
                      <li>Создайте список функций</li>
                      <li>Планирование по функциям</li>
                      <li>Дизайн по функциям</li>
                      <li>Создавать по функциям</li></ol>
              </details>
              <details><!--SAFe-->
              <summary>Scaled Agile Framework (SAFe)</summary>
              Представляет собой набор организационных шаблонов и шаблонов рабочих процессов для реализации практик Agile в масштабе предприятия .
              </details>
          </details>
      </div>
  </details>
  <details class="menu__item"><!-- Quality -->
      <summary>Quality</summary>
      <div class="menu__inner">
          <p>
              9 сентября - день тестировщика. <br>
              09.09.1947 - первый баг. <br>
              <dfn>QM</dfn>  - Quality management = QA + QC<br>
              <dfn>QA</dfn>  - Занимается вся команда, возможно с привлечением консультанта.<br>
                  - Верификация. Настраивает систему тестирования, пишет документацию. <br>
                  - Определяет какую документацию будет делать команда, какие характеристики в приоритете и т.д. <br>
              <dfn>QC</dfn>  - Занимаються тестировщики. <br>
                  - Валидация. Тест-дизайн. Тест-аналитик.<br>
                  - Пишет тестовую документацию и анализирует результаты тестирования. <br>                
              <dfn>Tester</dfn> - Выполнение тест-кейсов. Часть QC.
          </p>
          <details><!-- Качество -->
              <summary>Качество</summary>
              <p>Качество - это степень соответствия системы, компонента или процесса,
                  явным и неявным требованиям, в рамках установленного срока и бюджета.
              </p>
          </details>
          <details><!-- Характеристики качества -->
              <summary>Характеристики качества</summary>
              <details><!-- Функциональность -->
                  <summary>Функциональность - способность ПО решать задачи, которые
                      соответствуют зафиксированным и предполагаемым
                      потребностям пользователя, при заданных условиях</summary>
                      - Функциональная исправимость.
                      - Соответствие стандартам.
                      - Функциональная совместимость.
                      - Безопасность.
                      - Точность.
                  <details>
                      <summary>Функциональная полнота:</summary>
                      <p>
                          - Способность ПО покрывать все задачи и цели пользователя. <br>
                          - Все ли функции выполняет ПО для выполнения своих задач.
                      </p>
                  </details>
                  <details>
                      <summary>Функциональная правильность:</summary>
                      <p>
                          - Способность продукта обеспечивать правильные результаты с необходимой степенью точности. <br>
                          - Например у банковского ПО точность должна быть до копейки.
                      </p>
                  </details>
                  <details>
                      <summary>Функциональная целесообразность:</summary>
                      <p>
                          - Степень, в которой функции облегчают выполнение указанных задач и целей. <br>
                          - Насколько это ПО нужно для выполнения заданных задач.
                      </p>
                  </details>
              </details>
              <details><!-- Производительность -->
                  <summary>Производительность - cпособность ПО обеспечивать требуемый уровень производительности в соответствие
                      с выделенными ресурсами,временем и другими обозначенными условиями</summary>
                      - Эффективность по времени. <br>
                      - Эффективность использования ресурсов.
                      <details>
                          <summary>Временные характеристики:</summary>
                          <p>- Способность продукта или системы обеспечивать
                              достаточное время отклика, пропускную способность и скорость при выполнении своих функций</p>
                      </details>
                      <details>
                          <summary>Утилизация ресурсов:</summary>
                          <p>
                              - Степень соответствия количества и типов ресурсов,
                              используемых продуктом или системой при выполнении своих функций. <br>
                              - Утечка памяти, сколько ресурсов потребляет в работе.
                          </p>
                      </details>
                      <details>
                          <summary>Емкость:</summary>
                          <p>
                              - Соответствие лимитов производительности системы заявленным в требованиях. <br>
                              - Количественные показатели: какой объём данных обрабатывает, сколько пользователей.
                          </p>
                      </details>
              </details>
              <details><!-- Удобство использования -->
                  <summary>Удобство использования - возможность легкого понимания, изучения, использования и привлекательности ПО
                      для пользователя</summary>
                      - Удобство изучения. <br>
                      - Понятность. <br>
                      - Удобство и простота использования.
                  <details>
                      <summary>Определимость пригодности:</summary>
                      <p>
                          Как быстро пользователи могут определить подходит ли система для выполнения их целей и задач
                      </p>
                  </details>
                  <details>
                      <summary>Обучаемость:</summary>
                      <p>
                          Насколько быстро новый пользователь может разобраться с системой
                          использовать максимальное количество ее возможностей (подсказки, инструкции)
                      </p>
                  </details>
                  <details>
                      <summary>Управляемость:</summary>
                      <p>
                          Насколько интерфейс системы облегчает выполнение задач пользователя
                      </p>
                  </details>
                  <details>
                      <summary>Защищенность от ошибок пользователя:</summary>
                      <p>
                          Насколько сильно система защищает пользователей от ошибок (подсказки и валидация действий пользователя)
                      </p>
                  </details>
                  <details>
                      <summary>Эстетика пользовательского интерфейса:</summary>
                      <p>
                          Насколько привлекательный для пользователя дизайн имеет система
                      </p>
                  </details>
              </details>
              <details><!-- Совместимость -->
                  <summary>Совместимость - способность системы обмениваться информацией с другими системами или выполнять 
                      свои функции используя совместно аппаратную или програмную среду</summary>
                  <details>
                      <summary>Interoperability:</summary>
                      <p>
                          - Способность системы обмениваться информацией с другими системами, а также использовать полученную информацию<br>
                          - Передаваемая нашим ПО информация хорошо воспринимается другим ПО.
                      </p>
                  </details>
                  <details>
                      <summary>Сосуществование:</summary>
                      <p>
                          - Способность системы эффективно выполнять свои задачи при
                          совместном использовании общей среды и ресурсов с другими продуктами без
                          вредного воздействия на любой другой продукт. <br>
                          - Наше ПО не влияет на работу другого ПО и наоборот.
                      </p>
                  </details>
              </details>
              <details><!-- Надежность -->
                  <summary>Надежность - Способность ПО выполнять требуемые задачи в обозначенных условиях на протяжении
                      заданного промежутка времени или указанное количество операций</summary>
                      - Завершенность. <br>
                      - Восстанавливаемость. <br>
                      - Устойчивость к отказам.
                  <details> 
                      <summary>Доступность:</summary>
                      <p>
                          Доступность системы, продукта или компонента, когда это необходимо для использования
                      </p>
                  </details>
                  <details>
                      <summary>Отказоустойчивость:</summary>
                      <p>
                          Способность системы работать, как предполагалось, несмотря на наличие аппаратных или программных сбоев
                      </p>
                  </details>
                  <details>
                      <summary>Восстанавливаемость:</summary>
                      <p>
                          Насколько быстро система может восстановить данные и свою работоспособность при сбоях
                      </p>
                  </details>
              </details>
              <details><!-- Безопасность -->
                  <summary>Безопасность - Способность системы обеспечивать доступ только к тем данным, которые разрешены для 
                      пользователя или других систем в соответствии с их правами</summary>
                  <details>
                      <summary>Конфиденциальность:</summary>
                      <p>
                          - Способность системы предоставлять доступ к данным только тем, кто имеет на это право
                      </p>
                  </details>
                  <details>
                      <summary>Целостность:</summary>
                      <p>
                          - Способность системы предотвращать несанкционированный доступ или модификацию данных
                      </p>
                  </details>
                  <details>
                      <summary>Ответственность:</summary>
                      <p>
                          - Способность отслеживать и идентифицировать инициатора любого действия
                      </p>
                  </details>
                  <details>
                      <summary>Подлинность:</summary>
                      <p>
                          - Степень, в которой личность субъекта или ресурса может быть доказана как заявленная
                      </p>
                  </details>
              </details>
              <details><!-- Сопровождаемость -->
                  <summary>Сопровождаемость - легкость, с которой ПО может анализироваться, тестироваться, изменяться для исправления
                      дефектов, для реализации новых требований, для облегчения дальнейшего обслуживания и
                      адаптироваться к имеющемуся окружению</summary>
                  - Стабильность. <br>
                  - Анализируемость. <br>
                  - Контролепригодность. <br>
                  - Изменяемость.
                  <details>
                      <summary>Модульность:</summary>
                      <p>
                          - Степень, в которой система состоит из отдельных компонентов, так что
                          изменение одного компонента оказывает минимальное влияние на другие
                          компоненты. <br>
                          - Возможность многократного использования.
                      </p>
                  </details>
                  <details>
                      <summary>Анализируемость:</summary>
                      <p>
                          - Насколько просто оценить влияние потенциального изменения на
                          другие компоненты системы
                      </p>
                  </details>
                  <details>
                      <summary>Модифицируемость:</summary>
                      <p>
                          - Насколько легко добавить или изменить функционал ПО.
                      </p>
                  </details>
                  <details>
                      <summary>Тестируемость:</summary>
                      <p>
                          - Насколько просто установить критерии тестирования и выполнять
                          тестирование
                      </p>
                  </details>
              </details>
              <details><!-- Переносимость -->
                  <summary>Переносимость - характеризует ПО с точки зрения легкости его переноса из одного окружения
                      (software/hardware) в другое.</summary>
                  - Удобство установки. <br>
                  - Заменяемость. <br>
                  - Совместимость.
                  <details>
                      <summary>Адаптивность:</summary>
                      <p>
                          - Способность системы адаптироваться к разным окружениям и средам
                      </p>
                  </details>
                  <details>
                      <summary>Устанавливаемость:</summary>
                      <p>
                          - Способность системы разворачиваться и устанавливаться в различных окружениях и средах
                      </p>
                  </details>
                  <details>
                      <summary>Заменяемость:</summary>
                      <p>
                          - Способность системы заменять другие системы со схожей функциональностью
                      </p>
                  </details>
              </details>
          </details>
          <details><!-- Качества тестировщика -->
              <summary>Качества тестировщика:</summary>
              <ol>
                  <li>Саморазвитие</li>
                  <li>Внимательность</li>
                  <li>Любопытсво</li>
                  <li>Подозрительность</li>
                  <li>Поставить себя на место пользователя</li>
                  <li>Небезразличие</li>
                  <li>Исследовательский склад ума</li>
                  <li>Логическое мышление</li>
                  <li>Умение концентрироваться</li>
                  <li>Аналитические способности</li>
                  <li>Визуализация</li>
                  <li>Креативность</li>
                  <li>Изобретательность</li>
                  <li>Коммуникабельность</li>
                  <li>Ответственность</li>
                  <li>Инициативность</li>
                  <li>Упорство</li>
                  <li>Трудолюбие</li>
                  <li>Увлечённость</li>
                  <li>Настойчивость</li>
              </ol>
              <p>
                  Цель тестировщика - делать продукт лучше, а людей счастливее. <br>
                  Задача тестировщика - находить баги. <br>
                  Тестировщик оценивает и измеряет качество.
              </p>
          </details> 
          <details><!-- Bug -->
              <summary>Bug</summary>
              <details>
                  <summary>Люди совершают ошибки (Error)</summary>
                  <p>
                      Ошибка - человеческое действие, которое приводит к неправильному
                      результату (ISTQD)
                  </p>
              </details>
              <img src="../img/qc/def.png" alt="">
              <details>
                  <summary>Ошибка в коде или архитектуре программы - это дефект (Defect)</summary>
                  <p>
                      Дефект - несовершенство или недостаток в рабочем продукте, если он
                      не соответствует его требованиям или спецификациям (ISTQD)
                  </p>
              </details>
              <details>
                  <summary>Дефект может привести к отказу (Failure)</summary>
                  <p>
                      Отказ - событие, при котором компонент или система не выполняет
                      требуемое действие в заданных рамках (ISTQD)
                  </p>
              </details>
              <details>
                  <summary>Пример дефектов:</summary>
                  <p>
                      - Программа не делает чего-то, что она должна делать согласно техническим требованиям<br>
                      - Программа делает что-то, чего она не должна делать согласно техническим требованиям<br>
                      - Программа не делает чего-то, о чем не говорится в требованиях, однако подразумевается,
                      что она должна делать это<br>
                      - Программа трудна для понимания, неудобна в использовании<br>
                  </p>
                  <img src="../img/qc/DLC.png" alt="">
              </details>
          </details>
          <details><!-- Верификация -->
              <summary>Верификация</summary>
              <p>QA занимается Верификацией! <br>
                  - Проверка выполнения требований к процессу разработки ПО. <br>
                  - Подтверждение на основе представления объективных свидетельств того,
                  что установленные требования были выполнены<br>
                  - Делаем ли мы продукт ПРАВИЛЬНО?<br>
                  <br>
                  <em>QA - Quality Assurance:</em> <br>
                  - гарантирует, что мы делаем правильные шаги в правильном направлении <br>
                  - фокусируется на создании системы качества и привентирования дефектов <br>
                  - имеет дело с процессом создания продукта <br>
                  - на весь SDLC <br>
                  - это процесс упреждения <br>
              </p>
              <ul>Применяется к документации:
                  <li>Планы</li>
                  <li>Требованиям</li>
                  <li>Дизайну</li>
                  <li>Коду</li>
                  <li>Тест Кейсам</li>
              </ul>
              <ul>Основные активности:
                  <li>Reviews</li>
                  <li>Walkthroughs</li>
                  <li>Inspections</li>
              </ul>
              <img src="../img/qc/Must know QA.JPG" alt=""> <br>
              <img src="../img/qc/Must know QA_.JPG" alt=""> <br>
          </details>
          <details><!-- Валидация -->
              <summary>Валидация</summary>
              <p>
                  - Проверка выполнения требований к продукту. <br>
                  - Подтверждение на основе представления объективных свидетельств того, что требования,
                  предназначенные для конкретного использования или применения, выполнены <br>
                  - Делаем ли мы ПРАВИЛЬНЫЙ продукт?<br>
                  - QС занимается Валидацией!<br>
                  - Применяется к разрабатываемому продукту<br>
                  - Основнае активность тестирование<br>
                  <em>QC - Quality Control:</em>
                  - гарантирует, что результат нашей работы соответствует ожидаемому<br>
                  - фокусируется на тестировании и обнаружении дефектов<br>
                  - имеет дело с продуктом<br>
                  - на этапе тестирования в SDLC<br>
                  - это процесс исправления<br>
              </p>
          </details>
      </div>
  </details>
  <details class="menu__item"><!-- Testing -->
      <summary>Testing</summary>
      <div class="menu__inner">
          <p><dfn>Тестирование</dfn> - <i>процесс исследования, испытания продукта с целью проверки соответствия между 
              реальным поведением и ожидаемым на конечном наборе тестов, выбранных определенным образом.</i>
          <br>
          <img src="../img/qc/manual testing.png" alt=""> <br>
          Всегда перед тестированием спросить какие есть требования. <br>
          Если нет требований, то ищем требования похожего предмета тестирования, основываемся на общую практику 
          и опыт пользователя. <br>
          Пишем свои требования. <br>
          Нефункциональное тестирование без требований не проводят. <br>
          Первым всегда выполняем <dfn>Smoke Testing</dfn> - <i>проверяем самый основной функционал.</i> <br>
          Всегда сначала пишем и выполняем позитивные тесты. <br>
          Приоритет составления (выполнения) тест-кейсов определяется вопросом: что мы теряем если оно не работает? <br>
          Чем более вероятен сценарий, тем более он приоритетен. <br>
          Так таковых видов тестирования нет. <br>
          <img src="../img/qc/testtype.png" alt=""> <br>
          Всё тестирование разделяется на уровни и типы тестирования.
          </p>
          <details><!-- Цели тестирования -->
          <summary>Цели тестирования:</summary>
          <ul>
              <li>Повышение качества ПО</li>
              <li>Предотвращение появления дефектов</li>
              <li>Предоставление информации о качестве ПО конечному заказчику</li>
          </ul>
          </details>
          <details><!-- Принципы тестирования -->
          <summary>Принципы тестирования:</summary>
          <ol>(<i>Парадигмы тестирования</i>)
              <li>Тестирование демонстрирует наличие дефектов: <br>
                  естирование может показать, что дефекты присутствуют, но не может доказать, что их нет.
                  Тестирование снижает вероятность наличия дефектов, находящихся в программном обеспечении,
                  но, даже если дефекты не были обнаружены, тестирование не доказывает его корректности
              </li>
              <li>Исчерпывающее тестирование недостижимо: <br>
                  Полное тестирование с использованием всех комбинаций вводов и предусловий физически
                  невыполнимо, за исключением тривиальных случаев. Вместо попытки исчерпывающего
                  тестирования должны использоваться анализ рисков, методы тестирования и расстановка
                  приоритетов, чтобы сосредоточить усилия по тестированию
              </li>
              <li>Раннее тестирование: <br>
                  Для нахождения дефектов на ранних стадиях, как статические, так и динамические
                  активности по тестированию должны быть начаты как можно раньше в жизненном цикле
                  разработки программного обеспечения
              </li>
              <li>Кластеризация дефектов: <br>
                  Обычно небольшое количество модулей содержит большинство дефектов, обнаруженных 
                  во время тестирования перед выпуском, или отвечает за большинство эксплуатационных
                  отказов <br>
                  Принцип Парето: Из общего количества возможных тестов всегда необходимо выбирать 
                  20% таких, которые найдут 80% всех багов
              </li>
              <li>Парадокс пестицида: <br>
                  Если одни и те же тесты будут выполняться снова и снова, в конечном счете эти тесты
                  больше не будут находить новых дефектов. Для обнаружения новых дефектов может
                  потребоваться изменение существующих тестов и тестовых данных, а также написание новых
                  тестов.
              </li>
              <li>Тестирование зависит от контекста: <br>
                  Тестирование выполняется по-разному в зависимости от контекста. Например, программное
                  обеспечение управления производством, в котором критически важна безопасность,
                  тестируется иначе, чем мобильное приложение электронной коммерции
              </li>
              <li>Заблуждение об отсутствии ошибок: <br>
                  Нахождение и исправление дефектов не поможет, если ПО не удовлетворяет потребности 
                  и нужды пользователя
              </li>
          </ol>
          </details>
          <details><!-- Уровни тестирования -->
          <summary>Уровни тестирования:</summary>
          <p>
              <img src="../img/qc/typesLevels.png" alt=""> <br>
              Уровни тестирования разделяются по времени тестирования и по изолированности компонентов.
              <ul>Группы активностей тестирования, которые организуются и управляются как единое целое.
                  Каждый уровень тестирования — это реализация процесса тестирования, состоящего из мероприятий STLC,
                  и исполняемого в отношении ПО, находящегося на конкретном уровне разработки, начиная с отдельных модулей
                  и компонентов и заканчивая целыми системами
                  <li>Компонентное тестирование (Unit Testing) - фокусируется на компонентах, которые могут быть проверены отдельно.
                      <ul>Типичными объектами для компонентного тестирования являются:
                          <li>Компоненты, модули</li>
                          <li>Код и структуры данных</li>
                          <li>Классы</li>
                          <li>Модули БД</li>
                          Выполняется в основном разработчиками
                      </ul>
                  </li>
                  <br>
                  <li>Интеграционное тестирование (Integration Testing) - фокусируется на взаимодействии между компонентами или системами
                      <ul>Типичными объектами тестирования при интеграционном тестировании являются:
                          <li>Подсистемы</li>
                          <li>Базы данных</li>
                          <li>Инфраструктура</li>
                          <li>Интерфейсы</li>
                          <li>Программные интерфейсы приложения (API)</li>
                          <li>Микросервисы</li>
                      </ul>
                      <br>
                      <ul>Уровни интеграционного тестирования:
                          <li>Компонентный интеграционный уровень (Component Integration testing) - проверяется
                              взаимодействие между компонентами системы после проведения компонентного тестирования <br>
                              Выполняется в основном разработчиками
                          </li>
                          <li>Системный интеграционный уровень (System Integration Testing) - проверяется взаимодействие между разными
                              системами после проведения системного тестирования <br>
                              Выполняется в основном тестировщиками
                          </li>
                      </ul>
                  </li>
                  <li>Системное тестирование (System Testing – ST) - фокусируется на поведении и возможностях целой системы или продукта,
                      часто учитывая сквозные задачи, которые может выполнять система, и нефункциональное поведение, которое она
                      демонстрирует при выполнении этих задач
                      <ul>Типичные объекты системного тестирования включают:
                          <li>Приложения</li>
                          <li>Аппаратные / программные системы</li>
                          <li>Тестируемая система</li>
                          <li>Операционные системы</li>
                          <li>Конфигурация системы и конфигурация данных</li>
                          Выполняется в основном тестировщиком
                      </ul>
                  </li>
                  <li>Приемочное тестирование, как и системное тестирование, обычно фокусируется на поведении и возможностях системы
                      или продукта в целом
                      <ul>Типичными формами приемочного тестирования являются:
                          <li>Пользовательское приемочное тестирование (User Acceptance Testing – UAT) - обычно сосредоточено на проверке
                              пригодности использования системы предполагаемыми пользователями в реальной или моделируемой рабочей среде</li>
                          <li>Эксплуатационное приемочное тестирование</li>
                          <li>Контрактное и нормативное приемочное тестирование</li>
                          <li>Альфа-тестирование и бета-тестирование - обычно используются разработчиками готовых коммерческих решений,
                              которые хотят получить обратную связь от потенциальных или существующих пользователей, клиентов и/или
                              операторов до того, как программный продукт будет выставлен в коммерческую продажу.
                          </li>
                          Выполняется в основном клиентами, заказчиками, пользователями
                      </ul>
                  </li>
              </ul>
              <ul>Системное и приемочное тестирование:
                  <li>системное проверяет на соответствие системы требованиям.</li>
                  <li>приемочное проверяет систему с точки зрения пользования системой</li>
                  <li>тесты в системном и приёмочном тестировании очень похожи,
                      разница в формулировки теста.</li>
              </ul>
              <ul>Unit testing: <br>
                  <li>выполняется до других видов тестирования</li>
                  <li>модуль не полагается на внешний код или функции</li>
                  <li>состоит из 3-х ступеней:
                      - подготовка и обзор модуля <br>
                      - сделать test cases and scripts <br>
                      - провести тест кода
                  </li>
              </ul>
              Проверка безопасти - это проверка возможности обхода обычных путей использования и/или функционала.
          </p>
          </details>
          <details><!-- Типы тестирования -->
          <summary>Типы тестирования:</summary>
          <p>
              <img src="../img/qc/typesTest.png" alt="">
              Типы тестирования разделяются в зависимости от цели тестирования.
              <ul>Тип тестирования – это совокупность активностей тестирования, направленных на тестирование заданных характеристик
                  системы или ее части, основываясь на конкретных целях
                  <li>Функциональное тестирование (Functional testing) системы включает тесты по оценке функций, которые должна выполнять
                      система. Проверка того, «что делает система» <br>
                      Тестирование на основе требований выполняется в строгом соответствии с установленными требованиями. <br>
                      Тестирование на основе бизнес-процесса выполняется в соответствии с знаниями, основанными на повседневном использовании системы в бизнесе.
                  </li>
                  <li>Нефункциональное тестирование (Non Functional testing) Нефункциональное тестирование системы выполняется
                      для оценки таких характеристик системы и программного обеспечения, как удобство использования,
                      производительность или безопасность Проверка того, «насколько хорошо работает система»
                      <ul>Основные подтипы нефункционального тестирования:
                          <li>Производительности (Performance) - намеревается определить, как система работает с точки зрения быстроты
                              реагирования и стабильности при определенной нагрузке.
                              <ul>Характеристики:
                                  <li>Время отклика (response time)</li>
                                  <li>Пропускная способность (throughput)</li>
                                  <li>Способность к параллеливанию (concurrency)</li>
                                  <li>Доступность (availability, uptime)</li>
                                  <li>Потребление ресурсов (resource utilization)</li>
                                  <li>Потенциальная мощность (capacity)</li>
                              </ul>
                              <ul>Виды тестирования производительности:
                                  <li>Нагрузочное тестирование (Load testing) – оценка поведения системы при различных нагрузках,
                                      обычно между ожидаемыми условиями низкого, типичного и пикового использования</li>
                                  <li>Стресс-тестирование (Stress testing) – оценка поведения системы в пределах или за пределами ожидаемых или заданных рабочих
                                      нагрузок или с ограниченной доступностью ресурсов, таких как доступ к памяти или серверам</li>
                                  <li>Объемное тестирование (Volume testing) – позволяет анализировать производительность системы за счет
                                      увеличения объема данных в базе данных</li>
                                  <li>Тестирование стабильности (Stability testing)</li>
                                  <li>Тестирование параллелизма (Concurrency testing)</li>
                                  <li>Тестирование на масштабируемость (Scalability testing)</li>
                                  <li>Тестирование на выносливость (Endurance testing)</li>
                              </ul>
                              <img src="../img/qc/Performance.png" alt="">
                              <ul>быстро или медленно
                                  <li>меньше 0.1 секунды - мгновенно</li>
                                  <li>меньше секунды - быстро</li>
                                  <li>меньше 2 секунд - достаточно быстро</li>
                                  <li>2-4 секунды - приемлемо</li>
                                  <li>4-15 секунды - медленно</li>
                                  <li>больше 15 секунд - очень долго</li>
                              </ul>
                              <ul>Классификация проблем:
                                  <li>медленная подсистема/функция
                                      (например медленно загружается страница или выполняется скрипт)</li>
                                  <li>точка насыщения/"узкое горлышко"
                                      (например, пропускная способность сети или очереди для запросов, когда исчерпывается длина
                                      этой очереди и начинаются отказы)</li>
                                  <li>функциональный дефект
                                      (когда несколько систем используют один объект и одновременно меняют его состояние)</li>
                                  <li>дефект интерфейса
                                      (восстановление от ошибки - тесно граничит с UX тестированием)</li>
                              </ul>
                              <ul>Требования к производительности:
                                  <li>стала ли новая версия работать быстрее?</li>
                                  <li>что тормозит - софт или железо?</li>
                                  <li>почему пользователи не завершают заказы?</li>
                                  <li>выдержит ли сервер?</li>
                                  <li>какое состояние приложения?</li>
                              </ul>
                              <ul>Цели тестирования:
                                  <li>сравнить две версии приложения</li>
                                  <li>найти причину проблемы с производительностью</li>
                                  <li>оценить потенциальные возможности</li>
                                  <li>получить подтверждение, что все хорошо</li>
                              </ul>
                              <ul>Проектирование тестов:
                                  <li>Выясняем цели</li>
                                  <li>Описываем требования и условия</li>
                                  <li>Формулируем гипотезу для проверки</li>
                                  <li>Описываем профиль нагрузки</li>
                                  <li>Делаем сценарии для профиля нагрузки</li>
                              </ul>
                              <ul>Как выбрать операцию?
                                  <li>Критически важные (например, авторизация)</li>
                                  <li>Связанные с рисками (например, возврат средств)</li>
                                  <li>Требуемые заказчиком (например, есть просадки по завершению оплаты)</li>
                                  <li>Часто используемые (например, поиск товаров)</li>
                                  <li>Ресурсоемкие (например, получение архива)</li>
                              </ul>
                              <img src="../img/qc/perfor.png" alt="">
                              <ul>Профиль нагрузки - это подбор сценариев (объединение логических действий) для
                                  эмулирования нагрузки на ресурс.
                                  <li>Количество пользователей</li>
                                  <li>Количество сценариев</li>
                                  <li>Количество запросов (транзакций)</li>
                                  <li>Задержки между запросами (помогают регулировать количество операций)</li>
                                  <li>Задержки между транзакциями (группами запросов, например загрузка страницы, так как
                                      пользователь читает инфу, заполняет данные и тд)
                                  </li>
                              </ul>
                              <p>Запрос - одна операция <br>
                                  Транзакция - группа операций/запросов <br>
                                  Сценарий - группа транзакций (например переходы по нескольким страницам сайта)
                              </p>                             
                          </li>
                          <li>Пользовательского интерфейса (UI)</li>
                          <li>Удобства использования (Usability)</li>
                          <li>Безопасности (Security): <br>
                              <ul>Тестирование безопасности (Security Testing) направлено на то, чтобы обеспечить информационную систему
                                  защитой данных и поддерживать функциональность по назначению
                                  <li>Тестирование проникновения (Penetration Testing) – это симуляция атаки вредоносного источника,
                                      которое позволяет оценить безопасность компьютерной системы или сети</li>
                                  <li>XSS (Cross-SiteScripting) — это вид уязвимости программного обеспечения (Web приложений),
                                      при которой, на генерированной сервером странице, выполняются вредоносные скрипты</li>
                                  <li>XSRF / CSRF (RequestForgery) — это вид уязвимости, позволяющий использовать недостатки HTTP 
                                      протокола. Злоумышленники работают по следующей схеме: ссылка на вредоносный сайт устанавливается
                                      на странице, пользующейся доверием у пользователя, при переходе по вредоносной ссылке выполняется
                                      скрипт, сохраняющий личные данные пользователя (пароли, платежные данные и т.д.), либо отправляющий
                                      СПАМ сообщения от лица пользователя, либо изменяет доступ к учетной записи пользователя,
                                      для получения полного контроля над ней
                                  </li>
                                  <li>Code injections (SQL, PHP, ASP и т.д.) — это вид уязвимости, при котором становится возможно
                                      осуществить запуск исполняемого кода с целью получения доступа к системным ресурсам,
                                      несанкционированного доступа к данным либо выведения системы из строя</li>
                                  <li>AuthorizationBypass — это вид уязвимости, при котором возможно получить несанкционированный доступ
                                      к учетной записи или документам другого пользователя</li>
                              </ul>
                          </li>
                          <li>Конфигурации (Configuration)</li>
                          <li>Локализации (Localization)</li>
                          <li>Совместимости (Compatibility)</li>
                      </ul>
                  </li>
                  <li>Структурное тестирование (тестирование методом белого ящика – White Box Testing) основывается на внутренней
                      структуре системы или ее реализации. Под внутренней структурой подразумевается программный код, архитектура,
                      принципы работы и/или потоки данных внутри системы
                      <ul>
                          <li>Statement Coverage проверяет, что каждый оператор в
                              программе выполняется хотя бы один раз во время
                              тестирования программы.</li>
                          <li>Path Coverage предназначен для удовлетворения
                              критериев охвата каждого логического пути через
                              программу.</li>
                          <li>Branch Coverage проверяет, имеют ли каждое условие
                              ветвления для программы истинные или ложные
                              значения.</li>
                          <li>Condition Coverage похоже на Branch Coverage.
                              Основное различие заключается в проверке состояния
                              покрытия для условных и не условных ветвей.</li>
                      </ul>
                  </li>
                  <li>Tестирование связанное с изменениями: <br>
                      Когда в систему вносятся изменения, выполненные для исправления дефекта, либо из-за новой или изменяющейся
                      функциональности, необходимо провести тестирование, чтобы подтвердить, что изменения исправили дефект или
                      что функциональность правильно реализована и изменения не вызвали каких-либо непредвиденных неблагоприятных
                      последствий.
                      <ul>
                          <li>Дымное тестирование (Smoke testing) – Набор
                              тестов, который охватывает основные функции
                              компонента или системы, чтобы определить,
                              работает ли он должным образом до начала
                              запланированного тестирования</li>
                          <li>Подтверждающее тестирование (Confirmation
                              testing, Re-test) – после того как дефект исправлен,
                              программное
                              обеспечение может быть протестировано с
                              использованием всех тех же тестовых
                              сценариев, которые завершились с ошибкой из-за
                              найденного дефекта</li>
                          <li>Санитарное тестирование (Sanity testing) - используется с целью
                              доказательства работоспособности конкретной
                              функции или модуля согласно заявленным
                              техническим требованиям. Зачастую санитарное
                              тестирование используют для проверки какой
                              либо части программы или приложения в
                              результате внесенных изменений</li>
                          <li>Регрессионное тестирование (Regression testing) –
                              тестирование ранее протестированного
                              компонента или системы после модификации,
                              чтобы убедиться, что дефекты не были
                              обнаружены или были обнаружены в неизменных
                              областях программного обеспечения в результате
                              внесенных изменений. <br>
                              Регрессионное тестирование (Regression testing) проводится после того, как вся функциональность
                              реализована и все дефекты найденые на предыдущих уровнях исправлены или принято решениио их переносе.
                              Идеально начинать регрессию ПОСЛЕ заморозки кода (Code Freeze)
                          </li>
                      </ul>
                  </li>
              </ul>
          </p>
          </details>
          <details><!-- Техники тестирования -->
              <summary>Техники тестирования:</summary>
              <p>                                        
                  <img src="../img/qc/testTechnics.png" alt="">
                  <ul>
                      <li>Статическое тестирование <br>
                          тип техники тестирования, который предполагает, что программный код во время тестирования
                          не будет выполняться. При этом самотестирование может быть как ручным, 
                          так и автоматизированным
                          <ul>Виды статического тестирования:
                              <li>вычитка исходного кода программы;</li>
                              <li>проверка требований.</li>
                          </ul>
                      </li>
                      <br>
                      <li>Динамическое тестирование <br>
                          тип техники тестирования, который предполагает запуск
                          программного кода. Таким образом, анализируется поведение программы во
                          время ее работы.
                          <ul>Методы черного ящика: <br>
                              <img src="../img/qc/blackbox.png" alt="">
                              <li>Эквивалентное разделение (Equivalence Partitioning): <br>
                                  <ul>
                                      <li>Класс эквивалентности (equivalence class) – набор данных, обработка которых приводит
                                          к одному и тому же результату</li>
                                      <li>Разделение на классы эквивалентности – это техника, при которой функционал (диапазон
                                          возможных входных значений) разделяется на группы значений эквивалентных по воздействию
                                          на систему</li>
                                          <br>
                                          Пример: Есть поле с допустимым диапазоном значений ввода от 1 до 1000
                                          <img src="../img/qc/Equivalence.png" alt="">
                                  </ul>
                              </li>
                              <li>Анализ граничных значений (Boundary Value Analysis) - техника тест-дизайна, которая
                                  направлена на проверку поведения системы на граничных значениях входных данных (границах классов 
                                  эквивалентности)
                              </li>
                              <img src="../img/qc/Boundary.png" alt="">
                              <br>
                              <li>Метод попарного тестирования (Pairwise testing) – основан на следующей идее: подавляющее
                                  большинство багов, выявляются тестами, проверяющими либо один параметр, либо сочетание двух
                                  параметров</li>
                                  <img src="../img/qc/Pairwise.png" alt=""> <br>
                                  <a target="_blank" href="https://pairwise.teremokgames.com/">Тренировка</a>
                              <br>
                              <li>Таблица принятия решений (Decision table): <br>
                                  это способ компактного представления модели со сложной логикой. <br>
                                  Простыми словами, это варианты действий при различных входных условиях
                                  <ul>Шаги построения таблицы:
                                      <li>Определить/записать условия</li>
                                      <li>Посчитать количество возможных комбинаций условий: <br>
                                          N = n1 * n2 * ... * nm</li>
                                      <li>Заполнить комбинации</li>
                                      <li>Записать действия <br>
                                          <img src="../img/qc/Decision Table.png" alt="">
                                      </li>
                                  </ul>
                                  Используется для описания (и визуализации) сложных бизнес и системных требований <br>
                                  Помогают создавать тест кейсы (Условия – тестовые данный, Действия – Ожидаемый результат) <br>
                                  Не помогает ограничивать набор тестовых случаев
                              </li>
                              <br>
                              <li>Тестирование состояний и переходов (State - transition testing): <br>
                                  Диаграмма состояний и переходов (State transition diagrams) — показывает начальное и конечное
                                  состояния системы, а также описывает переходы между состояниями <br>
                                  <img src="../img/qc/State transition diagrams.png" alt=""> <br>
                                  Таблица состояний и переходов: <br>
                                  <img src="../img/qc/State transition tables.png" alt="">
                              </li>
                              <br>
                              <li>Тестирование по сценариям использования (Use case Testing): <br>
                                  Тестирование вариантов использования определяется как метод тестирования программного обеспечения,
                                  который помогает идентифицировать тестовые случаи, охватывающие всю систему,
                                  транзакция за транзакцией от начала до конечной точки.
                                  <a href="http://okiseleva.blogspot.com/2015/11/blog-post_86.html">Обзор</a><br>
                                  <img src="../img/qc/Use case Testing.png" alt="">
                              </li>                            
                          </ul>
                          <ul>Техники основанные на опыте:
                              <li>Предугадывание ошибок
                                  <ul>Предугадывание ошибок (Error Guessing) - это способ предотвращения ошибок, дефектов и отказов,
                                      основанный на знаниях тестировщика, включающих:
                                      <li>Историю работы приложения в прошлом</li>
                                      <li>Наиболее вероятные типы дефектов, допускаемых при разработке</li>
                                      <li>Типы дефектов, которые были обнаружены в схожих приложениях</li>
                                  </ul>
                              </li>
                              <li>Исследовательское тестирование: <br>
                                  Во время исследовательского тестирования неформальные (т.е. не созданные заранее)
                                  тестовые сценарии разрабатываются, выполняются, анализируются и оцениваются динамически
                                  во время выполнения тестов. <br>
                                  Результаты тестирования используются для изучения компонента или системы и последующей разработки
                                  тестовых сценариев для непокрытых областей.
                                  <a href="https://blog.noveogroup.ru/2018/06/issledovatelskoe-testirovanie-agile/">Обзор</a>
                              </li>
                              <li>Интуитивное тестирование (Ad-hoc testing) - это вид тестирования, который выполняется
                                  без подготовки к тестированию продукта, без определения ожидаемых результатов,
                                  проектирования тестовых сценариев. <br>
                                  Это неформальное, импровизационное тестирование</li>
                          </ul>
                      </li>
                  </ul>
              </p>
              <ul><dfn>workaround</dfn> - обходной путь при неработающем основном. На проекте нужно определять критерии оценки приоритета багов
                  <li>Описать баг</li>
                  <li>Воспроизвести шаги на других устройствах</li>
                  <li>Попробывать обопщить баг с другими случаями</li>
                  <li>Обопщенный вариант (если есть) пробуем воспроизвести на других устройствах</li>
              </ul>
          </details>
      </div>
  </details>
  <details class="menu__item"><!-- Test artifacts -->
      <summary>Test artifacts</summary>
      <div class="menu__inner">
      <details><!-- Требования -->
          <summary>Требования</summary>
          <p>
              Некое свойство программного обеспечения, необходимое пользователю, для решения проблемы при достижении поставленной цели. <br>
          Некое свойство программного обеспечения, которым должна обладать система или ее компонент, чтобы удовлетворить требования
          контракта, стандарта, спецификации либо иной формальной документации.
          <li>Могут быть:
              <ul>
                  <li>Прямыми(Формализованными в технической документации, спецификациях, User Story)</li>
                  <li>Косвенными(Проистекающими из прямых, либо являющиеся негласным стандартом для данной продукции или
                      основывающиеся на опыте и здравом смысле использования продукта или продуктов подобных ему)</li>
              </ul>
          </li>
          <li>Уровни требований:
              <ul>
                  <li>Бизнес-требования: <br> описание высокоуровневых целей организации или
                      заказчика, достигаемых посредством разрабатываемой
                      системы
                      <ul>Пример:
                          <li>Увеличить охват пользователей</li>
                          <li>Увеличить прибыль</li>
                          <li>Создать дополнительный канал продаж</li>
                      </ul>
                  </li>
                  <li>Требования заинтересованных лиц: <br> Формулировка потребностей определенного
                      заинтересованного лица или их группы. Кроме
                      потребности описывается также способ взаимодействия
                      ЗЛ с решением
                      <ul>Покупатель:
                          <li>Выбрать товар по определенным критериям</li>
                          <li>Сравнить разные товары</li>
                          <li>Купить товар с помощью кредитной карты</li>
                      </ul>
                      <ul>Администратор:
                          <li>Поддерживать перечень товаров в актуальном состоянии</li>
                          <li>Быстро отслеживать и управлять заказами</li>
                      </ul>
                  </li>
                  <li>Требования к решению:
                      <ul>
                          <li>Функциональные:
                              <ul>Покупатель должен иметь возможность:
                                  <li>Просмотреть список товаров</li>
                                  <li>Фильтровать товары</li>
                                  <li>Сравнивать товары между собой</li>
                                  <li>Добавлять товары в корзину</li>
                                  <li>Оформить заказ</li>
                              </ul>
                              <ul>Администратор должен иметь возможность:
                                  <li>Добавлять/удалять товар</li>
                                  <li>Менять цену</li>
                                  <li>Видеть заказы и менять ему статус</li>
                              </ul>
                          </li>
                          <li>Нефункциональные:
                              <ul>
                                  <li>Атрибуты качества
                                      <ul>Пример:
                                          <li>Время загрузки главной страницы и страницы товара – не выше 3 секунд</li>
                                          <li>База данных должна разворачиваться на основные СУБД без дополнительных изменений</li>
                                          <li>Сайт должен быть адаптирован под мобильные устройства</li>
                                      </ul>
                                  </li>
                                  <li>Ограничения в проектировании или реализации
                                      <ul>Пример:
                                          <li>Серверная часть должна быть написана на Java</li>
                                          <li>Сайт должен устанавливаться на ОС Ubuntu</li>
                                      </ul>
                                  </li>
                                  <li>Внешние интерфейсы
                                      <ul>Пример:
                                          <li>Поддержка платежных систем Visa и MasterCard</li>
                                          <li>Поддержка API социальных сетей</li>
                                      </ul>
                                  </li>
                              </ul>
                          </li>
                      </ul>
                  </li>
              </ul>
          </li>
          <li>Способы документации:
              <ul>Текстовый вид:
                  <li>Видение продукта (Product Vision)
                      <ul>
                          <li>Для (целевой заказчик/аудитория)</li>
                          <li>Которым (описание нужд или возможностей)</li>
                          <li>Продукт (имя, категория продуктов)</li>
                          <li>Который (ключевые выгоды, повод купить)</li>
                          <li>В отличие (главное отличие от конкурентов)</li>
                          <li>Наш продукт (главное преимущество)</li>
                      </ul>
                  </li>
                  <li>Пользовательская история (User story): <br>
                      Способ описания требований, к разрабатываемой системе, сформулированный, как одно или более предложений
                      на повседневном или деловом языке. <br>
                      Цель пользовательских историй состоит в том, чтобы быть в состоянии оперативно и без накладных затрат
                      реагировать на быстро изменяющиеся требования реального мира <br>
                      <img src="../img/qc/userStory1.png" alt="">
                      <img src="../img/qc/userStory2.png" alt="">
                  </li>
                  <li>Критерии приемки (Acceptance Criteria): <br>
                      это критерии, в том числе требования к рабочим характеристикам и основные условия, которые должны быть
                      выполнены чтобы результаты проекта были принятыми <br> Критерий приема = минимальное требование <br>
                      <img src="../img/qc/criteria.png" alt="">
                  </li>
                  <li>Сценарий использования (Use Case): <br>
                      это перечень действий, сценарий по которому пользователь взаимодействует с приложением, программой для
                      выполнения какого-либо действия для достижения конкретной цели
                      <ul>Пример:
                          <li>Пользователь захотел разместить объявление</li>
                          <li>Пользователь зашел в систему</li>
                          <li>Пользователь авторизовался в системе</li>
                          <li>Пользователь создал объявление</li>
                          <li>Система отобразила сообщение об успешном создании объявления</li>
                      </ul>
                  </li>
              </ul>
              <br>
              <ul>Графический вид:
                  <li>Макеты (Wireframe):
                      <ul>Вайрфрейм — это низко детализированное представление дизайна. Он чётко должен показывать:
                          <li>Основные группы содержимого. Что?</li>
                          <li>Информационную структуру. Где?</li>
                          <li>Описание взаимодействия пользователя с интерфейсом и его примерную визуализацию. Как?</li>
                          <img src="../img/qc/Wireframe.png" alt="">
                      </ul>
                  </li>
                  <li>Диаграммы (Diagrams): <br>
                      UML (англ. Unified Modeling Language — унифицированный язык моделирования) — язык графического описания
                      для объектного моделирования в области разработки программного обеспечения, для моделирования
                      бизнес-процессов, системного проектирования и отображения организационных структур
                      <img src="../img/qc/Diagrams.png" alt="">
                  </li>
              </ul>
          </li>
          <li>Требования к требованиям: <br>
              <ul>Основные проблемы требований:
                  <li>непонятность требований</li>
                  <li>частая изменяемость</li>
                  <li>изменения, вносимые в последний момент</li>
                  <li>неверная трактовка требований</li>
              </ul>
              <ul>Характеристики требований:
                  <li>Завершенность - Требование полностью определено в одном месте и вся необходимая информация присутствует</li>
                  <li>Последовательность - Требование не противоречит другим требованиям и полностью соответствует
                      внешней документации</li>
                  <li>Атомарность - Требование «атомарно». То есть оно не может быть разбито на ряд более детальных
                      требований без потери завершенности</li>
                  <li>Отслеживаемость - возможность отследить связь между требованием и другими артефактами проекта,
                      каждое требование имеет уникальный идентификатор, по которому оно легко прослеживается</li>
                  <li>Актуальность - Требование не стало устаревшим с течением времени</li>
                  <li>Выполнимость - Требование может быть реализовано в пределах проекта</li>
                  <li>Недвусмысленность - Требование кратко определено без обращения к техническому жаргону,
                      акронимам и другим скрытым формулировкам. <br>
                      Выражает объективные факты, не субъективные мнения. <br>
                      Возможна одна и только одна интерпретация. <br>
                      Определение не содержит нечётких фраз. <br>
                      Использование отрицательных утверждений и составных утверждений запрещено</li>
                  <li>Обязательность - Требование представляет определенную заинтересованным лицом характеристику,
                      отсутствие которой приводит к неполноценности решения, которая не может быть проигнорирована</li>
                  <li>Необязательное требование — противоречие самому понятию требования</li>
                  <li>Проверяемость – существует способ однозначной проверки выполнено требование или нет</li>
              </ul>
          </li>
          <br>
          <li>Техники тестирования требований:
              <ul>
                  <li>Взаимный просмотр:
                      <ul>
                          <li>беглый просмотр — автор показывает свою работу
                              коллегам, они в свою очередь дают свои
                              рекомендации, высказывают свои вопросы и
                              замечания</li>
                          <li>технический просмотр — выполняется группой
                              специалистов</li>
                          <li>формальная инспекция — привлекается большое
                              количество специалистов, представляет собой
                              структурированный, систематизированный и
                              документированный подход. Минус такого варианта
                              — тратится много времени</li>
                      </ul>
                  </li>
                  <li>Вопросы — если возникают вопросы, то можно спрашивать у представителей заказчика, более опытных коллег</li>
                  <li>Тест-кейсы и чек-листы — хорошее требование должно быть проверяемым, чтобы это определить можно
                      использовать чек-листы или полноценные тест-кейсы. <br>
                      Если можно быстро придумать несколько пунктов чек-листа — это уже хороший знак</li>
                  <li>Исследование поведения системы — необходимо мысленно смоделировать процесс работы пользователя с системой,
                      созданной по тестируемым требованиям, после этого определить неоднозначные варианты определения системы</li>
                  <li>Рисунки и прототипы — графическое представление дает наглядное представление приложения, на рисунке
                      проще увидеть, что какие-то элементы не стыкуются, где-то чего-то не хватает и т.д. <br>
                      Сделав наброски пользовательского интерфейса, легко оценить применение тех или иных пользовательских решений</li>
              </ul>
          </li>
          <ul>Пример: <br>
              <li>Шаг 1: <br>
                  <img src="../img/qc/example1.png" alt="">
              </li>
              <li>Шаг 2: <br>
                  <img src="../img/qc/Example2.png" alt="">
              </li>
              <li>Шаг 3: <br>
                  <img src="../img/qc/Example3.png" alt="">
              </li>
              <li>Шаг 4: <br>
                  <img src="../img/qc/Example4.png" alt="">
              </li>
              <li>Шаг 5: <br>
                  <img src="../img/qc/Example5.png" alt="">
              </li>
          </ul>
          </p>
      </details>
      <details><!-- Документация -->
          <summary>Документация</summary>    
          <p>Документация пишеться в passive voice.
              Тестовая документация бывает двух видов:
              <li>Внешняя
                  <ul>
                      <li>Отчет о дефекте (Bug or Defect Report) - это
                          документ, описывающий ситуацию или
                          последовательность действий приведшую к
                          некорректной работе объекта
                          тестирования, с указанием причин и
                          ожидаемого результата
                          <ul>Структура:
                              <li>Короткое описание (Summary)
                                  общее описание дефекта и наблюдаемого сбоя
                                  Очень важная часть дефекта, так как это первое, что менеджеры и разработчики видят
                              </li>
                              <li>Предусловия (Preconditions)</li>
                              <li>Компонент приложения (Component)</li>
                              <li>Номер версии (Version)</li>
                              <li>Серьезность (Severity)
                                  это атрибут, характеризующий влияние дефекта на работоспособность приложения. 
                                  Показывает технологическую степень влияния дефекта на ВСЮ СИСТЕМУ
                                  <img src="../img/qc/Severity.png" alt="">
                              </li>
                              <li>Приоритет (Priority)
                                  <ul>это атрибут, указывающий на очередность выполнения задачи или устранения дефекта.
                                      Чем выше приоритет, тем быстрее нужно исправить дефект
                                      Показывает степень важности выполнения задач для БИЗНЕСА
                                      <li>P1 Срочный (Urgent)</li>
                                      <li>P2 Высокий (High)</li>
                                      <li>P3 Средний (Medium)</li>
                                      <li>P4 Низкий (Low)</li>
                                  </ul>
                              </li>
                              <li>Статус (Status)</li>
                              <li>Автор (Reporter)</li>
                              <li>Описание (Description)
                                  <ul>Описание:
                                      <li>Шаги воспроизведения (Steps to Reproduce)</li>
                                      <li>Фактический Результат (Actual Result)</li>
                                      <li>Ожидаемый результат (Expected Result)</li>
                                  </ul>
                              </li>
                              <li>Вложения (Attachments)</li>
                          </ul>
                          <br>
                      </li>
                      <li>Запрос на изменение (Change Request)</li>
                      <li>Отчет о тестировании (Test Report)</li>
                  </ul>
              </li>
              <br>
              <li>Внутренняя
                  <ul>
                      <li>План тестирования (Test Plan)
                          <ul>Документ, описывающий весь объем работ по тестированию:
                              <li>описания объекта
                                  <ul>Хороший тест план должен как минимум описывать следующее:
                                      <li>Что будем тестировать?</li>
                                      <li>Как будем тестировать?</li>
                                      <li>Когда будете тестировать?</li>
                                  </ul>
                                  <ul>Объем тестирования (Scope of Work)
                                      <li>Что мы будем делать?</li>
                                      <li>Зачем?</li>
                                      <li>Для какого клиента?</li>
                                      <li>Кто будет использовать продукт?</li>
                                      <li>Для чего будет использоваться продукт?</li>
                                      <li>Какие компоненты и функции нужно протестировать, а какие тестироваться не будут</li>
                                  </ul>
                              </li>
                              <li>стратегии (Test Strategy)
                                  <ul>Наиболее важная часть документа. <br>Иногда даже может выноситься в отдельный документ. <br>
                                      Стратегия тестирования определяет:
                                      <li>Процесс тестирования</li>
                                      <li>Уровни и типы тестирования</li>
                                      <li>Роли и ответственность</li>
                                      <li>Анализ рисков</li>
                                      <li>Тестовое окружение</li>
                                      <li>Используемые ресурсы</li>
                                      <li>Документация</li>
                                  </ul>
                              </li>
                              <li>расписание
                                  <ul>содержит в себе:
                                      <li>список необходимых задач, их последовательность</li>
                                      <li>оценка и сроки выполнения</li>
                                  </ul>
                              </li>
                              <li>критериев начала и окончания тестирования (Entry & Exit Criteria)
                                  <ul>Entry Criteria:
                                      <li>Готовность тестовой платформы (тестового стенда)</li>
                                      <li>Законченность разработки требуемого функционала</li>
                                      <li>Наличие всей необходимой документации</li>
                                  </ul>
                                  <ul>Exit Criteria:
                                      <li>Определенный процент критических кейсов пройден</li>
                                      <li>Нет открытых критических дефектов</li>
                                      <li>Прошло определенное время без открытия новых дефектов (Zero Bug Bounce)</li>
                                      <li>Закончились средства</li>
                                      <li>Наступил дедлайн</li>
                                  </ul>
                              </li>
                              <li>необходимого в процессе работы оборудования</li>
                              <li>специальных знаний</li>
                              <li>оценки рисков с вариантами их разрешения</li>
                              <li>Утверждение плана (Approvals)
                                  <ul>Для увеличения ценности вашего тест плана
                                      рекомендуется проводить его периодическое
                                      рецензирование со стороны участников
                                      проектной группы:
                                      <li>Ведущий тестировщик</li>
                                      <li>Тест менеджер (менеджер по качеству)</li>
                                      <li>Руководитель разработки</li>
                                      <li>Менеджер проекта</li>
                                  </ul>
                              </li>
                          </ul>
                          <br>
                          <ul>Примеры рисков:
                              <li>Ограниченность ресурсов</li>
                              <li>Недостаточная квалификация</li>
                              <li>Отсутствие документации</li>
                              <li>Поздние изменения</li>
                              <li>Проблемы сторонних решений</li>
                              <li>Контрактные проблемы</li>
                              <img src="../img/qc/risks.png" alt="">
                          </ul>
                          <ul>
                              Структура тест-плана: <br>
                              <img src="../img/qc/testPlan.png" alt="">
                          </ul>
                          <br>
                      </li>
                      <li>Список проверок (Check List)
                          <ul>это документ, описывающий что должно быть протестировано. <br>
                              При этом чек-лист может быть абсолютно разного уровня детализации. <br>
                              На сколько детальным будет чек-лист зависит от:
                              <li>Требований к отчётности</li>
                              <li>Уровня знания продукта сотрудниками</li>
                              <li>Сложности продукта</li>
                          </ul>
                          <ul>чек-лист нужен:
                              <li>Не забыть требуемые тесты</li>
                              <li>Для деления задач по уровню квалификации</li>
                              <li>Для сохранения отчётности и результатов тестирования</li>
                              <li>Замена тестовым случаям (Test Cases) в условиях нехватки времени</li>
                          </ul>
                          В целом, грамотно составленные списки в значительной степени могут эффективно справится с функциями
                          детально расписанных тест-кейсов. Именно поэтому не во всех случаях рациональным будет трата времени
                          на написание тест-кейсов. <br>
                          Решение о их необходимости (или же наоборот) является результатом тщательно обдуманного планирования
                          и не может быть универсальным для всех проектов. <br>
                          <img src="../img/qc/checkList1.png" alt="">
                          <img src="../img/qc/checkList2.png" alt="">
                          <img src="../img/qc/checkList3.png" alt="">
                          <img src="../img/qc/checkList4.png" alt="">
                          <img src="../img/qc/checkList5.png" alt="">
                      </li>
                      <li>Тестовый случай (Test case)
                          <ul>это совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации
                              тестируемой функции или её части. <br>
                              Тестовый случай состоит из:
                              <li>Уникальный идентификатор (ID)</li>
                              <li>Название (Description)</li>
                              <li>Предусловия (Precondition) – опционально</li>
                              <li>Шаги (Steps)</li>
                              <li>Ожидаемый результат (Expected result)</li>
                          </ul>
                          <ul>тест-кейсы нужны:
                              <li>Жизненно важные системы, ошибка в
                                  которых может привести к гибели
                                  (самолетостроение, медицина, ПО для
                                  атомных станций)</li>
                                  <li>При тестировании сложных систем или
                                      сложных частей системы, чтобы не
                                      запутаться в чек-листе</li>
                              <li>Планирование, и только потом – выполнение!</li>
                              <li>дают нам структурированный системный подход, что снижает вероятность пропуска ошибки.</li>
                              <li>хороший способ хранения части проектной информации.</li>
                              <li>один из способов протестировать проектную документацию еще до выхода первого билда</li>
                              <li>ускоряет регрессионное тестирование</li>
                              <li>Можно доверить выполнять новичку или призванному на помощь коллеге из другого отдела</li>
                              <li>можем в любой момент «вспомнить», что мы делали месяц, полгода, год назад</li>
                              <li>Тест-кейсы позволяют легко отслеживать прогресс: <br>
                                  - X% тестов выполнено <br>
                                  - Y% тестов прошло/завалилось <br>
                                  - Z% требований покрыто тестами
                              </li>
                          </ul>
                          <ul>тест-кейсы НЕ нужны:
                              <li>Простые системы (веб-сайты, мобильные приложения и т. п.)</li>
                              <li>Ситуации, когда в команде всего один или
                                  два тестировщика, знающие свой продукт.
                                  Время, потраченное на создание и
                                  поддержку тест-кейсов никогда не окупится</li>
                          </ul>
                          <ul>Преимущества тест-кейсов:
                              <li>Время (приоритизация проверок)</li>
                              <li>Более быстрое введение в проект новых
                                  людей или подключение коллег из других
                                  проектов для проведения сессии
                                  тестирования</li>
                              <li>Напоминание о конфигурировании и
                                  настройке системы</li>
                              <li>Незаменимы при работе над на
                                  «тяжелых» проектах</li>
                                  <li>Понимание информации одинаково
                                      всеми участниками процесса</li>
                                  <li>Напоминание о старой
                                      функциональности, которую все еще нужно
                                      тестировать</li>
                          </ul>
                          <ul>Недостатки тест-кейсов:
                              <li>Разные Test Case, для одного
                                  функционала очень похожи</li>
                              <li>Сложность поддержки</li>
                              <li>Неактуальное состояние</li>
                              <li>Следуя сценарию, можно упустить
                                  важные проблемы</li>
                              <li>Валидация небольшого кусочка
                                  функциональности</li>
                              <li>Тестировщик проверяет продукт, а не
                                  тестирует его</li>
                              <li>Тестировщики выключают мозг, проходя
                                  Test Case</li>
                              <li>Любой может выполнять их, они не
                                  заменяют опытных тестировщиков,
                                  которые могут тестировать</li>
                          </ul>
                      </li>
                      <li>Набор тестов (Test Suites) это перечень тестовых случаев (test case), которые объединены тем 
                          что относятся к одному тестируемому модулю, функциональности, приоритету или одному типу тестирования.
                      </li>
                      <li>Матрица соответствия (Traceability Matrix) <br>
                          Это двумерная таблица, содержащая
                          соответствие функциональных требований
                          (functional requirements) продукта и
                          подготовленных тестовых сценариев (test
                          cases). В заголовках колонок таблицы
                          расположены требования, а в заголовках
                          строк — тестовые сценарии. На
                          пересечении — отметка, означающая, что
                          требование текущей колонки покрыто
                          тестовым сценарием текущей строки.
                          Матрица обычно хранится в виде
                          электронной таблицы.
                          <a href="https://habr.com/ru/company/simbirsoft/blog/412677/">Обзор</a> <br>
                          <img src="../img/qc/Matrix.png" alt=""> <br>
                          <img src="../img/qc/tracematrix.png" alt=""> <br>
                          Это матрица покрытия требований тест-кейсами. <br>
                          При разработке тестов ориентироваться какие из требований уже покрыты. <br>
                          При выполнении тестирования ориентироваться какие из ребований прошли все написанные для них тесты успешно.
                      </li>
                  </ul>
              </li>
          </p>
      </details>
      </div>
  </details>
  <details class="menu__item"><!-- Mobile testing -->
      <summary>Mobile testing</summary>
      <div class="menu__inner">
          <ul>Native apps <br>
              Под нативным мы подразумеваем
              мобильное приложение, которое создается
              для определенной платформы и
              непосредственно устанавливается на
              устройство пользователя (занимая
              определенный объем памяти). Такие
              приложения пользователь загружает через
              магазин приложений той или иной
              платформы, такой как Play Store для Google
              и Apple App Store для iOS
              <li>Органично выглядят на телефоне</li>
              <li>Используют все функции программного обеспечения гаджета</li>
              <li>Имеют быстрый отклик и плавность анимаций интерфейса</li>
              <li>Надежнее (работают стабильнее)</li>
              <li>Экономнее расходуют ресурсы телефона: батарею, память</li>
              <li>Дорого в разработке</li>
          </ul>
          <ul>Web apps <br>
              Веб приложения работают через веб-
              браузер на устройстве пользователя. Эти
              приложения по сути являются
              индивидуализированными вебсайтами,
              которые сделаны таким образом, чтобы
              выглядеть и использоваться как нативные
              приложения, но на самом деле они не
              находятся на устройстве пользователя
              <li>Приложения на веб-основе легче поддерживаются
                  и они могут функционировать на платформе с
                  любой ОС</li>
              <li>Разработчики могут предлагать приложения без
                  необходимости их утверждения какими-либо
                  магазинами приложений</li>
              <li>Более быстрая разработка циклов с
                  использованием CSS, HTML и JavaScript</li>
              <li>Нет доступа к устройству пользователя</li>
              <li>Пользователи должны использовать их через сеть,
                  что значительно снижает контроль безопасности</li>
              <li>Поиск приложения может быть затруднительным,
                  так как не существует магазина приложений с
                  каталогом и функцией поиска в нем</li>
          </ul>
          <ul>Hybrid apps <br>
              Гибридные приложения являются чем-то
              средним между нативными и веб-
              приложениями. Фактически они создаются
              так, чтобы выглядеть и использоваться как
              нативные приложения. Их также
              устанавливают на телефон пользователя и
              их можно найти в магазинах приложений
              Различие заключается в том, что они
              обязательно должны размещаться в рамках
              нативного приложения и созданы, чтобы
              работать через WebView
              <li>Запускается не из браузера, возможно
                  независимое обновление</li>
              <li>Скорость разработки, а, следственно, и цена
                  значительно ниже, чем нативные приложения</li>
              <li>Возможность распространяться через магазины
                  приложений (в отличие от веб-приложений)</li>
              <li>Скорость и стабильность работы оставляют желать
                  лучшего</li>
              <li>Сложности в масштабировании и развитии проекта</li>
              <li>Сложности и нестабильность при использовании
                  различных модулей/ функций смартфона</li>
          </ul>
          <ul>Этапы разработки и тестирования
              <li>User Story</li>
              <li>Создание проекта и дизайна
                  <ul>UI
                      UI design — это визуальное оформление «изделия»: 
                      какие использовать цвета, удобно ли будет человеку попадать пальцем в кнопки, 
                      читабельным ли будет текст.
                      <li>Сравнить дизайн с эталонным вариантов <br>
                          Рекомендации: ios, android <br>
                          Реальные UI элементы ОС
                      </li>
                      <li>Проверка разработанного UI с дизайном продукта</li>
                  </ul>
                  <ul>UX
                      UX design — Опыт пользователя, опыт взаимодействия (User eXperience, UX) — это восприятие
                      и ответные действия пользователя, возникающие в результате использования 
                      и/или предстоящего использования продукции, системы или услуги. <br>
                      Принципы обеспечения UX
                      <li>Видимость статуса системы <br>
                          Пользователь должен всегда знать, что происходит, получая подходящую обратную связь в приемлемое время.</li>
                      <li>Соответствие между системой и реальным миром <br>
                          Система должна «говорить на языке пользователя», используя понятную ему терминологию и концепции, 
                          а не «системно-ориентированный» язык.</li>
                      <li>Управляемость и свобода для пользователя <br>
                          Пользователь часто выбирает системные функции по ошибке и должен иметь ясно видимый «аварийный выход»
                          из нежелаемого состояния системы, не требующий сложных диалогов. Следует поддерживать функции отмены (undo)
                          и повтора (redo).</li>
                      <li>Согласованность и стандарты <br>
                          Пользователи не должны гадать, значат ли одно и то же разные слова, ситуации или операции. 
                          Также нужно следовать соглашениям, принятым для данной платформы.</li>
                      <li>Предотвращение ошибок <br>Продуманный дизайн, который не позволяет какой-то проблеме даже возникнуть, лучше, 
                          чем самые хорошие сообщения об ошибках. Следует устранять сами условия возникновения ошибок, 
                          либо выявлять их и предупреждать пользователя о предстоящей проблеме.</li>
                      <li>Распознавать лучше, чем вспоминать <br>
                          Минимизируйте нагрузку на память пользователя, явно показывая ему объекты, действия и варианты выбора. 
                          Пользователь не должен в одной части диалога запоминать информацию, которая потребуется ему в другой. 
                          Инструкции по использованию системы должны быть видимы или легко получаемы везде, где возможно.</li>
                      <li>Эстетический и минималистический дизайн <br>
                          В интерфейсе не должно быть информации, которая не нужна пользователю или которая может понадобиться 
                          ему в редких случаях. 
                          Каждый избыточный элемент диалога отнимает внимание от нужных элементов.</li>
                      <li>Помочь пользователю понять и исправить ошибку <br>
                          Сообщения об ошибках следует писать простым языком, без кодов, 
                          чётко формулируя проблему и предлагая конструктивное решение.</li>
                      <li>Справка и документация</li>
                  </ul>
                  <ul>рекомендации по UX/UI:
                      <li>Удалите беспорядок</li>
                      <li>Сделайте навигацию самоочевидной</li>
                      <li>Создайте бесшовный опыт</li>
                      <li>Используйте правильные размеры целей нажатия 
                          (тэп таргеты)</li>
                      <li>Текст должен 
                          быть разборчивым</li>
                      <li>Элементы интерфейса должны быть ясно видны</li>
                      <li>Разработайте управление, основанное на расположении руки</li>
                      <li>Снизьте необходимость 
                          в наборе текста</li>
                      Так же, как с любыми другими элементами дизайна, советы, указанные выше – это только место для старта. 
                      Смешивайте и сочетайте эти идеи с вашим собственным для достижения наилучших результатов. Просто помните, что дизайн — не только для дизайнеров — он для пользователей.
                  </ul>
              </li>
              <li>Тестирование
                  <ul>Check list
                      <li>Все элементы должны быть такого размера, чтобы пользователь мог попасть по ним</li>
                      <li>Отсутствие пустых экранов в приложениях</li>
                      <li>Многократные нажатия на кнопки</li>
                      <li>Проверка нативных жестов в приложениях</li>
                      <li>Обработка ситуаций нехватки памяти, для работы приложения</li>
                      <li>Недостаток места для установки приложения</li>
                      <li>Отсутствие у приложений поддерживаемых функций (SD – карта, 3G)</li>
                      <li>Установка или перенос приложения на SD – карту</li>
                      <li>Соответствие правилам хорошего тона (Apple HIG, Google Material Design)</li>
                      <li>Размер элементов</li>
                      <li>Количество информации</li>
                      <li>Адаптация под разные размеры экранов</li>
                      <li>Проверка изменения ориентации устройства (Portrait, Landscape)</li>
                      <li>Отзывчивость на воздействия (Графическая, звуковая, тактильная)</li>
                      <li>Сообщения об ошибках</li>
                      <li>Цветовая гамма</li>
                      <li>Retina и обычные экраны (изображения для retina, попавшие в обычные 
                          устройства будут выглядеть очень большими)</li>
                      <li>Версии OS (Приложения не должны устанавливаться на неподдерживаемые версии OS)</li>
                      <li>Соответствие используемых экранов в приложении (Решения, которые имеют смысл для одной платформы, 
                          могут быть неуместны в другой)</li>
                      <li>Входящие и исходящие SMS, MMS, звонки, оповещения других приложений</li>
                      <li>Выключение устройства, изъятие аккумулятора, зарядка устройства</li>
                      <li>Переход в режим ожидания (В том числе и с защитой паролем)</li>
                      <li>Изменение ориентации устройства в режиме ожидания</li>
                      <li>Включение/отключение сети, GPS, авиа – режима, Bluetooth</li>
                      <li>Отключение/подключение SD – карты, физической клавиатуры, гарнитуры</li>
                      <li>Соответствие цены и содержимого, заявленного в приложении тому, что попадает к пользователю</li>
                      <li>Восстановление покупок</li>
                      <li>Сохранение покупок при обновлении приложения</li>
                      <li>Использование различных функциональных возможностей девайса (Например, кнопка Back на Android)</li>
                      <li>Проверка корректности перевода</li>
                      <li>Все переведенные слова, корректно располагаются в отведенных для них местах</li>
                      <li>Проверка форматов дат, разделителей в числах и других нетривиальных моментах</li>
                      <li>Проверка работоспособности в разных часовых регионах</li>
                      <li>Убедиться, что поддерживаются все версии из предыдущих релизов 
                          (если в приложении добавлена функциональность из новой версии ОС, 
                          то необходимо разрабатывать урезанный функционал для старых версий ОС)</li>
                      <li>Проверка обновлений (Сохранение всех данных пользователей, Авторизация)</li>
                      <li>Если приложение поддерживает Portrait/Landscape – уделите смене ориентации много времени</li>
                      <li>Лучше всего переходите между экранами во время взаимодействия с сетью</li>
                      <li>Запросы должны отменяться, если они не завершены</li>
                      <li>Использовать настройки разработчика: эмитирование слабого соединения, не сохранять действие 
                          (состояние активити - Android) и тд</li>
                      <li>Проверять деинсталляцию - удаление всех пользовательских данных</li>
                  </ul>
                  Основные особенности
                  <ul>Экран:
                      <li>Ориентация (landscape, portrait)</li>
                      <li>Разрешение экрана</li>
                      <li>Монобровь</li>    
                  </ul>
                  <ul>Ресурсы устройства
                      <li>Мало места для установки или работы</li>
                      <li>Установка и перенос на SD карту</li>
                      <li>Очистка данных при удалении</li>
                      <li>Утечки памяти</li>
                      <li>Работа с низким зарядом батареи</li>
                      <li>Переключение между wifi и mobile data</li>
                      <li>Переход из 4G в 3G</li>
                      <li>Отключение интернета</li>
                      <li>Работа с датчиками, Bluetooth, GPS, камерой, контактами</li>
                  </ul>
                  <ul>Usability
                      <li>Соответствие рекомендациям: <br>
                          - Apple Human Interface Guidline <br>
                          - Google Material Design</li>
                      <li>Размер элементов</li>
                      <li>Количество информации</li>
                      <li>Отклик на действие</li>
                      <li>Управление одной рукой</li>
                      <li>Push сообщения</li>
                      <li>Сообщения об ошибках и предупреждения</li>
                      <li>Прогресс бары</li>
                  </ul>
                  <ul>OS
                      <li>Отдельно Android, отдельно IOS</li>
                      <li>Разные версии OS</li>
                      <li>Приложение не должно устанавливаться
                          на неподдерживаемые OS</li>
                      <li>Требования AppStore и Google Play</li>
                  </ul>
                  <ul>Прерывания
                      <li>Звонки и SMS</li>
                      <li>Push сообщения</li>
                      <li>Выключение телефона</li>
                      <li>Вход / выход спящий режим</li>
                      <li>Изменение ориентации в спящем режиме</li>
                      <li>Включение / выключение GPS, Bluetooth</li>
                      <li>Отключение / подключения USB кабеля, SD
                          карты, клавиатуры, гарнитуры</li>
                  </ul>
                  <ul>Платный контент
                      <li>Соответствие цены и содержимого, заявленного в
                          приложении тому, что попадает к пользователю</li>
                      <li>Восстановление покупок</li>
                      <li>Сохранение покупок при обновлении приложения</li>
                  </ul>
                  <ul>Интернационализация
                      <li>Корректность перевода</li>
                      <li>Все слова помещаются в элементы</li>
                      <li>Форматы дат, разделителей в числах и другие
                          нетривиальные моменты</li>
                  </ul>
                  <ul>Обновления
                      <li>Обратная совместимость</li>
                      <li>Поддержка старых версий OS</li>
                      <li>Сохранение данных пользователей</li>
                      <li>Авторизация</li>
                  </ul>
                  <ul>Советы
                      <li>Если приложение поддерживает Portrait/Landscape – уделите
                          смене ориентации много времени</li>
                      <li>Лучше всего переходите между экранами во время
                          взаимодействия с сетью</li>
                      <li>Запросы должны отменяться, если они не завершены</li>
                      <li>Ответ от сервера на удаленный из памяти (невидимый) экран, не
                          должны крэшить приложение</li>
                      <li>Скриншоты, логи, видео</li>
                      <li>Использование «Обезьянок», для поиска крэшей и зависаний
                          (Android – UI Monkey Exerciser, iOS - CrashMonkey)</li>
                      <li>Использование Бета – версии (Для Android – встроенное в магазин
                          решение, для iOS - TestFlight). Желательно оборачиватиь
                          приложения в оболочки (Crashlytics, TestFairy, HockeyApp)</li>
                      <li>Использовать настройки разработчика</li>
                      <li>iOS – позволяет настраивать скорость интернет – соединения и
                          раздавать его используя устройство, как точку доступа, логировать
                          использование трафика и энергии, удобное тестирование iAd –
                          рекламы</li>
                      <li>Android – настройки на любой вкус – от отображения загрузки
                          процессора до изменения анимации интерфейса</li>
                      <li>Эмуляторы и симуляторы</li>
                  </ul>
              </li>
              <li>Мониторинг</li>
          </ul>
      </div>
  </details>
  <details class="menu__item"><!-- Web testing -->
      <summary>Web testing</summary>
      <div class="menu__inner">
          <ul>
              <li>GUI
                  <ul>у любого тестируемого предмета и
                      веб-приложения есть внешний вид, поэтому
                      тестирование графического интерфейса или
                      попросту, внешнего вида — это самое
                      первое, что мы можем сделать <br>
                      Верстка — размещение элементов веб-приложения (изображения, текст, кнопки, видео и т.д.) 
                      в соответствии с макетом или требованиями
                      <li>Сравнение с макетом</li>
                      <li>Измерение размеров элемента</li>
                      <li>Правильность шрифтов</li>
                      <li>Цвета интерфейса</li>
                      <li>Контент</li>
                      <li>Курсор</li>
                      <li>Масштабируемость</li>
                      <li>Фавикон</li>
                      <li>Заголовки, title</li>
                      <li>Браузерные расширения</li>
                      <li>Back button</li>
                      <li>Scroll</li>
                      <li>Стандарты HTML/CSS</li>
                      <li>Кодировка</li>
                      <li>Правильность перевода</li>
                      <li>Длина переведенных слов</li>
                      <li>Сокращения/аббревиатуры</li>
                      <li>Валюта</li>
                      <li>Шрифты</li>
                      <li>Дата / время, разделители чисел</li>
                      <li>Поиск</li>
                      <li>RTL (right to left languages)</li>
                  </ul>
              </li>
              <br>
              <li>Functional <br>
                  проверяем работоспособность и взаимодействие элементов
                  <ul>Label (метка):
                      <li>Один уровень с полями</li>
                      <li>Выровнены по отношению к друг другу</li>
                      <li>Длинные строки</li>
                  </ul>
                  <ul>Placeholder:
                      <li>Цвет шрифта</li>
                      <li>Отступ</li>
                      <li>Пропадает при вводе значения / фокусе</li>
                      <li>Появляется при очистке</li>
                      <li>Нельзя скопировать</li>
                  </ul>
                  <ul>Text field:
                      <li>Цвет шрифта, отступы</li>
                      <li>Граничные значения</li>
                      <li>Классы эквивалентности</li>
                      <li>Длинные строки</li>
                      <li>Маска паролей</li>
                      <li>Trim</li>
                      <li>Работа с текстом</li>
                  </ul>
                  <ul>Text area:
                      <li>Длина</li>
                      <li>Перенос слов</li>
                      <li>Маштабирование</li>
                      <li>Скролы</li>
                      <li>Enter (Ctrl-Enter)</li>
                  </ul>
                  <ul>Checkbox:
                      <li>Все состояния</li>
                      <li>Неактивный</li>
                      <li>Неактивный включенный</li>
                      <li>Взаимное расположение</li>
                  </ul>
                  <ul>Radiobutton:
                      <li>Значение по умолчанию</li>
                      <li>Неактивный</li>
                      <li>Неактивный включенный</li>
                      <li>Взаимное расположение</li>
                      <li>Отображение группы</li>
                  </ul>
                  <ul>Switcher:
                      <li>Значение по умолчанию</li>
                      <li>Неактивный</li>
                      <li>Неактивный включенный</li>
                      <li>Стили</li>
                  </ul>
                  <ul>Dropdown list:
                      <li>Значение по умолчанию</li>
                      <li>Длина опций</li>
                      <li>Длина списка</li>
                      <li>Выпадение вверх</li>
                      <li>Подсветка выделенной опции</li>
                      <li>Скрол</li>
                      <li>Поиск</li>
                      <li>Каскадные списки</li>
                  </ul>
                  <ul>Combo box:
                      <li>Значение по умолчанию / placeholder</li>
                      <li>Раскрытие списка</li>
                      <li>Длина опций</li>
                      <li>Подсветка выделенной опции</li>
                      <li>Поиск</li>
                      <li>Количество опций</li>
                      <li>Выпадение вверх</li>
                      <li>Скрол</li>
                      <li>Multiselection</li>
                      <li>Добавление / удаление вариантов</li>
                  </ul>
                  <ul>Button:
                      <li>Размер и положение</li>
                      <li>Enabled / Disabled</li>
                      <li>Enter (Ctrl-Enter)</li>
                      <li>Hover / Click эффекты</li>
                      <li>Длина текста</li>
                      <li>Текст с заглавной</li>
                  </ul>
                  <ul>Slider:
                      <li>Диапазон</li>
                      <li>Шкала</li>
                      <li>Метки</li>
                      <li>Связанное поле</li>
                      <li>Изменение клавиатурой</li>
                  </ul>
                  <ul>Date picker:
                      <li>Выбор даты</li>
                      <li>Ввод даты вручную</li>
                      <li>Формат даты</li>
                      <li>Граничные значения</li>
                      <li>Некорректная дата</li>
                      <li>29 февраля</li>
                  </ul>
                  <ul>Time picker:
                      <li>Выбор времени</li>
                      <li>Ввод времени вручную</li>
                      <li>Некорректное время</li>
                      <li>Время сервера</li>
                      <li>Временные зоны</li>
                  </ul>
                  <ul>Tabs:
                      <li>С заглавной буквы</li>
                      <li>Активная / Не активные</li>
                      <li>Hover эффект</li>
                  </ul>
                  <ul>Validation message:
                      <li>Текст отражает суть</li>
                      <li>Нет серверных ошибок</li>
                      <li>Красный цвет</li>
                      <li>Не должно ломать верстку</li>
                      <li>Исчезновение при исправлении</li>
                  </ul>
                  <ul>Popup:
                      <li>Расположение по центру</li>
                      <li>Закрытие по ESC</li>
                      <li>Закрытие по клику</li>
                      <li>Кнопка закрытия</li>
                  </ul>
                  <ul>Дополнительно:
                      <li>Разрыв соединения</li>
                      <li>Работа в нескольких вкладках</li>
                      <li>Проверка консоли и логов</li>
                      <li>Отключение Javascript</li>
                  </ul>
              </li>
              <br>
              <li>Usability
                  <ul>от этого зависит, будет ли востребован продукт вообще
                      <li>Соответствует ли приложение
                          ожиданиям конечного пользователя</li>
                      <li>Логичность интерфейса</li>
                      <li>Самое нужное «сверху»</li>
                      <li>Продуманная навигация</li>
                      <li>Минимизация действий</li>
                      <li>Локализация</li>
                      <li>Совместимость с другим софтом (соцсети) и
                          железом</li>
                      <li>Скорость работы приложения</li>
                      <li>Информативность (сообщения / обязательные
                          поля)</li>
                      <li>Возможность отмены действий пользователя</li>
                      <li>Подсказки и подтверждения</li>
                      <li>Help — должна быть инструкция, как работать с
                          приложением</li>
                  </ul>
              </li>
              <br>
              <li>Security
                  <ul>
                      <li>Матрица ролей</li>
                      <li>SQL – инъекции</li>
                      <li>XSS</li>
                      <li>HTML tags</li>
                  </ul>
              </li>
              <br>
              <li>Performance
                  <ul>
                      <li>Несколько сессий</li>
                      <li>Длительные сессии</li>
                      <li>Большое количество действий</li>
                      <li>Большие файлы</li>
                      <li>Сложные запросы</li>
                      <li>Низкая скорость интернета</li>
                      <li>Throttling</li>
                  </ul>
              </li>
              <br>
              <li>Configuration <br>
                  Кроссбраузерность
              </li>
          </ul>
      </div>
  </details>
  <details class="menu__item"><!-- APP -->
      <summary>APP</summary>
      <div class="menu__inner">
          <ul>Bug Tracking Systems: <br>
              <li>Jira <br>
                  <img src="../img/qc/BTS.png" alt=""><br>
                  коммерческая система
                  отслеживания ошибок. Разработана
                  компанией Atlassian, является одним
                  из двух её основных продуктов
                  (наряду с вики-системой Confluence).
                  Имеет веб-интерфейс. <a href="https://www.atlassian.com/ru/software/jira">Обзор</a><br>
              </li>
              <br>
              <li>JMeter <br>
                  <img src="../img/qc/per.png" alt="">
                  <ul>Инструмент нагрузочного тестирования
                      <li>Графический интерфейс</li>
                      <li>Кроссплатформенность (Написан на Java)</li>
                      <li>Бесплатно весь функционал</li>
                      <li>Генерация отчетов</li>
                      <li>Работа в консоли</li>
                      <li>Возможность расширения и тонкой настройки</li>
                      <li>Эмуляция одновременной работы пользователей</li>
                      <li>Распределенная нагрузка</li>
                      <li>Снятие метрик</li>
                  </ul>
              </li>
              <br>
              <li>Jenkins <br>
                  <img src="../img/qc/cicd.png" alt=""><br>
              </li>
              <li><a href="https://www.postman.com/"></a>Postman</li>
              <li><a href="https://www.telerik.com/fiddler"></a>Fiddler</li>
              <li><a href="https://www.charlesproxy.com/"></a>charles</li>
              <li>SoapUI</li>
              <li>REST-assured</li>
              <li>Selenium</li>
              <li>TestComplete</li>
              <li>Cypress</li>
          </ul>
      </div>
  </details>
  <details class="menu__item"><!--Automation-->
      <summary>Automation</summary>
      <div class="menu__inner">
          <img src="../img/qc/automation.png" alt="">
          <p>
              <dfn>Автоматизированное (автоматическое) тестирование</dfn> является составной частью процесса тестирования. <br>
              Оно использует программные средства для выполнения тестов и проверки результатов пробега этих тестов, 
              что помогает сократить время тестирования и упростить его процесс
          </p>
          <ul>Преимущества:
              <li><dfn>Повторяемость</dfn> – все написанные тесты всегда будут выполняться однообразно, то есть исключен «человеческий фактор». <br>
                  Тестировщик не пропустит тест по неосторожности и ничего не напутает в результатах</li>
              <li><dfn>Быстрое выполнение</dfn> – автоматизированному скрипту не нужно сверяться с инструкциями и документациями, это сильно экономит время выполнения</li>
              <li><dfn>Отчеты</dfn> – автоматически рассылаемые и сохраняемые отчеты о результатах тестирования</li>
              <li><dfn>Выполнение без вмешательства</dfn> – во время выполнения тестов инженер-тестировщик может заниматься другими полезными делами, 
                  или тесты могут выполняться в нерабочее время (этот метод предпочтительнее, так как нагрузка на локальные сети ночью снижена)</li>
          </ul>
          <ul>Недостатки:
              <li><dfn>Повторяемость</dfn> – все написанные тесты всегда будут выполняться однообразно. <br>
                  Это одновременно является и недостатком, так как тестировщик, выполняя тест вручную, может oбратить внимание на некоторые детали и,
                  проведя несколько дополнительных операций, найти дефект. <br>
                  Скрипт этого сделать не может</li>
              <li><dfn>Затраты на поддержку</dfn> – несмотря на то, что в случае автоматизированных тестов они меньше, чем затраты на ручное тестирование того же
                  функционала – они все же есть. <br>
                  Чем чаще изменяется приложение, тем они выше</li>
              <li><dfn>Большие затраты на разработку</dfn> – разработка автоматизированных тестов это сложный процесс, так как фактически идет разработка приложения,
                  которое тестирует другое приложение. <br>
                  В сложных автоматизированных тестах также есть фреймворки, утилиты, библиотеки и прочее. <br>
                  Естественно, все это нужно тестировать и отлаживать, а это требует времени</li>
              <li>Пропуск мелких ошибок – автоматический ckрипт может пропускать мелкие ошибки на проверку которых он не запрограммирован. <br>
                  Это могут быть неточности в позиционировании окон, ошибки в надписях, которые не проверяются, 
                  ошибки элементов и форм с которыми не осуществляется взаимодействие во время выполнения скрипта</li>
          </ul>
          <ul>Автоматизировать:
              <li>Unit Tests</li>
              <li>Smoke tests</li>
              <li>Integration tests</li>
              <li>Performance</li>
              <li>Regression</li>
          </ul>
          <ul>Применение:
              <li>Труднодоступные места в системе
                  (бэкенд процессы, логирование файлов,
                  запись в БД)</li>
              <li>Часто используемая функциональность,
                  риски от ошибок в которой достаточно
                  высоки. Автоматизировав проверку
                  критической функциональности, можно
                  гарантировать быстрое нахождение
                  ошибок, а значит и быстрое их решение</li>
              <li>Рутинные операции, такие как
                  переборы данных (формы с большим
                  количеством вводимых полей.
                  Автоматизировать заполнение полей
                  различными данными и их проверку
                  после сохранения)</li>
              <li>Валидационные сообщения
                  (Автоматизировать заполнение полей
                  не корректными данными и проверку
                  на появление той или иной валидации) </li>
              <li>Длинные end-to-end сценарии</li>
              <li>Проверка данных, требующих точных
                  математических расчетов</li>
              <li>Проверка правильности поиска данных</li>
          </ul>
          <ul>Случаи для автоматизации:
              <li>Функционал стабилен</li>
              <li>Большое количество ручных тестов и не хватает времени на регулярное проведение полного регресса</li>
              <li>Короткие циклы тестирования продукта</li>
              <li>Подготовка к тестированию (настройка конфигурации, генерация тестовых данных) занимает много времени</li>
              <li>Поддержка старых версий ПО, в которых нужно тестировать новые патчи и сервис-паки</li>
              <li>В каждом случае – если это экономически целесообразно</li>
              <li>Когда мануальное тестирование невозможно</li>
          </ul>
          <ul>Инструменты – Unit Tests
              <li>JUnit</li>
              <li>Nunit</li>
              <li>Mocha</li>
          </ul>
          <ul>UI automation tool <br>
              <li>selenium WebDriver Architecture</li>
              <li>Тесты подлежащие автоматизации: <br>
                  • часто повторяющиеся (ежедневно) <br>
                  • занимающие много времени <br>
                  • отработанные тесты (тесты для стабильного функционала, который уже в продакшине)
              </li>
              <li>ферма браузеров</li>
              <li>web driver</li>
              <li>xpaph</li>
              <li>functional testing automation</li>
              <li>layout testing automation</li>
              <li>поиск элементов по id, XPaph, css selectors</li>
          </ul>
      </div>
  </details>
  <details class="menu__item"><!--Interview-->
      <summary>Interview</summary>
      <div class="menu__inner">
          <dl>Manual testing questions:
              <dt>1. <em>What is software testing?</em></dt>
              <dd>- It is an investigation conducted to provide stakeholders with information 
                  about the quality of the software product or service under test. <br>
                  <em>OR</em> <br>
                  - It is a process of verifying a system with the purpose of identifying any errors,
                  gaps or missing information.
              </dd>
              <dt>2. <em>What is Quality Assurance?</em></dt>
              <dd>- QA is a way of preventing mistakes and defects in manufactured products
                  and avoiding problems when delivering products or services to customers.
              </dd>
              <dt>3. <em>What is Quality Control?</em></dt>
              <dd>QC is a set of procedures intended to ensure that a manufactured product or performed service 
                  adheres to a defined set of quality criteria.
              </dd>
              <dt>4. <em>What is the difference between verification and validation?</em></dt>
              <dd>Verification is the process of checking that a software achieves its goal without any bugs. <br>
                  Validation is the process of cheking whether the specification captures the customer's needs.
              </dd>
              <dt>5. <em>What is Test Plan?</em></dt>
              <dd>It is a document detailing the objectives, resources and processes for a specific test for a software
                  or hardware product.
              </dd>
              <dt>6. <em>What is Defect Density?</em></dt>
              <dd>It is a number of confirmed bugs in a software application during the period of development,
                  divided by the size of the software. <br>
                  <em>OR</em> <br>
                  It is the average number of defects per thousand lines of code.
              </dd>
              <dt>7. <em>What is stub?</em></dt>
              <dd>It is a piece of code used to stand in for some other programming functionality. <br>
                  A stub may simulate the behavior of existing code.
              </dd>
              <dt>8. <em>What is driver?</em></dt>
              <dd>It is a program that interacts with a particular device or special kind of software.</dd>
              <dt>9. <em>What is debugging?</em></dt>
              <dd>It is the process of finding and removing the causes of software failures.</dd>
              <dt>10. <em>What is Gorilla Testing</em></dt>
              <dd>It is a testing technique in which sometimes developers also join testers to test a particular module
                  thoroughly in all aspects.
              </dd>
              <dt>11. <em>What is Gray Box Testing?</em></dt>
              <dd>It is a combination of Black Box and White Dox testing methodologies.</dd>
              <dt>12. <em>What is Positive Testing?</em></dt>
              <dd>It is a testing aimed at showing software works. (Test to Pass).</dd>
              <dt>13. <em>What is Negative Testing?</em></dt>
              <dd>It is a testing aimed at showing software doesn't work. (Test to Fail).</dd>
              <dt>14. <em>What is Recovery Testing?</em></dt>
              <dd>It confirms that the program recovers from expected or unexpected events
                  without loss of date or functionality.
              </dd>
              <dt>15. <em>What is Release Candidate?</em></dt>
              <dd>It is a prerelease version, which contains the desired functionality of the final version,
                  but which needs to be tested for bugs.
              </dd>
              <dt>16. <em>Why does software have bugs?</em></dt>
              <dd>- miscommunication <br>
                  - programming errors <br>
                  - time pressure <br>
                  - changing requirements <br>
                  - software complexity
              </dd>
              <dt>17. <em>What is Test Environment?</em></dt>
              <dd>It is the hardware and software environment in which test will be run.</dd>
              <dt>18. <em>What is Traceability Matrix?</em></dt>
              <dd>It is a document showing the relationship between Test Requirements and Test Cases.</dd>
              <dt>19. <em>What is Good Code?</em></dt>
              <dd>Good Code is a code that works, is bug free, is readable and maintainable.</dd>
              <dt>20. <em>What is Test Harness?</em></dt>
              <dd>It is a collection of stub and drivers and other supporting tools to conduct a test.</dd>
              <dt>21. <em>How to perform testing when there are no documents?</em></dt>
              <dd>Ad hoc testing is done without use of any documentation or planning. <br>
                  This is the least formal type of testing. <br>
                  To perform this type of testing, tester needs to have in-depth understanding of the application
                  and all its functional flows.
              </dd>
              <dt>22. <em>Define a web server.</em></dt>
              <dd>Wed server follows the client/server model where the program uses HTTP.</dd>
              <dt>23. <em>What is the difference between Authorization and Authentication?</em></dt>
              <dd>Authentication is the process with which the system identifies who the user is. <br>
                  Authorization is the process with which the system identifies what user is authorized to do.
              </dd>
              <dt>24. <em>Define HTTP.</em></dt>
              <dd>HTTP is the data transfer protocol that defines how messages are formatted 
                  and transferred over the world wide web.</dd>
              <dt>25. <em>What is the difference between Static and Dynamic website?</em></dt>
              <dd>Static website is the one which gives out information only 
                  and there is no sort of interaction between the user and the website. <br>
                  Dynamic website is the one where interaction is possible between the website and the user.
              </dd>
              <dt>26. <em>What is Proxy server?</em></dt>
              <dd>It is a server that acts as an intermediary or is one that lies between the client and the main server.</dd>
              <dt>27. <em>What is Priority?</em></dt>
              <dd>It indicates the importance or urgency of fixing a defect.</dd>
              <dt>28. <em>When can the testing be stopped?</em></dt>
              <dd>- deadlines <br>
                  - test cases completed with certain percentage passed <br>
                  - test budget depleted <br>
                  - bug rate falls below a certain level <br>
                  - beta and alpha testing period ends <br>
              </dd>
              <dt>29. <em>What's the goal of a software tester?</em></dt>
              <dd>The goal of a software tester is to find bugs, find them as early as possible,
                  and make shure they get fixed.
              </dd>
              <dt>30. <em>What's the difference between translation and localization?</em></dt>
              <dd>Translation is concerned only with the language aspects - translating the words. <br>
                  Localization takes into account the customs, conventions, and culture of the region or locale.
              </dd>
              <dt>31. <em>What might you include in a quality assurance testing document?</em></dt>
              <dd>Test Plans, Test Scenarios, Test Cases, Check list, Bug Report, Traceability Matrix, Test Suits.</dd>
              <dt>32. <em>What is a bug?</em></dt>
              <dd>A bug is any kind of error, mistake or failure in software code that prevents 
                  the software function from executing properly.</dd>
              <dt>33. <em>What is the difference between severity and priority?</em></dt>
              <dd>Severity is how difficult the issue is to fix. <br>
                  Priority is how important the issue is to fix.
              </dd>
          </dl>
          <ul>
              <li>Как составлять тест-кейсы?</li>
              <li>Как составлять чек-листы?</li>
              <li>Что такое классы эквивалентности и как их выделять?</li>
              <li>Что такое метод граничных значений?</li>
              <li>Как правильно оформить баг?</li>
              <li>Какие бывают виды и уровни тестирования?</li>
              <li>Что такое клиент-серверная архитектура и как она работает?</li>
          </ul>
      </div>
  </details>
  <img src="../img/qc/QCways.png" alt=""/> <br>
  <br>
  <a class="resources" href="https://lms.ithillel.ua/auth">hillel</a> <br>
  <a class="resources" href="https://habr.com/en/companies/badoo/articles/301764/">habr</a> <br>
  <a class="resources" href="https://habr.com/en/feed/">habr</a> <br>
  <a class="resources" href="https://www.portnov.com/">portnov</a> <br>
  <a class="resources" href="https://www.youtube.com/watch?v=JbhG8bruYsU&list=PL7XXjge0nKZfUjvs_puLSXpkV-dBrihZu">Курс</a> <br>
  <a class="resources" href="https://software-testing.ru/">software</a> <br>
  <a class="resources" href="https://dou.ua/">dou</a> <br>
  <a class="resources" href="https://www.themoviedb.org/">themoviedb</a> <br>
  <a class="resources" href="https://www.guru99.com/">guru99</a> <br>
  <a class="resources" href="drow.io">drow</a> <br>

</body>
</html>